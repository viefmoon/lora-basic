This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.gitignore
include/BLE.h
include/clsPCA9555.h
include/config_manager.h
include/config.h
include/debug.h
include/HardwareManager.h
include/LoRaManager.h
include/MAX31865.h
include/ModbusMaster.h
include/ModbusSensorManager.h
include/PowerManager.h
include/RTCManager.h
include/sensor_constants.h
include/sensor_types.h
include/SensorManager.h
include/SleepManager.h
include/util/crc16.h
include/util/word.h
include/utilities.h
lib/README
platformio.ini
src/BLE.cpp
src/clsPCA9555.cpp
src/config_manager.cpp
src/HardwareManager.cpp
src/LoRaManager.cpp
src/main.cpp
src/MAX31865.cpp
src/ModbusMaster.cpp
src/ModbusSensorManager.cpp
src/PowerManager.cpp
src/RTCManager.cpp
src/SensorManager.cpp
src/SleepManager.cpp
src/utilities.cpp
test/README

================================================================
Files
================================================================

================
File: .gitignore
================
.pio
.vscode/.browse.c_cpp.db*
.vscode/c_cpp_properties.json
.vscode/launch.json
.vscode/ipch

================
File: include/BLE.h
================
#ifndef BLE_H
#define BLE_H

#include <Arduino.h>
#include <BLEDevice.h>
#include <BLEServer.h>
#include <BLEAdvertising.h>
#include <BLECharacteristic.h>
#include <ArduinoJson.h>
#include "clsPCA9555.h"
#include "config.h"
#include "config_manager.h"
#include "debug.h"

// Clase para gestionar toda la funcionalidad BLE
class BLEHandler {
public:
    /**
     * @brief Verifica si se mantuvo presionado el botón de configuración y activa el modo BLE.
     * @param ioExpander Referencia al expansor de I/O para controlar el LED
     * @return true si se activó el modo BLE, false en caso contrario
     */
    static bool checkConfigMode(PCA9555& ioExpander);

    /**
     * @brief Inicializa el BLE con el nombre del dispositivo basado en el devEUI
     * @param devEUI Identificador único del dispositivo
     * @return Puntero al servidor BLE creado
     */
    static BLEServer* initBLE(const String& devEUI);

    /**
     * @brief Configura los servicios y características BLE
     * @param pServer Servidor BLE donde se configurarán los servicios
     * @return Puntero al servicio BLE creado
     */
    static BLEService* setupService(BLEServer* pServer);

    /**
     * @brief Ejecuta el bucle de parpadeo del LED en modo configuración
     * @param ioExpander Referencia al expansor de I/O para controlar el LED
     */
    static void runConfigLoop(PCA9555& ioExpander);

private:
    // Callback para eventos del servidor BLE
    class ServerCallbacks: public BLEServerCallbacks {
    public:
        void onConnect(BLEServer* pServer) override;
        void onDisconnect(BLEServer* pServer) override;
    };

    // Callback para configuración del sistema
    class SystemConfigCallback: public BLECharacteristicCallbacks {
        void onWrite(BLECharacteristic *pCharacteristic) override;
        void onRead(BLECharacteristic *pCharacteristic) override;
    };

#ifdef DEVICE_TYPE_ANALOGIC
    // Callback para NTC 100K
    class NTC100KConfigCallback: public BLECharacteristicCallbacks {
        void onWrite(BLECharacteristic *pCharacteristic) override;
        void onRead(BLECharacteristic *pCharacteristic) override;
    };

    // Callback para NTC 10K
    class NTC10KConfigCallback: public BLECharacteristicCallbacks {
        void onWrite(BLECharacteristic *pCharacteristic) override;
        void onRead(BLECharacteristic *pCharacteristic) override;
    };

    // Callback para Conductividad
    class ConductivityConfigCallback: public BLECharacteristicCallbacks {
        void onWrite(BLECharacteristic *pCharacteristic) override;
        void onRead(BLECharacteristic *pCharacteristic) override;
    };

    // Callback para pH
    class PHConfigCallback: public BLECharacteristicCallbacks {
        void onWrite(BLECharacteristic *pCharacteristic) override;
        void onRead(BLECharacteristic *pCharacteristic) override;
    };
#endif

    // Callback para configuración de sensores
#if defined(DEVICE_TYPE_BASIC) || defined(DEVICE_TYPE_ANALOGIC) || defined(DEVICE_TYPE_MODBUS)
    class SensorsConfigCallback: public BLECharacteristicCallbacks {
        void onWrite(BLECharacteristic *pCharacteristic) override;
        void onRead(BLECharacteristic *pCharacteristic) override;
    };
#endif

    // Callback para configuración de LoRa
    class LoRaConfigCallback: public BLECharacteristicCallbacks {
        void onWrite(BLECharacteristic *pCharacteristic) override;
        void onRead(BLECharacteristic *pCharacteristic) override;
    };
};

#endif // BLE_H

================
File: include/clsPCA9555.h
================
/*
 * clsPCA9555.h
 *
 *  Created on: 27 jul. 2015
 *      Author: Nico
 */

#ifndef CLSPCA9555_H_
#define CLSPCA9555_H_

#if defined(ARDUINO) && ARDUINO >= 100
#include "Arduino.h"
#else
#include "WProgram.h"
#endif

#define DEBUG 1

#include "config.h"

/** enum with names of ports ED0 - ED15 */
enum {
    ED0, ED1, ED2 , ED3 , ED4 , ED5 , ED6 , ED7 ,
    ED8, ED9, ED10, ED11, ED12, ED13, ED14, ED15
};

/** enum with names of the ports as they're referred to on the TI datasheet */
enum {
    P00, P01, P02, P03, P04, P05, P06, P07,
    P10, P11, P12, P13, P14, P15, P16, P17,
};

//
// PCA9555 defines
//
#define NXP_INPUT      0
#define NXP_OUTPUT     2
#define NXP_INVERT     4
#define NXP_CONFIG     6

class PCA9555 {
public:
    PCA9555(uint8_t address, int sda, int scl, int interruptPin = -1);
    PCA9555(uint8_t address, int interruptPin = -1);
    void pinMode(uint8_t pin, uint8_t IOMode );          // pinMode
    uint8_t digitalRead(uint8_t pin);                    // digitalRead
    void digitalWrite(uint8_t pin, uint8_t value );      // digitalWrite
    uint8_t stateOfPin(uint8_t pin);                     // Actual ISR
    void setClock(uint32_t clockFrequency);              // Clock speed
    bool begin();                                        // Checks if PCA is responsive
    void sleep();

private:
    static PCA9555* instancePointer;
    static void alertISR(void); // Function pointing to actual ISR
    void pinStates();           // Function tied to interrupt

    //
    // low level methods
    //
    uint16_t I2CGetValue(uint8_t address, uint8_t reg);
    void I2CSetValue(uint8_t address, uint8_t reg, uint8_t value);

    union {
        struct {
            uint8_t _stateOfPins_low;          // low order byte
            uint8_t _stateOfPins_high;         // high order byte
        };
        uint16_t _stateOfPins;                 // 16 bits presentation
    };
    union {
        struct {
            uint8_t _configurationRegister_low;          // low order byte
            uint8_t _configurationRegister_high;         // high order byte
        };
        uint16_t _configurationRegister;                 // 16 bits presentation
    };
    union {
        struct {
            uint8_t _valueRegister_low;                  // low order byte
            uint8_t _valueRegister_high;                 // high order byte
        };
        uint16_t _valueRegister;
    };
    uint8_t _address;                                    // address of port this class is supporting
    int _error;                                          // error code from I2C
    int _sda;
    int _scl;
};


#endif /* CLSPCA9555_H_ */

================
File: include/config_manager.h
================
#pragma once
#include <Preferences.h>
#include <vector>
#include <Arduino.h>  // Se incluye para utilizar el tipo String
#include "sensor_types.h"
#include <RadioLib.h> // Añadido para RADIOLIB_LORAWAN_SESSION_BUF_SIZE
#include "config.h"

// Definición de la estructura para la configuración de LoRa
struct LoRaConfig {
    //FOR OTAA
    String joinEUI;
    String devEUI;
    String nwkKey;
    String appKey;
};

class ConfigManager {
public:
    /* =========================================================================
       INICIALIZACIÓN Y CONFIGURACIÓN DEL SISTEMA
       ========================================================================= */
    // Verificación e inicialización
    static bool checkInitialized();
    static void initializeDefaultConfig();
    
    // Configuración del sistema
    static void getSystemConfig(bool &initialized, uint32_t &sleepTime, String &deviceId, String &stationId);
    static void setSystemConfig(bool initialized, uint32_t sleepTime, const String &deviceId, const String &stationId);

    /* =========================================================================
       CONFIGURACIÓN DE SENSORES NO-MODBUS
       ========================================================================= */
    // Gestión de sensores generales
    static void setSensorsConfigs(const std::vector<SensorConfig>& configs);
    static std::vector<SensorConfig> getAllSensorConfigs();
    static std::vector<SensorConfig> getEnabledSensorConfigs();

    /* =========================================================================
       CONFIGURACIÓN DE SENSORES MODBUS
       ========================================================================= */
    static void setModbusSensorsConfigs(const std::vector<ModbusSensorConfig>& configs);
    static std::vector<ModbusSensorConfig> getAllModbusSensorConfigs();
    static std::vector<ModbusSensorConfig> getEnabledModbusSensorConfigs();
    
    /* =========================================================================
       CONFIGURACIÓN DE LORA
       ========================================================================= */
    static LoRaConfig getLoRaConfig();
    static void setLoRaConfig(
        const String &joinEUI, 
        const String &devEUI, 
        const String &nwkKey, 
        const String &appKey);
    
#ifdef DEVICE_TYPE_ANALOGIC
    /* =========================================================================
       CONFIGURACIÓN DE SENSORES ANALÓGICOS (Solo para dispositivo analógico)
       ========================================================================= */
    // NTC 100K
    static void getNTC100KConfig(double& t1, double& r1, double& t2, double& r2, double& t3, double& r3);
    static void setNTC100KConfig(double t1, double r1, double t2, double r2, double t3, double r3);
    
    // NTC 10K
    static void getNTC10KConfig(double& t1, double& r1, double& t2, double& r2, double& t3, double& r3);
    static void setNTC10KConfig(double t1, double r1, double t2, double r2, double t3, double r3);
    
    // Conductividad
    static void getConductivityConfig(float& calTemp, float& coefComp, 
                                    float& v1, float& t1, float& v2, float& t2, float& v3, float& t3);
    static void setConductivityConfig(float calTemp, float coefComp,
                                    float v1, float t1, float v2, float t2, float v3, float t3);
    
    // pH
    static void getPHConfig(float& v1, float& t1, float& v2, float& t2, float& v3, float& t3, float& defaultTemp);
    static void setPHConfig(float v1, float t1, float v2, float t2, float v3, float t3, float defaultTemp);
#endif

private:
    // Configuraciones por defecto
    static const SensorConfig defaultConfigs[]; // Configs no-Modbus
};

================
File: include/config.h
================
#ifndef CONFIG_H
#define CONFIG_H

// Descomentar solo UNO de los siguientes
//#define DEVICE_TYPE_BASIC
//#define DEVICE_TYPE_ANALOGIC
#define DEVICE_TYPE_MODBUS

// Configuración de depuración - Comentar para deshabilitar mensajes de depuración
// #define DEBUG_ENABLED

#ifdef DEVICE_TYPE_BASIC

// Pines generales
#define ONE_WIRE_BUS        0
#define I2C_SDA_PIN         19
#define I2C_SCL_PIN         18
#define I2C_ADDRESS_PCA9555 0x20

// SPI
#define SPI_SCK_PIN         10
#define SPI_MISO_PIN        6
#define SPI_MOSI_PIN        7
#define SPI_RTD_CLOCK       1000000
#define SPI_RADIO_CLOCK     100000

// PT100
#define PT100_CS_PIN        P03

// Modo Config
#define CONFIG_PIN          2
#define CONFIG_TRIGGER_TIME 5000
#define CONFIG_TIMEOUT      30000
#define CONFIG_LED_PIN      P11

// LoRa
#define LORA_NSS_PIN        8
#define LORA_BUSY_PIN       4
#define LORA_RST_PIN        5
#define LORA_DIO1_PIN       3

// Serial
#define SERIAL_BAUD_RATE        9600

// Deep Sleep
#define DEFAULT_TIME_TO_SLEEP   30

// Identificadores
#define DEFAULT_DEVICE_ID   "DEV001"
#define DEFAULT_STATION_ID  "ST001"

// LoRa (OTAA)
#define DEFAULT_JOIN_EUI    "00,00,00,00,00,00,00,00"
#define DEFAULT_DEV_EUI     "1f,d4,e6,68,46,8c,e1,b7"
#define DEFAULT_APP_KEY     "1d,fb,69,80,69,d6,a0,7e,5d,bf,29,ba,6b,37,d3,04"
#define DEFAULT_NWK_KEY     "82,91,e9,55,19,ab,c0,6c,86,25,63,68,e7,f4,5a,89"

// LoRa Region y SubBand
#define LORA_REGION         US915
#define LORA_SUBBAND        2       // For US915, use 2; for other regions, use 0

#define BLE_SERVICE_UUID             "180A"
#define BLE_CHAR_SYSTEM_UUID         "2A37"
#define BLE_CHAR_SENSORS_UUID        "2A40"
#define BLE_CHAR_LORA_CONFIG_UUID    "2A41"

// Calibración batería
const double R1 = 470000.0;
const double R2 = 1500000.0;
const double conversionFactor = (R1 + R2) / R1;

// Namespaces
#define NAMESPACE_SYSTEM        "system"
#define NAMESPACE_SENSORS       "sensors"
#define NAMESPACE_LORAWAN       "lorawan"
#define NAMESPACE_LORA_SESSION  "lorasession"

// Claves
#define KEY_INITIALIZED         "initialized"
#define KEY_SLEEP_TIME          "sleep_time"
#define KEY_STATION_ID          "stationId"
#define KEY_DEVICE_ID           "deviceId"
#define KEY_VOLT                "volt"
#define KEY_SENSOR              "k"
#define KEY_SENSOR_ID           "id"
#define KEY_SENSOR_ID_TEMPERATURE_SENSOR "ts"
#define KEY_SENSOR_TYPE         "t"
#define KEY_SENSOR_CHANNEL      "ch"
#define KEY_SENSOR_VALUE        "v"
#define KEY_SENSOR_ENABLE       "e"
#define KEY_LORA_JOIN_EUI       "joinEUI"
#define KEY_LORA_DEV_EUI        "devEUI"
#define KEY_LORA_NWK_KEY        "nwkKey"
#define KEY_LORA_APP_KEY        "appKey"
#define KEY_LORAWAN_SESSION     "lorawan_session"

// Tamaños de documentos JSON - Centralizados
#define JSON_DOC_SIZE_SMALL   300
#define JSON_DOC_SIZE_MEDIUM  1024
#define JSON_DOC_SIZE_LARGE   2048

// Batería
#define BATTERY_PIN             1

//Power Manager
#define POWER_3V3_PIN           P00
#define POWER_STABILIZE_DELAY   20

// Configuración default sensores
#define DEFAULT_SENSOR_CONFIGS { \
    {"R", "RTD1", RTD, 0, "", true}, \
    {"D", "DS1", DS18B20, 0, "", true}, \
    {"I2C", "SHT30", SHT30, 0, "", true} \
}

#endif


#ifdef DEVICE_TYPE_ANALOGIC

// Pines generales
#define ONE_WIRE_BUS        0
#define I2C_SDA_PIN         19
#define I2C_SCL_PIN         18
#define I2C_ADDRESS_PCA9555 0x20

// SPI
#define SPI_SCK_PIN         10
#define SPI_MISO_PIN        6
#define SPI_MOSI_PIN        7
#define SPI_RTD_CLOCK       1000000
#define SPI_RADIO_CLOCK     100000

// PT100
#define PT100_CS_PIN        P03

// Modo Config
#define CONFIG_PIN          2
#define CONFIG_TRIGGER_TIME 5000
#define CONFIG_TIMEOUT      30000
#define CONFIG_LED_PIN      P11

// LoRa
#define LORA_NSS_PIN        8
#define LORA_BUSY_PIN       4
#define LORA_RST_PIN        5
#define LORA_DIO1_PIN       3

// Serial
#define SERIAL_BAUD_RATE         9600

// Deep Sleep
#define DEFAULT_TIME_TO_SLEEP   30

// Identificadores
#define DEFAULT_DEVICE_ID   "DEV001"
#define DEFAULT_STATION_ID  "ST001"

// LoRa (OTAA)
#define DEFAULT_JOIN_EUI    "00,00,00,00,00,00,00,00"
#define DEFAULT_DEV_EUI     "1f,d4,e6,68,46,8c,e1,b7"
#define DEFAULT_APP_KEY     "1d,fb,69,80,69,d6,a0,7e,5d,bf,29,ba,6b,37,d3,04"
#define DEFAULT_NWK_KEY     "82,91,e9,55,19,ab,c0,6c,86,25,63,68,e7,f4,5a,89"

// LoRa Region y SubBand
#define LORA_REGION         US915
#define LORA_SUBBAND        2       // For US915, use 2; for other regions, use 0

#define BLE_SERVICE_UUID             "180A"
#define BLE_CHAR_SYSTEM_UUID         "2A37"
#define BLE_CHAR_SENSORS_UUID        "2A40"
#define BLE_CHAR_LORA_CONFIG_UUID    "2A41"

// Calibración batería
const double R1 = 470000.0;
const double R2 = 1500000.0;
const double conversionFactor = (R1 + R2) / R1;

// Namespaces
#define NAMESPACE_SYSTEM        "system"
#define NAMESPACE_SENSORS       "sensors"
#define NAMESPACE_LORAWAN       "lorawan"
#define NAMESPACE_LORA_SESSION  "lorasession"
#define NAMESPACE_SENSORS_MODBUS "sensors_modbus"

// Claves
#define KEY_INITIALIZED         "initialized"
#define KEY_SLEEP_TIME          "sleep_time"
#define KEY_STATION_ID          "stationId"
#define KEY_DEVICE_ID           "deviceId"
#define KEY_VOLT                "volt"
#define KEY_SENSOR              "k"
#define KEY_SENSOR_ID           "id"
#define KEY_SENSOR_ID_TEMPERATURE_SENSOR "ts"
#define KEY_SENSOR_TYPE         "t"
#define KEY_SENSOR_CHANNEL      "ch"
#define KEY_SENSOR_VALUE        "v"
#define KEY_SENSOR_ENABLE       "e"
#define KEY_LORA_JOIN_EUI       "joinEUI"
#define KEY_LORA_DEV_EUI        "devEUI"
#define KEY_LORA_NWK_KEY        "nwkKey"
#define KEY_LORA_APP_KEY        "appKey"
#define KEY_LORAWAN_SESSION     "lorawan_session"

// Claves para Modbus
#define KEY_MODBUS_SENSOR_ID    "id"
#define KEY_MODBUS_SENSOR_TYPE  "t"
#define KEY_MODBUS_SENSOR_ADDR  "ad"
#define KEY_MODBUS_SENSOR_ENABLE "e"

// Configuración Modbus
#define MODBUS_BAUDRATE         9600
#define MODBUS_SERIAL_CONFIG    SERIAL_8N1
#define MODBUS_RESPONSE_TIMEOUT 1000  // Tiempo de espera para respuesta en ms


// Tamaños de documentos JSON - Centralizados
#define JSON_DOC_SIZE_SMALL   300
#define JSON_DOC_SIZE_MEDIUM  1024
#define JSON_DOC_SIZE_LARGE   2048

// Batería
#define BATTERY_ADC_CHANNEL     1
#define BATTERY_ADC_PIN         BATTERY_ADC_CHANNEL
#define POWER_3V3_PIN           P00
#define POWER_12V_PIN           P01
#define POWER_2V5_PIN           P02
#define POWER_STABILIZE_DELAY   20

// ADC m08
#define ADC_CS_PIN    P05
#define ADC_DRDY_PIN  P06
#define ADC_RST_PIN   P13
#define SPI_ADC_CLOCK 100000

// FlowSensor
#define FLOW_SENSOR_PIN 14

// BLE
#define BLE_CHAR_NTC100K_UUID        "2A38"
#define BLE_CHAR_NTC10K_UUID         "2A39"
#define BLE_CHAR_CONDUCTIVITY_UUID   "2A3C"
#define BLE_CHAR_PH_UUID             "2A3B"

// Namespaces analógicos
#define NAMESPACE_NTC100K   "ntc_100k"
#define NAMESPACE_NTC10K    "ntc_10k"
#define NAMESPACE_COND      "cond"
#define NAMESPACE_PH        "ph"

// Calibración NTC 100K
#define DEFAULT_T1_100K     25.0
#define DEFAULT_R1_100K     100000.0
#define DEFAULT_T2_100K     35.0
#define DEFAULT_R2_100K     64770.0
#define DEFAULT_T3_100K     45.0
#define DEFAULT_R3_100K     42530.0

// Calibración NTC 10K
#define DEFAULT_T1_10K      25.0
#define DEFAULT_R1_10K      10000.0
#define DEFAULT_T2_10K      35.0
#define DEFAULT_R2_10K      6477.0
#define DEFAULT_T3_10K      45.0
#define DEFAULT_R3_10K      4253.0

// Calibración Conductividad
#define CONDUCTIVITY_DEFAULT_V1    0.5f
#define CONDUCTIVITY_DEFAULT_T1    200.0f
#define CONDUCTIVITY_DEFAULT_V2    1.0f
#define CONDUCTIVITY_DEFAULT_T2    1000.0f
#define CONDUCTIVITY_DEFAULT_V3    1.5f
#define CONDUCTIVITY_DEFAULT_T3    2000.0f
#define TEMP_COEF_COMPENSATION     0.02f
#define CONDUCTIVITY_DEFAULT_TEMP  25.0f

// Calibración pH
#define PH_DEFAULT_V1          0.4425
#define PH_DEFAULT_T1          4.01
#define PH_DEFAULT_V2          0.001
#define PH_DEFAULT_T2          6.86
#define PH_DEFAULT_V3         -0.32155
#define PH_DEFAULT_T3          9.18
#define PH_DEFAULT_TEMP        25.0

// Claves NTC100K
#define KEY_NTC100K_T1         "n100k_t1"
#define KEY_NTC100K_R1         "n100k_r1"
#define KEY_NTC100K_T2         "n100k_t2"
#define KEY_NTC100K_R2         "n100k_r2"
#define KEY_NTC100K_T3         "n100k_t3"
#define KEY_NTC100K_R3         "n100k_r3"

// Claves NTC10K
#define KEY_NTC10K_T1          "n10k_t1"
#define KEY_NTC10K_R1          "n10k_r1"
#define KEY_NTC10K_T2          "n10k_t2"
#define KEY_NTC10K_R2          "n10k_r2"
#define KEY_NTC10K_T3          "n10k_t3"
#define KEY_NTC10K_R3          "n10k_r3"

// Claves Conductividad
#define KEY_CONDUCT_CT         "c_ct"
#define KEY_CONDUCT_CC         "c_cc"
#define KEY_CONDUCT_V1         "c_v1"
#define KEY_CONDUCT_T1         "c_t1"
#define KEY_CONDUCT_V2         "c_v2"
#define KEY_CONDUCT_T2         "c_t2"
#define KEY_CONDUCT_V3         "c_v3"
#define KEY_CONDUCT_T3         "c_t3"

// Claves pH
#define KEY_PH_V1              "ph_v1"
#define KEY_PH_T1              "ph_t1"
#define KEY_PH_V2              "ph_v2"
#define KEY_PH_T2              "ph_t2"
#define KEY_PH_V3              "ph_v3"
#define KEY_PH_T3              "ph_t3"
#define KEY_PH_CT              "ph_ct"

// Configuración default sensores
#define DEFAULT_SENSOR_CONFIGS { \
    {"0", "NTC1",  N100K,  0, "", true}, \
    {"1", "NTC2",  N100K,  1, "", true}, \
    {"2", "CH1",   CONDH,  2, "", true}, \
    {"3", "SM1",   SOILH,  3, "", true}, \
    {"4", "SM2",   SOILH,  4, "", true}, \
    {"5", "CON1",  COND,   5, "", true}, \
    {"7", "PH1",   PH,     7, "", true}, \
    {"R", "RTD1",  RTD,    0, "", true}, \
    {"D", "DS1",   DS18B20,0, "", true}, \
    {"I2C", "SHT30", SHT30, 0, "", true} \
}


#define DEFAULT_MODBUS_SENSOR_CONFIGS { \
    {"ModbusEnv1", ENV_SENSOR, 1, true} \
}

#endif


#ifdef DEVICE_TYPE_MODBUS

// Pines generales
#define I2C_SDA_PIN         19
#define I2C_SCL_PIN         18
#define I2C_ADDRESS_PCA9555 0x20

// SPI
#define SPI_SCK_PIN         10
#define SPI_MISO_PIN        6
#define SPI_MOSI_PIN        7
#define SPI_RTD_CLOCK       1000000
#define SPI_RADIO_CLOCK     100000

// PT100
#define PT100_CS_PIN        P03

// FlowSensor
#define FLOW_SENSOR_PIN     0

// Batería
#define BATTERY_PIN         1

// Modo Config
#define CONFIG_PIN          2
#define CONFIG_TRIGGER_TIME 5000
#define CONFIG_TIMEOUT      30000
#define CONFIG_LED_PIN      P11

// LoRa
#define LORA_NSS_PIN        8
#define LORA_BUSY_PIN       4
#define LORA_RST_PIN        5
#define LORA_DIO1_PIN       3

// Serial
#define SERIAL_BAUD_RATE         9600

// Deep Sleep
#define DEFAULT_TIME_TO_SLEEP   30

// Identificadores
#define DEFAULT_DEVICE_ID   "DEV001"
#define DEFAULT_STATION_ID  "ST001"

// LoRa (OTAA)
#define DEFAULT_JOIN_EUI    "00,00,00,00,00,00,00,00"
#define DEFAULT_DEV_EUI     "1f,d4,e6,68,46,8c,e1,b7"
#define DEFAULT_APP_KEY     "1d,fb,69,80,69,d6,a0,7e,5d,bf,29,ba,6b,37,d3,04"
#define DEFAULT_NWK_KEY     "82,91,e9,55,19,ab,c0,6c,86,25,63,68,e7,f4,5a,89"

// LoRa Region y SubBand
#define LORA_REGION         US915
#define LORA_SUBBAND        2

#define BLE_SERVICE_UUID             "180A"
#define BLE_CHAR_SYSTEM_UUID         "2A37"
#define BLE_CHAR_SENSORS_UUID        "2A40"
#define BLE_CHAR_LORA_CONFIG_UUID    "2A41"

// Calibración batería
const double R1 = 470000.0;
const double R2 = 1500000.0;
const double conversionFactor = (R1 + R2) / R1;

// Namespaces
#define NAMESPACE_SYSTEM                "system"
#define NAMESPACE_SENSORS               "sensors"
#define NAMESPACE_LORAWAN               "lorawan"
#define NAMESPACE_LORA_SESSION          "lorasession"
#define NAMESPACE_SENSORS_MODBUS        "sensors_modbus"

// Claves
#define KEY_INITIALIZED                  "initialized"
#define KEY_SLEEP_TIME                   "sleep_time"
#define KEY_STATION_ID                   "stationId"
#define KEY_DEVICE_ID                    "deviceId"
#define KEY_VOLT                         "volt"
#define KEY_SENSOR                       "k"
#define KEY_SENSOR_ID                    "id"
#define KEY_SENSOR_ID_TEMPERATURE_SENSOR "ts"
#define KEY_SENSOR_TYPE                  "t"
#define KEY_SENSOR_CHANNEL               "ch"
#define KEY_SENSOR_VALUE                 "v"
#define KEY_SENSOR_ENABLE                "e"
#define KEY_LORA_JOIN_EUI                "joinEUI"
#define KEY_LORA_DEV_EUI                 "devEUI"
#define KEY_LORA_NWK_KEY                 "nwkKey"
#define KEY_LORA_APP_KEY                 "appKey"
#define KEY_LORAWAN_SESSION              "lorawan_session"

// Claves para Modbus
#define KEY_MODBUS_SENSOR_ID    "id"
#define KEY_MODBUS_SENSOR_TYPE  "t"
#define KEY_MODBUS_SENSOR_ADDR  "ad"
#define KEY_MODBUS_SENSOR_ENABLE "e"

// Configuración Modbus
#define MODBUS_BAUDRATE         9600
#define MODBUS_SERIAL_CONFIG    SERIAL_8N1
#define MODBUS_RESPONSE_TIMEOUT 1000  // Tiempo de espera para respuesta en ms
#define MODBUS_MAX_RETRY        3     // Número máximo de intentos de lectura Modbus

// Tamaños JSON
#define JSON_DOC_SIZE_SMALL   300
#define JSON_DOC_SIZE_MEDIUM  1024
#define JSON_DOC_SIZE_LARGE   2048

// Power management
#define POWER_3V3_PIN           P00
#define POWER_12V_PIN           P01
#define POWER_STABILIZE_DELAY   20

// Configuración default sensores
#define DEFAULT_SENSOR_CONFIGS { \
    {"R", "RTD1", RTD, 0, "", true}, \
    {"D", "DS1", DS18B20, 0, "", true}, \
    {"I2C", "SHT30", SHT30, 0, "", true} \
}

#define DEFAULT_MODBUS_SENSOR_CONFIGS { \
    {"Env1", ENV4, 1, true} \
}

#endif

#endif // CONFIG_H

================
File: include/debug.h
================
/*******************************************************************************************
 * Archivo: include/debug.h
 * Descripción: Sistema de depuración configurable para mensajes por Serial
 *******************************************************************************************/

#ifndef DEBUG_H
#define DEBUG_H

#include <Arduino.h>
#include "config.h"

// Si DEBUG_ENABLED está definido en config.h, las macros de depuración estarán activas
// Si no está definido, las macros se compilarán como código vacío

#ifdef DEBUG_ENABLED
    #define DEBUG_BEGIN(baud)     Serial.begin(baud)
    #define DEBUG_PRINT(...)      Serial.print(__VA_ARGS__)
    #define DEBUG_PRINTLN(...)    Serial.println(__VA_ARGS__)
    #define DEBUG_PRINTF(...)     Serial.printf(__VA_ARGS__)
    #define DEBUG_FLUSH()         Serial.flush()
    #define DEBUG_END()           Serial.end()
#else
    #define DEBUG_BEGIN(baud)     Serial.begin(baud)  // Mantenemos Serial.begin por compatibilidad
    #define DEBUG_PRINT(...)      {}
    #define DEBUG_PRINTLN(...)    {}
    #define DEBUG_PRINTF(...)     {}
    #define DEBUG_FLUSH()         Serial.flush()      // Mantenemos Serial.flush por seguridad
    #define DEBUG_END()           Serial.end()        // Mantenemos Serial.end por seguridad
#endif

#endif // DEBUG_H

================
File: include/HardwareManager.h
================
/*******************************************************************************************
 * Archivo: include/HardwareManager.h
 * Descripción: Gestión de inicialización y configuración del hardware del sistema.
 * Incluye funciones para inicialización de periféricos y control de energía.
 *******************************************************************************************/

#ifndef HARDWARE_MANAGER_H
#define HARDWARE_MANAGER_H

#include <Arduino.h>
#include <Wire.h>
#include <SPI.h>
#include "config.h"
#include "PowerManager.h"
#include "clsPCA9555.h"
#include <SensirionI2cSht3x.h>

class HardwareManager {
public:
    /**
     * @brief Inicializa el bus I2C, la expansión de I/O y el PowerManager.
     * @param ioExpander Referencia al expansor de I/O
     * @param powerManager Referencia al gestor de energía
     * @param sht30Sensor Referencia al sensor SHT30
     * @return true si la inicialización fue exitosa, false en caso contrario
     */
    static bool initHardware(PCA9555& ioExpander, PowerManager& powerManager, SensirionI2cSht3x& sht30Sensor);

    /**
     * @brief Configura los pines SPI para los diferentes periféricos
     * @param spi Referencia al objeto SPI
     */
    static void initSPI(SPIClass& spi);

    /**
     * @brief Prepara el hardware para entrar en modo deep sleep
     * @param ioExpander Referencia al expansor de I/O
     */
    static void prepareHardwareForSleep(PCA9555& ioExpander);
};

#endif // HARDWARE_MANAGER_H

================
File: include/LoRaManager.h
================
/*******************************************************************************************
 * Archivo: include/LoRaManager.h
 * Descripción: Gestión de comunicaciones LoRa y LoRaWAN para el sistema de sensores.
 * Incluye funciones para inicialización, activación y envío de datos.
 *******************************************************************************************/

#ifndef LORA_MANAGER_H
#define LORA_MANAGER_H

#include <Arduino.h>
#include <RadioLib.h>
#include <vector>
#include <ArduinoJson.h>
#include "config_manager.h"
#include "utilities.h"
#include "sensor_types.h"
#include "RTCManager.h"
#include "SensorManager.h"

class LoRaManager {
public:
    /**
     * @brief Inicializa el módulo LoRa con la configuración especificada
     * @param radio Puntero al módulo de radio SX1262
     * @param region Región LoRaWAN a utilizar
     * @param subBand Sub-banda para la región (relevante para US915)
     * @return Estado de la inicialización
     */
    static int16_t begin(SX1262* radio, const LoRaWANBand_t* region, uint8_t subBand);

    /**
     * @brief Activa el nodo LoRaWAN restaurando la sesión o realizando un nuevo join
     * @param node Referencia al nodo LoRaWAN
     * @return Estado de la activación
     */
    static int16_t lwActivate(LoRaWANNode& node);

    /**
     * @brief Envía el payload de sensores estándar fragmentado para no superar el tamaño máximo permitido.
     * @param readings Vector con todas las lecturas de sensores.
     * @param node Referencia al nodo LoRaWAN
     * @param deviceId ID del dispositivo
     * @param stationId ID de la estación
     * @param rtcManager Referencia al gestor RTC para obtener timestamp
     */
    static void sendFragmentedPayload(const std::vector<SensorReading>& readings, 
                                     LoRaWANNode& node,
                                     const String& deviceId, 
                                     const String& stationId, 
                                     RTCManager& rtcManager);

    /**
     * @brief Envía el payload de sensores estándar y Modbus fragmentado para no superar el tamaño máximo permitido.
     * @param normalReadings Vector con lecturas de sensores estándar
     * @param modbusReadings Vector con lecturas de sensores Modbus
     * @param node Referencia al nodo LoRaWAN
     * @param deviceId ID del dispositivo
     * @param stationId ID de la estación
     * @param rtcManager Referencia al gestor RTC para obtener timestamp
     */
    static void sendFragmentedPayload(const std::vector<SensorReading>& normalReadings, 
                                     const std::vector<ModbusSensorReading>& modbusReadings,
                                     LoRaWANNode& node,
                                     const String& deviceId, 
                                     const String& stationId, 
                                     RTCManager& rtcManager);

    /**
     * @brief Prepara el módulo LoRa para entrar en modo sleep
     * @param radio Puntero al módulo de radio SX1262
     */
    static void prepareForSleep(SX1262* radio);

    /**
     * @brief Configura el datarate para la transmisión
     * @param node Referencia al nodo LoRaWAN
     * @param datarate Valor del datarate a configurar
     */
    static void setDatarate(LoRaWANNode& node, uint8_t datarate);

private:
    static LoRaWANNode* node;
    static SX1262* radioModule;
};

#endif // LORA_MANAGER_H

================
File: include/MAX31865.h
================
#ifndef _MAX31865_H
#define _MAX31865_H

#include <stdint.h>
#include <SPI.h>
#include "clsPCA9555.h"


#define MAX31865_FAULT_HIGH_THRESHOLD  ( 1 << 7 )
#define MAX31865_FAULT_LOW_THRESHOLD   ( 1 << 6 )
#define MAX31865_FAULT_REFIN           ( 1 << 5 )
#define MAX31865_FAULT_REFIN_FORCE     ( 1 << 4 )
#define MAX31865_FAULT_RTDIN_FORCE     ( 1 << 3 )
#define MAX31865_FAULT_VOLTAGE         ( 1 << 2 )

#define MAX31865_FAULT_DETECTION_NONE      ( 0x00 << 2 )
#define MAX31865_FAULT_DETECTION_AUTO      ( 0x01 << 2 )
#define MAX31865_FAULT_DETECTION_MANUAL_1  ( 0x02 << 2 )
#define MAX31865_FAULT_DETECTION_MANUAL_2  ( 0x03 << 2 )



/* RTD data, RTD current, and measurement reference
   voltage. The ITS-90 standard is used; other RTDs
   may have coefficients defined by the DIN 43760 or
   the U.S. Industrial (American) standard. */
#define RTD_A_ITS90         3.9080e-3
#define RTD_A_USINDUSTRIAL  3.9692e-3
#define RTD_A_DIN43760      3.9848e-3
#define RTD_B_ITS90         -5.870e-7
#define RTD_B_USINDUSTRIAL  -5.8495e-7
#define RTD_B_DIN43760      -5.8019e-7
/* RTD coefficient C is required only for temperatures
   below 0 deg. C.  The selected RTD coefficient set
   is specified below. */
#define SELECT_RTD_HELPER(x) x
#define SELECT_RTD(x) SELECT_RTD_HELPER(x)
#define RTD_A         SELECT_RTD(RTD_A_ITS90)
#define RTD_B         SELECT_RTD(RTD_B_ITS90)
/*
 * The reference resistor on the hardware; see the MAX31865 datasheet
 * for details.  The values 400 and 4000 Ohm are recommended values for
 * the PT100 and PT1000.
 */
#define RTD_RREF_PT100         430 /* Ohm */
#define RTD_RREF_PT1000       4000 /* Ohm */
/*
 * The RTD resistance at 0 degrees Celcius.  For the PT100, this is 100 Ohm;
 * for the PT1000, it is 1000 Ohm.
 */
#define RTD_RESISTANCE_PT100   100 /* Ohm */
#define RTD_RESISTANCE_PT1000 1000 /* Ohm */

#define RTD_ADC_RESOLUTION  ( 1u << 15 ) /* 15 bits */


/* See the main (MAX31865.cpp) file for documentation of the class methods. */
class MAX31865_RTD
{
public:
  enum ptd_type { RTD_PT100, RTD_PT1000 };

  /**
   * @brief Constructor para usar PCA9555 como CS.
   * @param type         Tipo de RTD (PT100/PT1000)
   * @param spi          Referencia al objeto SPI que usarás (por ej. spiCustom)
   * @param spiSettings  Configuración de SPI (frecuencia, MSB/LSB, modo, etc.)
   * @param pca          Referencia a tu PCA9555
   * @param pcaPinCS     Pin del PCA que actúa como CS
   */
  MAX31865_RTD(
      ptd_type type,
      SPIClass& spi,
      SPISettings& spiSettings,
      PCA9555& pca,
      uint8_t pcaPinCS
  );

    /**
   * @brief Constructor alternativo, usando pin nativo de microcontrolador como CS.
   */
  MAX31865_RTD(
      ptd_type type,
      SPIClass& spi,
      SPISettings& spiSettings,
      uint8_t csPin
  );

  void configure( bool v_bias, bool conversion_mode, bool one_shot, bool three_wire,
                  uint8_t fault_cycle, bool fault_clear, bool filter_50hz,
                  uint16_t low_threshold, uint16_t high_threshold );
  uint8_t read_all( );
  double temperature( ) const;
  uint8_t status( ) const { return( measured_status ); }
  uint16_t low_threshold( ) const { return( measured_low_threshold ); }
  uint16_t high_threshold( ) const  { return( measured_high_threshold ); }
  uint16_t raw_resistance( ) const { return( measured_resistance ); }
  double resistance( ) const
  {
    const double rtd_rref =
      ( this->type == RTD_PT100 ) ? (double)RTD_RREF_PT100 : (double)RTD_RREF_PT1000;
    return( (double)raw_resistance( ) * rtd_rref / (double)RTD_ADC_RESOLUTION );
  }

  // Nuevo método para medición única
  double singleMeasurement(uint16_t conversionDelayMs = 100);

  // Agregar el método begin
  bool begin();

private:
  void reconfigure();
  void setCSLow();
  void setCSHigh();

  /* SPI */
  SPIClass* _spi;           ///< Puntero a la clase SPI
  SPISettings* _spiSettings;   ///< Puntero a SPISettings

  /* PCA9555 / Pin CS */
  PCA9555* _pca = nullptr; 
  uint8_t  _pcaPinCS = 0xFF;
  bool     _usePCA   = false;

  uint8_t  _csPinMCU = 0xFF;     ///< CS pin nativo (si no usamos PCA)

  /* Config RTD */
  ptd_type type;
  uint8_t  configuration_control_bits;
  uint16_t configuration_low_threshold;
  uint16_t configuration_high_threshold;

  /* Valores leídos del dispositivo */
  uint8_t  measured_configuration = 0;
  uint16_t measured_resistance    = 0;
  uint16_t measured_high_threshold= 0;
  uint16_t measured_low_threshold = 0;
  uint8_t  measured_status        = 0;
};

#endif /* _MAX31865_H */

================
File: include/ModbusMaster.h
================
/**
@file
Arduino library for communicating with Modbus slaves over RS232/485 (via RTU protocol).

@defgroup setup ModbusMaster Object Instantiation/Initialization
@defgroup buffer ModbusMaster Buffer Management
@defgroup discrete Modbus Function Codes for Discrete Coils/Inputs
@defgroup register Modbus Function Codes for Holding/Input Registers
@defgroup constant Modbus Function Codes, Exception Codes
*/
/*

  ModbusMaster.h - Arduino library for communicating with Modbus slaves
  over RS232/485 (via RTU protocol).

  Library:: ModbusMaster

  Copyright:: 2009-2016 Doc Walker

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

*/

  
#ifndef ModbusMaster_h
#define ModbusMaster_h


/**
@def __MODBUSMASTER_DEBUG__ (0)
Set to 1 to enable debugging features within class:
  - PIN A cycles for each byte read in the Modbus response
  - PIN B cycles for each millisecond timeout during the Modbus response
*/
#define __MODBUSMASTER_DEBUG__ (0)
#define __MODBUSMASTER_DEBUG_PIN_A__ 4
#define __MODBUSMASTER_DEBUG_PIN_B__ 5

/* _____STANDARD INCLUDES____________________________________________________ */
// include types & constants of Wiring core API
#include "Arduino.h"

/* _____UTILITY MACROS_______________________________________________________ */


/* _____PROJECT INCLUDES_____________________________________________________ */
// functions to calculate Modbus Application Data Unit CRC
#include "util/crc16.h"

// functions to manipulate words
#include "util/word.h"


/* _____CLASS DEFINITIONS____________________________________________________ */
/**
Arduino class library for communicating with Modbus slaves over 
RS232/485 (via RTU protocol).
*/
class ModbusMaster
{
  public:
    ModbusMaster();
   
    void begin(uint8_t, Stream &serial);
    void idle(void (*)());
    void preTransmission(void (*)());
    void postTransmission(void (*)());

    // Modbus exception codes
    /**
    Modbus protocol illegal function exception.
    
    The function code received in the query is not an allowable action for
    the server (or slave). This may be because the function code is only
    applicable to newer devices, and was not implemented in the unit
    selected. It could also indicate that the server (or slave) is in the
    wrong state to process a request of this type, for example because it is
    unconfigured and is being asked to return register values.
    
    @ingroup constant
    */
    static const uint8_t ku8MBIllegalFunction            = 0x01;

    /**
    Modbus protocol illegal data address exception.
    
    The data address received in the query is not an allowable address for 
    the server (or slave). More specifically, the combination of reference 
    number and transfer length is invalid. For a controller with 100 
    registers, the ADU addresses the first register as 0, and the last one 
    as 99. If a request is submitted with a starting register address of 96 
    and a quantity of registers of 4, then this request will successfully 
    operate (address-wise at least) on registers 96, 97, 98, 99. If a 
    request is submitted with a starting register address of 96 and a 
    quantity of registers of 5, then this request will fail with Exception 
    Code 0x02 "Illegal Data Address" since it attempts to operate on 
    registers 96, 97, 98, 99 and 100, and there is no register with address 
    100. 
    
    @ingroup constant
    */
    static const uint8_t ku8MBIllegalDataAddress         = 0x02;
    
    /**
    Modbus protocol illegal data value exception.
    
    A value contained in the query data field is not an allowable value for 
    server (or slave). This indicates a fault in the structure of the 
    remainder of a complex request, such as that the implied length is 
    incorrect. It specifically does NOT mean that a data item submitted for 
    storage in a register has a value outside the expectation of the 
    application program, since the MODBUS protocol is unaware of the 
    significance of any particular value of any particular register.
    
    @ingroup constant
    */
    static const uint8_t ku8MBIllegalDataValue           = 0x03;
    
    /**
    Modbus protocol slave device failure exception.
    
    An unrecoverable error occurred while the server (or slave) was
    attempting to perform the requested action.
    
    @ingroup constant
    */
    static const uint8_t ku8MBSlaveDeviceFailure         = 0x04;

    // Class-defined success/exception codes
    /**
    ModbusMaster success.
    
    Modbus transaction was successful; the following checks were valid:
      - slave ID
      - function code
      - response code
      - data
      - CRC
      
    @ingroup constant
    */
    static const uint8_t ku8MBSuccess                    = 0x00;
    
    /**
    ModbusMaster invalid response slave ID exception.
    
    The slave ID in the response does not match that of the request.
    
    @ingroup constant
    */
    static const uint8_t ku8MBInvalidSlaveID             = 0xE0;
    
    /**
    ModbusMaster invalid response function exception.
    
    The function code in the response does not match that of the request.
    
    @ingroup constant
    */
    static const uint8_t ku8MBInvalidFunction            = 0xE1;
    
    /**
    ModbusMaster response timed out exception.
    
    The entire response was not received within the timeout period, 
    ModbusMaster::ku8MBResponseTimeout. 
    
    @ingroup constant
    */
    static const uint8_t ku8MBResponseTimedOut           = 0xE2;
    
    /**
    ModbusMaster invalid response CRC exception.
    
    The CRC in the response does not match the one calculated.
    
    @ingroup constant
    */
    static const uint8_t ku8MBInvalidCRC                 = 0xE3;
    
    uint16_t getResponseBuffer(uint8_t);
    void     clearResponseBuffer();
    uint8_t  setTransmitBuffer(uint8_t, uint16_t);
    void     clearTransmitBuffer();
    
    void beginTransmission(uint16_t);
    uint8_t requestFrom(uint16_t, uint16_t);
    void sendBit(bool);
    void send(uint8_t);
    void send(uint16_t);
    void send(uint32_t);
    uint8_t available(void);
    uint16_t receive(void);
    
    
    uint8_t  readCoils(uint16_t, uint16_t);
    uint8_t  readDiscreteInputs(uint16_t, uint16_t);
    uint8_t  readHoldingRegisters(uint16_t, uint16_t);
    uint8_t  readInputRegisters(uint16_t, uint8_t);
    uint8_t  writeSingleCoil(uint16_t, uint8_t);
    uint8_t  writeSingleRegister(uint16_t, uint16_t);
    uint8_t  writeMultipleCoils(uint16_t, uint16_t);
    uint8_t  writeMultipleCoils();
    uint8_t  writeMultipleRegisters(uint16_t, uint16_t);
    uint8_t  writeMultipleRegisters();
    uint8_t  maskWriteRegister(uint16_t, uint16_t, uint16_t);
    uint8_t  readWriteMultipleRegisters(uint16_t, uint16_t, uint16_t, uint16_t);
    uint8_t  readWriteMultipleRegisters(uint16_t, uint16_t);
    
  private:
    Stream* _serial;                                             ///< reference to serial port object
    uint8_t  _u8MBSlave;                                         ///< Modbus slave (1..255) initialized in begin()
    static const uint8_t ku8MaxBufferSize                = 64;   ///< size of response/transmit buffers    
    uint16_t _u16ReadAddress;                                    ///< slave register from which to read
    uint16_t _u16ReadQty;                                        ///< quantity of words to read
    uint16_t _u16ResponseBuffer[ku8MaxBufferSize];               ///< buffer to store Modbus slave response; read via GetResponseBuffer()
    uint16_t _u16WriteAddress;                                   ///< slave register to which to write
    uint16_t _u16WriteQty;                                       ///< quantity of words to write
    uint16_t _u16TransmitBuffer[ku8MaxBufferSize];               ///< buffer containing data to transmit to Modbus slave; set via SetTransmitBuffer()
    uint16_t* txBuffer; // from Wire.h -- need to clean this up Rx
    uint8_t _u8TransmitBufferIndex;
    uint16_t u16TransmitBufferLength;
    uint16_t* rxBuffer; // from Wire.h -- need to clean this up Rx
    uint8_t _u8ResponseBufferIndex;
    uint8_t _u8ResponseBufferLength;
    
    // Modbus function codes for bit access
    static const uint8_t ku8MBReadCoils                  = 0x01; ///< Modbus function 0x01 Read Coils
    static const uint8_t ku8MBReadDiscreteInputs         = 0x02; ///< Modbus function 0x02 Read Discrete Inputs
    static const uint8_t ku8MBWriteSingleCoil            = 0x05; ///< Modbus function 0x05 Write Single Coil
    static const uint8_t ku8MBWriteMultipleCoils         = 0x0F; ///< Modbus function 0x0F Write Multiple Coils

    // Modbus function codes for 16 bit access
    static const uint8_t ku8MBReadHoldingRegisters       = 0x03; ///< Modbus function 0x03 Read Holding Registers
    static const uint8_t ku8MBReadInputRegisters         = 0x04; ///< Modbus function 0x04 Read Input Registers
    static const uint8_t ku8MBWriteSingleRegister        = 0x06; ///< Modbus function 0x06 Write Single Register
    static const uint8_t ku8MBWriteMultipleRegisters     = 0x10; ///< Modbus function 0x10 Write Multiple Registers
    static const uint8_t ku8MBMaskWriteRegister          = 0x16; ///< Modbus function 0x16 Mask Write Register
    static const uint8_t ku8MBReadWriteMultipleRegisters = 0x17; ///< Modbus function 0x17 Read Write Multiple Registers
    
    // Modbus timeout [milliseconds]
    static const uint16_t ku16MBResponseTimeout          = 2000; ///< Modbus timeout [milliseconds]
    
    // master function that conducts Modbus transactions
    uint8_t ModbusMasterTransaction(uint8_t u8MBFunction);
    
    // idle callback function; gets called during idle time between TX and RX
    void (*_idle)();
    // preTransmission callback function; gets called before writing a Modbus message
    void (*_preTransmission)();
    // postTransmission callback function; gets called after a Modbus message has been sent
    void (*_postTransmission)();
};
#endif

/**
@example examples/Basic/Basic.pde
@example examples/PhoenixContact_nanoLC/PhoenixContact_nanoLC.pde
@example examples/RS485_HalfDuplex/RS485_HalfDuplex.ino
*/

================
File: include/ModbusSensorManager.h
================
#ifndef MODBUS_SENSOR_MANAGER_H
#define MODBUS_SENSOR_MANAGER_H

#include <Arduino.h>
#include <vector>
#include "sensor_types.h"

/**
 * @brief Clase para manejar la lectura de sensores Modbus.
 *        Usa Serial por defecto. Asegurarse de no usar debug durante la medición.
 *        Utiliza la biblioteca ModbusMaster para comunicación.
 */
class ModbusSensorManager {
public:
    /**
     * @brief Inicializa el bus RS485/Modbus (configura Serial a 9600, 8N1, etc.)
     *        Debe llamarse una sola vez al principio.
     */
    static void beginModbus();

    /**
     * @brief Finaliza la comunicación Modbus (cierra Serial)
     *        Debe llamarse después de completar todas las lecturas Modbus
     */
    static void endModbus();

    /**
     * @brief Lee un sensor Modbus de tipo ENV_SENSOR (ejemplo del datasheet).
     *        Regresa la lectura con subvalores (T, H, Ruido, PM2.5, PM10, Presión, Iluminación).
     * @param cfg Configuración del sensor (dirección, etc.)
     * @return Estructura ModbusSensorReading con los subvalores.
     */
    static ModbusSensorReading readEnvSensor(const ModbusSensorConfig &cfg);

private:
    /**
     * @brief Envía un frame Modbus (Función 0x03) y recibe la respuesta utilizando ModbusMaster.
     *        Para simplificar el ejemplo, se hace una lectura consecutiva de registros.
     * @param address Dirección Modbus del dispositivo
     * @param startReg Registro inicial
     * @param numRegs  Cantidad de registros
     * @param outData  Buffer de salida donde se almacenan los valores de cada registro
     * @return true si la lectura fue exitosa, false en caso de error
     */
    static bool readHoldingRegisters(uint8_t address, uint16_t startReg, uint16_t numRegs, uint16_t* outData);
};

#endif // MODBUS_SENSOR_MANAGER_H

================
File: include/PowerManager.h
================
#ifndef POWER_MANAGER_H
#define POWER_MANAGER_H

#include "clsPCA9555.h"
#include "config.h"

class PowerManager {
private:
    PCA9555& ioExpander;

public:
    PowerManager(PCA9555& expander);
    bool begin();

    // Método común para todos los dispositivos
    void power3V3On();
    void power3V3Off();
    
    // Métodos disponibles solo para dispositivos ANALOGIC y MODBUS
#if defined(DEVICE_TYPE_ANALOGIC) || defined(DEVICE_TYPE_MODBUS)
    void power12VOn();
    void power12VOff();
#endif

    // Método disponible solo para dispositivo ANALOGIC
#ifdef DEVICE_TYPE_ANALOGIC
    void power2V5On();
    void power2V5Off();
#endif

    void allPowerOff();
};

#endif

================
File: include/RTCManager.h
================
#ifndef RTC_MANAGER_H
#define RTC_MANAGER_H

#include <Arduino.h>
#include <RTClib.h>
#include <Wire.h>

class RTCManager {
private:
    RTC_DS3231 rtc;

public:
    RTCManager();
    bool begin();
    void setFallbackDateTime();
    DateTime getCurrentTime();
    void printDateTime();
    bool hasLostPower();
    uint32_t getEpochTime();
    
    /**
     * @brief Actualiza el RTC usando el tiempo Unix recibido del servidor
     * @param unixTime Segundos desde Unix epoch (1/Jan/1970)
     * @param fraction Fracción de segundo (1/256 segundos)
     * @return true si la actualización fue exitosa
     */
    bool setTimeFromServer(uint32_t unixTime, uint8_t fraction);
};

#endif

================
File: include/sensor_constants.h
================
/*******************************************************************************************
 * Archivo: include/sensor_constants.h
 * Descripción: Constantes y definiciones para sensores
 *******************************************************************************************/

#ifndef SENSOR_CONSTANTS_H
#define SENSOR_CONSTANTS_H

/**
 * @brief Claves para sensores específicos
 */
// Claves para el sensor ambiental 4 en 1 (ENV4)
#define ENV4_KEY_HUMIDITY "H"       // Clave para Humedad en sensor ENV4
#define ENV4_KEY_TEMPERATURE "T"    // Clave para Temperatura en sensor ENV4
#define ENV4_KEY_PRESSURE "P"       // Clave para Presión Atmosférica en sensor ENV4
#define ENV4_KEY_ILLUMINATION "Lux" // Clave para Iluminación en sensor ENV4

/**
 * @brief Tiempos de estabilización para sensores (en ms)
 */
// Para sensores Modbus
#define SENSOR_MODBUS_ENV4_STABILIZATION_TIME 5000   // Tiempo de estabilización para sensor ENV4
// Añadir aquí otros tiempos de estabilización

#endif // SENSOR_CONSTANTS_H

================
File: include/sensor_types.h
================
#ifndef SENSOR_TYPES_H
#define SENSOR_TYPES_H

#include <stdint.h>
#include <vector>
#include "sensor_constants.h"

/**
 * @brief Estructura para variables múltiples en un solo sensor.
 *        Por ejemplo, un sensor SHT30 que da Temperature (T) y Humidity (H).
 */
struct SubValue {
    char key[10];    // Nombre corto de la variable, por ej: "T", "H", etc.
    float value;
};

/************************************************************************
 * SECCIÓN PARA SENSORES ESTÁNDAR (NO MODBUS)
 ************************************************************************/

/**
 * @brief Enumeración de tipos de sensores disponibles (no-Modbus).
 */
enum SensorType {
    N100K,    // NTC 100K
    N10K,     // NTC 10K
    WNTC10K,  // Water NTC 10K
    RTD,      // RTD
    DS18B20,  // DS18B20
    PH,       // pH
    COND,     // Conductividad
    CONDH,    // Condensation Humidity
    SOILH,    // Soil Humidity
    SHT30     // Nuevo tipo unificado para SHT30
};

/**
 * @brief Estructura básica para almacenar una lectura de sensor.
 *        Para sensores con múltiples variables, se utilizará 'subValues'.
 */
struct SensorReading {
    char sensorId[20];         // Identificador del sensor (ej. "SHT30_1")
    SensorType type;           // Tipo de sensor (no-Modbus)
    float value;               // Valor único (si aplica)
    std::vector<SubValue> subValues; // Subvalores, si el sensor genera varias mediciones
};

/**
 * @brief Estructura de configuración para sensores "normales" (no Modbus).
 */
struct SensorConfig {
    char configKey[20];
    char sensorId[20];
    SensorType type;
    uint8_t channel;
    char tempSensorId[20]; 
    bool enable;
};

/************************************************************************
 * SECCIÓN PARA SENSORES MODBUS
 ************************************************************************/

/**
 * @brief Enumeración de tipos de sensores Modbus.
 */
enum ModbusSensorType {
    ENV4 = 0,   // Sensor ambiental 4 en 1
    // Aquí se pueden agregar más tipos de sensores Modbus
};

/**
 * @brief Estructura de configuración para sensores Modbus.
 */
struct ModbusSensorConfig {
    char sensorId[20];         // Identificador del sensor
    ModbusSensorType type;     // Tipo de sensor Modbus
    uint8_t address;           // Dirección Modbus del dispositivo
    bool enable;               // Si está habilitado o no
};

/**
 * @brief Estructura para almacenar la lectura completa de un sensor Modbus.
 */
struct ModbusSensorReading {
    char sensorId[20];         // Identificador del sensor
    ModbusSensorType type;     // Tipo de sensor Modbus
    std::vector<SubValue> subValues; // Subvalores reportados por el sensor
};

#endif // SENSOR_TYPES_H

================
File: include/SensorManager.h
================
#ifndef SENSOR_MANAGER_H
#define SENSOR_MANAGER_H

#include <Arduino.h>
#include <vector>
#include "sensor_types.h"
#include "RTCManager.h"
#include "clsPCA9555.h"
#include "PowerManager.h"
#include "MAX31865.h"
#if defined(DEVICE_TYPE_BASIC) || defined(DEVICE_TYPE_ANALOGIC)
#include <OneWire.h>
#include <DallasTemperature.h>
#endif
#include <SensirionI2cSht3x.h>
#include "ModbusSensorManager.h"

// Variables y objetos globales declarados en main.cpp
extern RTCManager rtcManager;
extern PCA9555 ioExpander;
extern PowerManager powerManager;
extern SPIClass spi;
#ifdef DEVICE_TYPE_ANALOGIC
extern SPISettings spiAdcSettings;
#endif
extern SPISettings spiRtdSettings;
extern MAX31865_RTD rtd;
#if defined(DEVICE_TYPE_BASIC) || defined(DEVICE_TYPE_ANALOGIC)
extern OneWire oneWire;
extern DallasTemperature dallasTemp;
#endif
extern SensirionI2cSht3x sht30Sensor;

/**
 * @brief Clase que maneja la inicialización y lecturas de todos los sensores
 *        incluyendo sensores normales y Modbus.
 */
class SensorManager {
  public:
    // Inicializa pines, periféricos (ADC, RTD, etc.), OneWire, etc.
    static void beginSensors();

    // Devuelve la lectura (o lecturas) de un sensor NO-Modbus según su configuración.
    static SensorReading getSensorReading(const SensorConfig& cfg);
    
    // Devuelve la lectura de un sensor Modbus según su configuración
    static ModbusSensorReading getModbusSensorReading(const ModbusSensorConfig& cfg);
    
    // Obtiene todas las lecturas de sensores (normales y Modbus) habilitados
    static void getAllSensorReadings(std::vector<SensorReading>& normalReadings, 
                                     std::vector<ModbusSensorReading>& modbusReadings);

    // Lee el voltaje de la batería a través del pin analógico del ESP32.
    static float readBatteryVoltageADC();

  private:
    // Métodos de lectura internos
    static float readRtdSensor();
#if defined(DEVICE_TYPE_BASIC) || defined(DEVICE_TYPE_ANALOGIC)
    static float readDallasSensor();
#endif
    // Lectura unificada de SHT30
    static void readSht30(float& outTemp, float& outHum);

    // Redondea un valor flotante a un máximo de 3 decimales.
    static float roundTo3Decimals(float value);

    static void initializeSPISSPins();
    static float readSensorValue(const SensorConfig &cfg, SensorReading &reading);
};

#endif // SENSOR_MANAGER_H

================
File: include/SleepManager.h
================
/*******************************************************************************************
 * Archivo: include/SleepManager.h
 * Descripción: Gestión del modo deep sleep para el ESP32.
 * Incluye funciones para configurar y entrar en modo de bajo consumo.
 *******************************************************************************************/

#ifndef SLEEP_MANAGER_H
#define SLEEP_MANAGER_H

#include <Arduino.h>
#include "esp_sleep.h"
#include "driver/gpio.h"
#include "PowerManager.h"
#include "clsPCA9555.h"
#include "config.h"
#include <RadioLib.h>
#include <SPI.h>
#include <Wire.h>

class SleepManager {
public:
    /**
     * @brief Configura y entra en modo deep sleep.
     * @param timeToSleep Tiempo en segundos para permanecer en deep sleep
     * @param powerManager Referencia al gestor de energía
     * @param ioExpander Referencia al expansor de I/O
     * @param radio Puntero al módulo de radio LoRa
     * @param node Referencia al nodo LoRaWAN para guardar sesión
     * @param LWsession Buffer para almacenar la sesión LoRaWAN
     * @param spi Referencia al objeto SPI
     */
    static void goToDeepSleep(uint32_t timeToSleep, 
                             PowerManager& powerManager,
                             PCA9555& ioExpander,
                             SX1262* radio,
                             LoRaWANNode& node,
                             uint8_t* LWsession,
                             SPIClass& spi);
    
    /**
     * @brief Configura los pines no utilizados en alta impedancia para reducir el consumo durante deep sleep.
     */
    static void configurePinsForDeepSleep();

    /**
     * @brief Libera el estado de retención (hold) de los pines que fueron configurados para deep sleep.
     * Esto permite que los pines puedan ser reconfigurados adecuadamente tras salir del deep sleep.
     */
    static void releaseHeldPins();
};

#endif // SLEEP_MANAGER_H

================
File: include/util/crc16.h
================
/**
@file
CRC Computations

@defgroup util_crc16 "util/crc16.h": CRC Computations
@code#include "util/crc16.h"@endcode

This header file provides functions for calculating
cyclic redundancy checks (CRC) using common polynomials.
Modified by Doc Walker to be processor-independent (removed inline
assembler to allow it to compile on SAM3X8E processors).

@par References:
Jack Crenshaw's "Implementing CRCs" article in the January 1992 issue of @e
Embedded @e Systems @e Programming. This may be difficult to find, but it
explains CRC's in very clear and concise terms. Well worth the effort to
obtain a copy.

*/
/* Copyright (c) 2002, 2003, 2004  Marek Michalkiewicz
   Copyright (c) 2005, 2007 Joerg Wunsch
   Copyright (c) 2013 Dave Hylands
   Copyright (c) 2013 Frederic Nadeau
   Copyright (c) 2015 Doc Walker
   All rights reserved.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are met:

   * Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.

   * Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.

   * Neither the name of the copyright holders nor the names of
     contributors may be used to endorse or promote products derived
     from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */


#ifndef _UTIL_CRC16_H_
#define _UTIL_CRC16_H_


/** @ingroup util_crc16
    Processor-independent CRC-16 calculation.

    Polynomial: x^16 + x^15 + x^2 + 1 (0xA001)<br>
    Initial value: 0xFFFF

    This CRC is normally used in disk-drive controllers.

    @param uint16_t crc (0x0000..0xFFFF)
    @param uint8_t a (0x00..0xFF)
    @return calculated CRC (0x0000..0xFFFF)
*/
static uint16_t crc16_update(uint16_t crc, uint8_t a)
{
  int i;

  crc ^= a;
  for (i = 0; i < 8; ++i)
  {
    if (crc & 1)
      crc = (crc >> 1) ^ 0xA001;
    else
      crc = (crc >> 1);
  }

  return crc;
}


#endif /* _UTIL_CRC16_H_ */

================
File: include/util/word.h
================
/**
@file
Utility Functions for Manipulating Words

@defgroup util_word "util/word.h": Utility Functions for Manipulating Words
@code#include "util/word.h"@endcode

This header file provides utility functions for manipulating words.

*/
/*

  word.h - Utility Functions for Manipulating Words

  This file is part of ModbusMaster.

  ModbusMaster is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  ModbusMaster is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with ModbusMaster.  If not, see <http://www.gnu.org/licenses/>.

  Written by Doc Walker (Rx)
  Copyright © 2009-2015 Doc Walker <4-20ma at wvfans dot net>

*/


#ifndef _UTIL_WORD_H_
#define _UTIL_WORD_H_


/** @ingroup util_word
    Return low word of a 32-bit integer.

    @param uint32_t ww (0x00000000..0xFFFFFFFF)
    @return low word of input (0x0000..0xFFFF)
*/
static inline uint16_t lowWord(uint32_t ww)
{
  return (uint16_t) ((ww) & 0xFFFF);
}


/** @ingroup util_word
    Return high word of a 32-bit integer.

    @param uint32_t ww (0x00000000..0xFFFFFFFF)
    @return high word of input (0x0000..0xFFFF)
*/
static inline uint16_t highWord(uint32_t ww)
{
  return (uint16_t) ((ww) >> 16);
}


#endif /* _UTIL_WORD_H_ */

================
File: include/utilities.h
================
#ifndef UTILITIES_H
#define UTILITIES_H

#include <Arduino.h>

void parseKeyString(const String &keyStr, uint8_t *outArray, size_t expectedSize);
bool parseEUIString(const char* euiStr, uint64_t* eui);

/**
 * @brief Redondea un valor a un número específico de decimales, solo si el valor 
 *        realmente tiene más decimales que el límite indicado.
 * @param value Valor a redondear.
 * @param decimals Número máximo de decimales permitidos.
 * @return Valor redondeado o el valor original si ya tiene la precisión requerida.
 */

/**
 * @brief Redondea un valor flotante a un máximo de 3 decimales.
 * @param value Valor a redondear.
 * @return Valor redondeado a 3 decimales.
 */
float roundTo3Decimals(float value);

#endif // UTILITIES_H

================
File: lib/README
================
This directory is intended for project specific (private) libraries.
PlatformIO will compile them to static libraries and link into executable file.

The source code of each library should be placed in an own separate directory
("lib/your_library_name/[here are source files]").

For example, see a structure of the following two libraries `Foo` and `Bar`:

|--lib
|  |
|  |--Bar
|  |  |--docs
|  |  |--examples
|  |  |--src
|  |     |- Bar.c
|  |     |- Bar.h
|  |  |- library.json (optional, custom build options, etc) https://docs.platformio.org/page/librarymanager/config.html
|  |
|  |--Foo
|  |  |- Foo.c
|  |  |- Foo.h
|  |
|  |- README --> THIS FILE
|
|- platformio.ini
|--src
   |- main.c

and a contents of `src/main.c`:
```
#include <Foo.h>
#include <Bar.h>

int main (void)
{
  ...
}

```

PlatformIO Library Dependency Finder will find automatically dependent
libraries scanning project source files.

More information about PlatformIO Library Dependency Finder
- https://docs.platformio.org/page/librarymanager/ldf.html

================
File: platformio.ini
================
; PlatformIO Project Configuration File
;
;   Build options: build flags, source filter
;   Upload options: custom upload port, speed and extra flags
;   Library options: dependencies, extra library storages
;   Advanced options: extra scripting
;
; Please visit documentation for the other options and examples
; https://docs.platformio.org/page/projectconf.html

[env:esp32-c3-devkitc-02]
platform = espressif32
board = esp32-c3-devkitc-02
framework = arduino
lib_deps = 
	adafruit/RTClib@^2.1.1
	paulstoffregen/OneWire@^2.3.7
	milesburton/DallasTemperature@^3.11.0
	SPI
	Wire
	BLE
	jgromes/RadioLib@^6.6.0
	bblanchon/ArduinoJson@^6.21.4
	sensirion/Sensirion I2C SHT3x@^1.0.1
upload_speed = 921600
monitor_speed = 9600

================
File: src/BLE.cpp
================
/*******************************************************************************************
 * Archivo: src/BLE.cpp
 * Descripción: Implementación unificada de la gestión BLE para el ESP32.
 *******************************************************************************************/

#include "BLE.h"

// Implementación de los métodos de la clase ServerCallbacks
void BLEHandler::ServerCallbacks::onConnect(BLEServer* pServer) {
    DEBUG_PRINTLN(F("BLE Cliente conectado"));
}

void BLEHandler::ServerCallbacks::onDisconnect(BLEServer* pServer) {
    DEBUG_PRINTLN(F("BLE Cliente desconectado, reiniciando publicidad..."));
    pServer->getAdvertising()->start();
}

// Implementación de los métodos de BLEHandler
bool BLEHandler::checkConfigMode(PCA9555& ioExpander) {
    if (digitalRead(CONFIG_PIN) == LOW) {
        DEBUG_PRINTLN("Modo configuración activado");
        unsigned long startTime = millis();
        while (digitalRead(CONFIG_PIN) == LOW) {
            if (millis() - startTime >= CONFIG_TRIGGER_TIME) {
                // Obtener configuración LoRa para el nombre BLE
                LoRaConfig loraConfig = ConfigManager::getLoRaConfig();
                String bleName = "SENSOR_DEV" + String(loraConfig.devEUI);
                
                // Inicializar BLE
                BLEDevice::init(bleName.c_str());
                BLEServer* pServer = BLEDevice::createServer();
                pServer->setCallbacks(new ServerCallbacks());
                
                // Configurar servicio BLE
                BLEService* pService = setupService(pServer);
                
                // Configurar publicidad BLE
                BLEAdvertising* pAdvertising = BLEDevice::getAdvertising();
                pAdvertising->addServiceUUID(pService->getUUID());
                pAdvertising->setScanResponse(true);
                pAdvertising->setMinPreferred(0x06);
                pAdvertising->setMinPreferred(0x12);
                pAdvertising->start();
                
                // Entrar en bucle de configuración
                runConfigLoop(ioExpander);
                return true;
            }
        }
    }
    return false;
}

BLEServer* BLEHandler::initBLE(const String& devEUI) {
    String bleName = "SENSOR_DEV" + devEUI;
    BLEDevice::init(bleName.c_str());
    BLEServer* pServer = BLEDevice::createServer();
    pServer->setCallbacks(new ServerCallbacks());
    return pServer;
}

void BLEHandler::runConfigLoop(PCA9555& ioExpander) {
    // Bucle de parpadeo del LED de configuración
    while (true) {
        ioExpander.digitalWrite(CONFIG_LED_PIN, HIGH);
        delay(500);
        ioExpander.digitalWrite(CONFIG_LED_PIN, LOW);
        delay(500);
    }
}

// Implementación de la configuración del servicio BLE
BLEService* BLEHandler::setupService(BLEServer* pServer) {
    // Crear el servicio de configuración utilizando el UUID definido
    BLEService* pService = pServer->createService(BLEUUID(BLE_SERVICE_UUID));

    // Característica del sistema - común para todos los tipos de dispositivo
    BLECharacteristic* pSystemChar = pService->createCharacteristic(
        BLEUUID(BLE_CHAR_SYSTEM_UUID),
        BLECharacteristic::PROPERTY_READ | BLECharacteristic::PROPERTY_WRITE
    );
    pSystemChar->setCallbacks(new SystemConfigCallback());

#ifdef DEVICE_TYPE_ANALOGIC
    // Para dispositivo analógico, se utilizan todas las callbacks
    
    // Característica para configuración NTC 100K
    BLECharacteristic* pNTC100KChar = pService->createCharacteristic(
        BLEUUID(BLE_CHAR_NTC100K_UUID),
        BLECharacteristic::PROPERTY_READ | BLECharacteristic::PROPERTY_WRITE
    );
    pNTC100KChar->setCallbacks(new NTC100KConfigCallback());
    
    // Característica para configuración NTC 10K
    BLECharacteristic* pNTC10KChar = pService->createCharacteristic(
        BLEUUID(BLE_CHAR_NTC10K_UUID),
        BLECharacteristic::PROPERTY_READ | BLECharacteristic::PROPERTY_WRITE
    );
    pNTC10KChar->setCallbacks(new NTC10KConfigCallback());
    
    // Característica para configuración de Conductividad
    BLECharacteristic* pCondChar = pService->createCharacteristic(
        BLEUUID(BLE_CHAR_CONDUCTIVITY_UUID),
        BLECharacteristic::PROPERTY_READ | BLECharacteristic::PROPERTY_WRITE
    );
    pCondChar->setCallbacks(new ConductivityConfigCallback());
    
    // Característica para configuración de pH
    BLECharacteristic* pPHChar = pService->createCharacteristic(
        BLEUUID(BLE_CHAR_PH_UUID),
        BLECharacteristic::PROPERTY_READ | BLECharacteristic::PROPERTY_WRITE
    );
    pPHChar->setCallbacks(new PHConfigCallback());
#endif

    // Característica para configuración de Sensores - común para BASIC y ANALOGIC
#if defined(DEVICE_TYPE_BASIC) || defined(DEVICE_TYPE_ANALOGIC) || defined(DEVICE_TYPE_MODBUS)
    BLECharacteristic* pSensorsChar = pService->createCharacteristic(
        BLEUUID(BLE_CHAR_SENSORS_UUID),
        BLECharacteristic::PROPERTY_READ | BLECharacteristic::PROPERTY_WRITE
    );
    pSensorsChar->setCallbacks(new SensorsConfigCallback());
#endif
    
    // Característica para configuración de LoRa - común para todos los tipos
    BLECharacteristic* pLoRaConfigChar = pService->createCharacteristic(
        BLEUUID(BLE_CHAR_LORA_CONFIG_UUID),
        BLECharacteristic::PROPERTY_READ | BLECharacteristic::PROPERTY_WRITE
    );
    pLoRaConfigChar->setCallbacks(new LoRaConfigCallback());
    
    pService->start();
    return pService;
}

// Implementación de SystemConfigCallback
void BLEHandler::SystemConfigCallback::onWrite(BLECharacteristic *pCharacteristic) {
    DEBUG_PRINTLN(F("DEBUG: SystemConfigCallback onWrite - JSON recibido:"));
    DEBUG_PRINTLN(pCharacteristic->getValue().c_str());
    
    // Se espera un JSON de la forma: { "system": { "initialized": <bool>, "sleep_time": <valor>, "device_id": "<valor>" } }
    StaticJsonDocument<JSON_DOC_SIZE_SMALL> doc;
    DeserializationError error = deserializeJson(doc, pCharacteristic->getValue());
    if (error) {
        DEBUG_PRINT(F("Error deserializando System config: "));
        DEBUG_PRINTLN(error.c_str());
        return;
    }
    JsonObject obj = doc[NAMESPACE_SYSTEM];
    bool initialized = obj[KEY_INITIALIZED] | false;
    uint32_t sleepTime = obj[KEY_SLEEP_TIME] | DEFAULT_TIME_TO_SLEEP;
    String deviceId = obj[KEY_DEVICE_ID] | "";
    String stationId = obj[KEY_STATION_ID] | "";
    
    DEBUG_PRINT(F("DEBUG: Configuración de sistema parseada: initialized="));
    DEBUG_PRINT(initialized);
    DEBUG_PRINT(F(", sleepTime="));
    DEBUG_PRINT(sleepTime);
    DEBUG_PRINT(F(", deviceId="));
    DEBUG_PRINT(deviceId);
    DEBUG_PRINT(F(", stationId="));
    DEBUG_PRINTLN(stationId);
    
    ConfigManager::setSystemConfig(initialized, sleepTime, deviceId, stationId);
}

void BLEHandler::SystemConfigCallback::onRead(BLECharacteristic *pCharacteristic) {
    bool initialized;
    uint32_t sleepTime;
    String deviceId;
    String stationId;
    ConfigManager::getSystemConfig(initialized, sleepTime, deviceId, stationId);
    
    StaticJsonDocument<JSON_DOC_SIZE_SMALL> doc;
    JsonObject obj = doc.createNestedObject(NAMESPACE_SYSTEM);
    obj[KEY_INITIALIZED] = initialized;
    obj[KEY_SLEEP_TIME] = sleepTime;
    obj[KEY_DEVICE_ID] = deviceId;
    obj[KEY_STATION_ID] = stationId;

    String jsonString;
    serializeJson(doc, jsonString);
    DEBUG_PRINT(F("DEBUG: SystemConfigCallback onRead - JSON enviado: "));
    DEBUG_PRINTLN(jsonString);
    pCharacteristic->setValue(jsonString.c_str());
}

#ifdef DEVICE_TYPE_ANALOGIC
// Implementación de NTC100KConfigCallback
void BLEHandler::NTC100KConfigCallback::onWrite(BLECharacteristic *pCharacteristic) {
    DEBUG_PRINTLN(F("DEBUG: NTC100KConfigCallback onWrite - JSON recibido:"));
    DEBUG_PRINTLN(pCharacteristic->getValue().c_str());

    // Se espera un JSON de la forma: { "ntc_100k": { <parámetros> } }
    StaticJsonDocument<JSON_DOC_SIZE_SMALL> fullDoc;
    DeserializationError error = deserializeJson(fullDoc, pCharacteristic->getValue());
    if (error) {
        DEBUG_PRINT(F("Error deserializando NTC100K config: "));
        DEBUG_PRINTLN(error.c_str());
        return;
    }
    JsonObject doc = fullDoc[NAMESPACE_NTC100K];
    DEBUG_PRINT(F("DEBUG: NTC100K valores parseados - T1: "));
    DEBUG_PRINT(doc[KEY_NTC100K_T1] | 0.0);
    DEBUG_PRINT(F(", R1: "));
    DEBUG_PRINT(doc[KEY_NTC100K_R1] | 0.0);
    DEBUG_PRINT(F(", T2: "));
    DEBUG_PRINT(doc[KEY_NTC100K_T2] | 0.0);
    DEBUG_PRINT(F(", R2: "));
    DEBUG_PRINT(doc[KEY_NTC100K_R2] | 0.0);
    DEBUG_PRINT(F(", T3: "));
    DEBUG_PRINT(doc[KEY_NTC100K_T3] | 0.0);
    DEBUG_PRINT(F(", R3: "));
    DEBUG_PRINTLN(doc[KEY_NTC100K_R3] | 0.0);
    
    ConfigManager::setNTC100KConfig(
        doc[KEY_NTC100K_T1] | 0.0,
        doc[KEY_NTC100K_R1] | 0.0,
        doc[KEY_NTC100K_T2] | 0.0,
        doc[KEY_NTC100K_R2] | 0.0,
        doc[KEY_NTC100K_T3] | 0.0,
        doc[KEY_NTC100K_R3] | 0.0
    );
}

void BLEHandler::NTC100KConfigCallback::onRead(BLECharacteristic *pCharacteristic) {
    double t1, r1, t2, r2, t3, r3;
    ConfigManager::getNTC100KConfig(t1, r1, t2, r2, t3, r3);
    
    DEBUG_PRINT(F("DEBUG: NTC100KConfigCallback onRead - Config: T1="));
    DEBUG_PRINT(t1);
    DEBUG_PRINT(F(", R1="));
    DEBUG_PRINT(r1);
    DEBUG_PRINT(F(", T2="));
    DEBUG_PRINT(t2);
    DEBUG_PRINT(F(", R2="));
    DEBUG_PRINT(r2);
    DEBUG_PRINT(F(", T3="));
    DEBUG_PRINT(t3);
    DEBUG_PRINT(F(", R3="));
    DEBUG_PRINTLN(r3);
    
    StaticJsonDocument<JSON_DOC_SIZE_SMALL> fullDoc;
    // Crear objeto anidado con el namespace "ntc_100k"
    JsonObject doc = fullDoc.createNestedObject(NAMESPACE_NTC100K);
    doc[KEY_NTC100K_T1] = t1;
    doc[KEY_NTC100K_R1] = r1;
    doc[KEY_NTC100K_T2] = t2;
    doc[KEY_NTC100K_R2] = r2;
    doc[KEY_NTC100K_T3] = t3;
    doc[KEY_NTC100K_R3] = r3;
    
    String jsonString;
    serializeJson(fullDoc, jsonString);
    DEBUG_PRINT(F("DEBUG: NTC100KConfigCallback onRead - JSON enviado: "));
    DEBUG_PRINTLN(jsonString);
    pCharacteristic->setValue(jsonString.c_str());
}

// Implementación de NTC10KConfigCallback
void BLEHandler::NTC10KConfigCallback::onWrite(BLECharacteristic *pCharacteristic) {
    DEBUG_PRINTLN(F("DEBUG: NTC10KConfigCallback onWrite - JSON recibido:"));
    DEBUG_PRINTLN(pCharacteristic->getValue().c_str());
    
    // Se espera JSON: { "ntc_10k": { <parámetros> } }
    StaticJsonDocument<JSON_DOC_SIZE_SMALL> fullDoc;
    DeserializationError error = deserializeJson(fullDoc, pCharacteristic->getValue());
    if (error) {
        DEBUG_PRINT(F("Error deserializando NTC10K config: "));
        DEBUG_PRINTLN(error.c_str());
        return;
    }
    JsonObject doc = fullDoc[NAMESPACE_NTC10K];
    DEBUG_PRINT(F("DEBUG: NTC10K valores parseados - T1: "));
    DEBUG_PRINT(doc[KEY_NTC10K_T1] | 0.0);
    DEBUG_PRINT(F(", R1: "));
    DEBUG_PRINT(doc[KEY_NTC10K_R1] | 0.0);
    DEBUG_PRINT(F(", T2: "));
    DEBUG_PRINT(doc[KEY_NTC10K_T2] | 0.0);
    DEBUG_PRINT(F(", R2: "));
    DEBUG_PRINT(doc[KEY_NTC10K_R2] | 0.0);
    DEBUG_PRINT(F(", T3: "));
    DEBUG_PRINT(doc[KEY_NTC10K_T3] | 0.0);
    DEBUG_PRINT(F(", R3: "));
    DEBUG_PRINTLN(doc[KEY_NTC10K_R3] | 0.0);
    
    ConfigManager::setNTC10KConfig(
        doc[KEY_NTC10K_T1] | 0.0,
        doc[KEY_NTC10K_R1] | 0.0,
        doc[KEY_NTC10K_T2] | 0.0,
        doc[KEY_NTC10K_R2] | 0.0,
        doc[KEY_NTC10K_T3] | 0.0,
        doc[KEY_NTC10K_R3] | 0.0
    );
}

void BLEHandler::NTC10KConfigCallback::onRead(BLECharacteristic *pCharacteristic) {
    double t1, r1, t2, r2, t3, r3;
    ConfigManager::getNTC10KConfig(t1, r1, t2, r2, t3, r3);
    
    DEBUG_PRINT(F("DEBUG: NTC10KConfigCallback onRead - Config: T1="));
    DEBUG_PRINT(t1);
    DEBUG_PRINT(F(", R1="));
    DEBUG_PRINT(r1);
    DEBUG_PRINT(F(", T2="));
    DEBUG_PRINT(t2);
    DEBUG_PRINT(F(", R2="));
    DEBUG_PRINT(r2);
    DEBUG_PRINT(F(", T3="));
    DEBUG_PRINT(t3);
    DEBUG_PRINT(F(", R3="));
    DEBUG_PRINTLN(r3);
    
    StaticJsonDocument<JSON_DOC_SIZE_SMALL> fullDoc;
    JsonObject doc = fullDoc.createNestedObject(NAMESPACE_NTC10K);
    doc[KEY_NTC10K_T1] = t1;
    doc[KEY_NTC10K_R1] = r1;
    doc[KEY_NTC10K_T2] = t2;
    doc[KEY_NTC10K_R2] = r2;
    doc[KEY_NTC10K_T3] = t3;
    doc[KEY_NTC10K_R3] = r3;
    
    String jsonString;
    serializeJson(fullDoc, jsonString);
    DEBUG_PRINT(F("DEBUG: NTC10KConfigCallback onRead - JSON enviado: "));
    DEBUG_PRINTLN(jsonString);
    pCharacteristic->setValue(jsonString.c_str());
}

// Implementación de ConductivityConfigCallback
void BLEHandler::ConductivityConfigCallback::onWrite(BLECharacteristic *pCharacteristic) {
    DEBUG_PRINTLN(F("DEBUG: ConductivityConfigCallback onWrite - JSON recibido:"));
    DEBUG_PRINTLN(pCharacteristic->getValue().c_str());
    
    // Se espera un JSON: { "cond": { <parámetros> } }
    StaticJsonDocument<JSON_DOC_SIZE_SMALL> fullDoc;
    DeserializationError error = deserializeJson(fullDoc, pCharacteristic->getValue());
    if (error) {
        DEBUG_PRINT(F("Error deserializando Conductivity config: "));
        DEBUG_PRINTLN(error.c_str());
        return;
    }
    JsonObject doc = fullDoc[NAMESPACE_COND];
    
    DEBUG_PRINT(F("DEBUG: Conductivity valores parseados - CT: "));
    DEBUG_PRINT(doc[KEY_CONDUCT_CT] | 0.0f);
    DEBUG_PRINT(F(", CC: "));
    DEBUG_PRINT(doc[KEY_CONDUCT_CC] | 0.0f);
    DEBUG_PRINT(F(", V1: "));
    DEBUG_PRINT(doc[KEY_CONDUCT_V1] | 0.0f);
    DEBUG_PRINT(F(", T1: "));
    DEBUG_PRINT(doc[KEY_CONDUCT_T1] | 0.0f);
    DEBUG_PRINT(F(", V2: "));
    DEBUG_PRINT(doc[KEY_CONDUCT_V2] | 0.0f);
    DEBUG_PRINT(F(", T2: "));
    DEBUG_PRINT(doc[KEY_CONDUCT_T2] | 0.0f);
    DEBUG_PRINT(F(", V3: "));
    DEBUG_PRINT(doc[KEY_CONDUCT_V3] | 0.0f);
    DEBUG_PRINT(F(", T3: "));
    DEBUG_PRINTLN(doc[KEY_CONDUCT_T3] | 0.0f);
    
    ConfigManager::setConductivityConfig(
        doc[KEY_CONDUCT_CT] | 0.0f,  // Temperatura de calibración
        doc[KEY_CONDUCT_CC] | 0.0f,  // Coeficiente de compensación
        doc[KEY_CONDUCT_V1] | 0.0f,
        doc[KEY_CONDUCT_T1] | 0.0f,
        doc[KEY_CONDUCT_V2] | 0.0f,
        doc[KEY_CONDUCT_T2] | 0.0f,
        doc[KEY_CONDUCT_V3] | 0.0f,
        doc[KEY_CONDUCT_T3] | 0.0f
    );
}

void BLEHandler::ConductivityConfigCallback::onRead(BLECharacteristic *pCharacteristic) {
    float calTemp, coefComp, v1, t1, v2, t2, v3, t3;
    ConfigManager::getConductivityConfig(calTemp, coefComp, v1, t1, v2, t2, v3, t3);
    
    DEBUG_PRINT(F("DEBUG: ConductivityConfigCallback onRead - Config: CT="));
    DEBUG_PRINT(calTemp);
    DEBUG_PRINT(F(", CC="));
    DEBUG_PRINT(coefComp);
    DEBUG_PRINT(F(", V1="));
    DEBUG_PRINT(v1);
    DEBUG_PRINT(F(", T1="));
    DEBUG_PRINT(t1);
    DEBUG_PRINT(F(", V2="));
    DEBUG_PRINT(v2);
    DEBUG_PRINT(F(", T2="));
    DEBUG_PRINT(t2);
    DEBUG_PRINT(F(", V3="));
    DEBUG_PRINT(v3);
    DEBUG_PRINT(F(", T3="));
    DEBUG_PRINTLN(t3);
    
    StaticJsonDocument<JSON_DOC_SIZE_SMALL> fullDoc;
    JsonObject doc = fullDoc.createNestedObject(NAMESPACE_COND);
    doc[KEY_CONDUCT_CT] = calTemp;
    doc[KEY_CONDUCT_CC] = coefComp;
    doc[KEY_CONDUCT_V1] = v1;
    doc[KEY_CONDUCT_T1] = t1;
    doc[KEY_CONDUCT_V2] = v2;
    doc[KEY_CONDUCT_T2] = t2;
    doc[KEY_CONDUCT_V3] = v3;
    doc[KEY_CONDUCT_T3] = t3;
    
    String jsonString;
    serializeJson(fullDoc, jsonString);
    DEBUG_PRINT(F("DEBUG: ConductivityConfigCallback onRead - JSON enviado: "));
    DEBUG_PRINTLN(jsonString);
    pCharacteristic->setValue(jsonString.c_str());
}

// Implementación de PHConfigCallback
void BLEHandler::PHConfigCallback::onWrite(BLECharacteristic *pCharacteristic) {
    DEBUG_PRINTLN(F("DEBUG: PHConfigCallback onWrite - JSON recibido:"));
    DEBUG_PRINTLN(pCharacteristic->getValue().c_str());
    
    // Se espera JSON: { "ph": { <parámetros> } }
    StaticJsonDocument<JSON_DOC_SIZE_SMALL> fullDoc;
    DeserializationError error = deserializeJson(fullDoc, pCharacteristic->getValue());
    if (error) {
        DEBUG_PRINT(F("Error deserializando pH config: "));
        DEBUG_PRINTLN(error.c_str());
        return;
    }
    JsonObject doc = fullDoc[NAMESPACE_PH];
    DEBUG_PRINT(F("DEBUG: pH valores parseados - V1: "));
    DEBUG_PRINT(doc[KEY_PH_V1] | 0.0f);
    DEBUG_PRINT(F(", T1: "));
    DEBUG_PRINT(doc[KEY_PH_T1] | 0.0f);
    DEBUG_PRINT(F(", V2: "));
    DEBUG_PRINT(doc[KEY_PH_V2] | 0.0f);
    DEBUG_PRINT(F(", T2: "));
    DEBUG_PRINT(doc[KEY_PH_T2] | 0.0f);
    DEBUG_PRINT(F(", V3: "));
    DEBUG_PRINT(doc[KEY_PH_V3] | 0.0f);
    DEBUG_PRINT(F(", T3: "));
    DEBUG_PRINT(doc[KEY_PH_T3] | 0.0f);
    DEBUG_PRINT(F(", CT: "));
    DEBUG_PRINTLN(doc[KEY_PH_CT] | 25.0f);
    
    ConfigManager::setPHConfig(
        doc[KEY_PH_V1] | 0.0f,
        doc[KEY_PH_T1] | 0.0f,
        doc[KEY_PH_V2] | 0.0f,
        doc[KEY_PH_T2] | 0.0f,
        doc[KEY_PH_V3] | 0.0f,
        doc[KEY_PH_T3] | 0.0f,
        doc[KEY_PH_CT] | 25.0f
    );
}

void BLEHandler::PHConfigCallback::onRead(BLECharacteristic *pCharacteristic) {
    float v1, t1, v2, t2, v3, t3, calTemp;
    ConfigManager::getPHConfig(v1, t1, v2, t2, v3, t3, calTemp);
    
    DEBUG_PRINT(F("DEBUG: PHConfigCallback onRead - Config: V1="));
    DEBUG_PRINT(v1);
    DEBUG_PRINT(F(", T1="));
    DEBUG_PRINT(t1);
    DEBUG_PRINT(F(", V2="));
    DEBUG_PRINT(v2);
    DEBUG_PRINT(F(", T2="));
    DEBUG_PRINT(t2);
    DEBUG_PRINT(F(", V3="));
    DEBUG_PRINT(v3);
    DEBUG_PRINT(F(", T3="));
    DEBUG_PRINT(t3);
    DEBUG_PRINT(F(", CT="));
    DEBUG_PRINTLN(calTemp);
    
    StaticJsonDocument<JSON_DOC_SIZE_SMALL> fullDoc;
    JsonObject doc = fullDoc.createNestedObject(NAMESPACE_PH);
    doc[KEY_PH_V1] = v1;
    doc[KEY_PH_T1] = t1;
    doc[KEY_PH_V2] = v2;
    doc[KEY_PH_T2] = t2;
    doc[KEY_PH_V3] = v3;
    doc[KEY_PH_T3] = t3;
    doc[KEY_PH_CT] = calTemp;
    
    String jsonString;
    serializeJson(fullDoc, jsonString);
    DEBUG_PRINT(F("DEBUG: PHConfigCallback onRead - JSON enviado: "));
    DEBUG_PRINTLN(jsonString);
    pCharacteristic->setValue(jsonString.c_str());
}
#endif // DEVICE_TYPE_ANALOGIC

#if defined(DEVICE_TYPE_BASIC) || defined(DEVICE_TYPE_ANALOGIC) || defined(DEVICE_TYPE_MODBUS)
// Implementación de SensorsConfigCallback
void BLEHandler::SensorsConfigCallback::onWrite(BLECharacteristic *pCharacteristic) {
    DEBUG_PRINTLN(F("DEBUG: SensorsConfigCallback onWrite - JSON recibido:"));
    DEBUG_PRINTLN(pCharacteristic->getValue().c_str());
    
    // Se espera un JSON: { "sensors": [ {<sensor1>}, {<sensor2>}, ... ] }
    DynamicJsonDocument doc(JSON_DOC_SIZE_LARGE);
    DeserializationError error = deserializeJson(doc, pCharacteristic->getValue());
    if (error) {
        DEBUG_PRINT(F("Error deserializando Sensors config: "));
        DEBUG_PRINTLN(error.c_str());
        return;
    }
    
    std::vector<SensorConfig> configs;
    JsonArray sensorArray = doc[NAMESPACE_SENSORS];
    
    for (JsonVariant sensor : sensorArray) {
        SensorConfig config;
        strncpy(config.configKey, sensor[KEY_SENSOR] | "", sizeof(config.configKey));
        strncpy(config.sensorId, sensor[KEY_SENSOR_ID] | "", sizeof(config.sensorId));
        strncpy(config.tempSensorId, sensor[KEY_SENSOR_ID_TEMPERATURE_SENSOR] | "", sizeof(config.tempSensorId));
        config.type = static_cast<SensorType>(sensor[KEY_SENSOR_TYPE] | 0);
        config.enable = sensor[KEY_SENSOR_ENABLE] | false;
        
        DEBUG_PRINT(F("DEBUG: Sensor config parsed - key: "));
        DEBUG_PRINT(config.configKey);
        DEBUG_PRINT(F(", sensorId: "));
        DEBUG_PRINT(config.sensorId);
        DEBUG_PRINT(F(", tempSensorId: "));
        DEBUG_PRINT(config.tempSensorId);
        DEBUG_PRINT(F(", type: "));
        DEBUG_PRINT(static_cast<int>(config.type));
        DEBUG_PRINT(F(", enable: "));
        DEBUG_PRINTLN(config.enable ? "true" : "false");
        
        configs.push_back(config);
    }
    
    ConfigManager::setSensorsConfigs(configs);
}

void BLEHandler::SensorsConfigCallback::onRead(BLECharacteristic *pCharacteristic) {
    DynamicJsonDocument doc(JSON_DOC_SIZE_LARGE);
    JsonArray sensorArray = doc.createNestedArray(NAMESPACE_SENSORS);

    std::vector<SensorConfig> configs = ConfigManager::getAllSensorConfigs();
    
    DEBUG_PRINTLN(F("DEBUG: SensorsConfigCallback onRead - Configuraciones de sensores obtenidas:"));
    for (const auto& sensor : configs) {
        DEBUG_PRINT(F("DEBUG: Sensor config - key: "));
        DEBUG_PRINT(sensor.configKey);
        DEBUG_PRINT(F(", sensorId: "));
        DEBUG_PRINT(sensor.sensorId);
        DEBUG_PRINT(F(", type: "));
        DEBUG_PRINT(static_cast<int>(sensor.type));
        DEBUG_PRINT(F(", tempSensorId: "));
        DEBUG_PRINT(sensor.tempSensorId);
        DEBUG_PRINT(F(", enable: "));
        DEBUG_PRINTLN(sensor.enable ? "true" : "false");

        JsonObject obj = sensorArray.createNestedObject();
        obj[KEY_SENSOR]             = sensor.configKey;
        obj[KEY_SENSOR_ID]          = sensor.sensorId;
        obj[KEY_SENSOR_TYPE]        = static_cast<int>(sensor.type);
        obj[KEY_SENSOR_ID_TEMPERATURE_SENSOR]   = sensor.tempSensorId;
        obj[KEY_SENSOR_ENABLE]      = sensor.enable;
    }

    String jsonString;
    serializeJson(doc, jsonString);
    DEBUG_PRINT(F("DEBUG: SensorsConfigCallback onRead - JSON enviado: "));
    DEBUG_PRINTLN(jsonString);
    pCharacteristic->setValue(jsonString.c_str());
}
#endif

// Implementación de LoRaConfigCallback
void BLEHandler::LoRaConfigCallback::onWrite(BLECharacteristic* pCharacteristic) {
    DEBUG_PRINTLN(F("DEBUG: LoRaConfigCallback onWrite - JSON recibido:"));
    DEBUG_PRINTLN(pCharacteristic->getValue().c_str());
    
    // Se espera JSON: { "lorawan": { <parámetros> } }
    StaticJsonDocument<JSON_DOC_SIZE_SMALL> fullDoc;
    DeserializationError error = deserializeJson(fullDoc, pCharacteristic->getValue());
    if (error) {
        DEBUG_PRINT(F("Error deserializando LoRa config: "));
        DEBUG_PRINTLN(error.c_str());
        return;
    }
    JsonObject doc = fullDoc[NAMESPACE_LORAWAN];
    String joinEUI     = doc[KEY_LORA_JOIN_EUI]      | "";
    String devEUI     = doc[KEY_LORA_DEV_EUI]      | "";
    String nwkKey     = doc[KEY_LORA_NWK_KEY]      | "";
    String appKey     = doc[KEY_LORA_APP_KEY]      | "";
    
    DEBUG_PRINT(F("DEBUG: LoRa valores parseados - joinEUI: "));
    DEBUG_PRINT(joinEUI);
    DEBUG_PRINT(F(", devEUI: "));
    DEBUG_PRINT(devEUI);
    DEBUG_PRINT(F(", nwkKey: "));
    DEBUG_PRINT(nwkKey);
    DEBUG_PRINT(F(", appKey: "));
    DEBUG_PRINTLN(appKey);
    
    ConfigManager::setLoRaConfig(joinEUI, devEUI, nwkKey, appKey);
}

void BLEHandler::LoRaConfigCallback::onRead(BLECharacteristic* pCharacteristic) {
    LoRaConfig config = ConfigManager::getLoRaConfig();
    
    DEBUG_PRINTLN(F("DEBUG: LoRaConfigCallback onRead - Config obtenido:"));
    DEBUG_PRINT(F("joinEUI: "));
    DEBUG_PRINTLN(config.joinEUI);
    DEBUG_PRINT(F("devEUI: "));
    DEBUG_PRINTLN(config.devEUI);
    DEBUG_PRINT(F("nwkKey: "));
    DEBUG_PRINTLN(config.nwkKey);
    
    // Aumentamos el tamaño del documento para asegurarnos de incluir todas las claves
    StaticJsonDocument<JSON_DOC_SIZE_SMALL> fullDoc;
    JsonObject doc = fullDoc.createNestedObject(NAMESPACE_LORAWAN);
    doc[KEY_LORA_JOIN_EUI]     = config.joinEUI;
    doc[KEY_LORA_DEV_EUI]     = config.devEUI;
    doc[KEY_LORA_NWK_KEY]     = config.nwkKey;
    doc[KEY_LORA_APP_KEY]     = config.appKey;
    String jsonString;
    serializeJson(fullDoc, jsonString);
    DEBUG_PRINT(F("DEBUG: LoRaConfigCallback onRead - JSON enviado: "));
    DEBUG_PRINTLN(jsonString);
    pCharacteristic->setValue(jsonString.c_str());
}

================
File: src/clsPCA9555.cpp
================
/**
 * @file    clsPCA9555.cpp
 * @author     Nico Verduin
 * @date      9-8-2015
 *
 * @mainpage  clsPCA9555
 * Class to enable pinMode(), digitalRead() and digitalWrite() functions on PCA9555 IO expanders
 *
 * Additional input received from Rob Tillaart (9-8-2015)
 *
 * @par License info
 *
 * Class to enable the use of single pins on PCA9555 IO Expander using
 * pinMode(), digitalRead() and digitalWrite().
 *
 * Copyright (C) 2015  Nico Verduin
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Program : clsPCA9555  Copyright (C) 2015  Nico Verduin
 * This is free software, and you are welcome to redistribute it.
 *
 */

#if defined(ARDUINO) && ARDUINO >= 100
#include "Arduino.h"
#else
#include "WProgram.h"
#endif

#include "clsPCA9555.h"
#include "Wire.h"
#include "debug.h"

PCA9555* PCA9555::instancePointer = 0;

/**
 * @name PCA9555 constructor
 * @param address I2C address of the IO Expander
 * Creates the class interface and sets the I2C Address of the port
 */
PCA9555::PCA9555(uint8_t address, int interruptPin) {
    _address         = address;        // save the address id
    _valueRegister   = 0;
    Wire.begin();                      // start I2C communication

    if(interruptPin >= 0)
    {
    instancePointer = this;
    attachInterrupt(digitalPinToInterrupt(interruptPin), PCA9555::alertISR, LOW); // Set to low for button presses
    }
}

PCA9555::PCA9555(uint8_t address, int sda, int scl, int interruptPin) {
    _address = address;
    _sda = sda;
    _scl = scl;
    _valueRegister = 0;
    Wire.begin(sda, scl); // Inicia I2C con los pines especificados

    if (interruptPin >= 0) {
        instancePointer = this;
        attachInterrupt(digitalPinToInterrupt(interruptPin), PCA9555::alertISR, LOW);
    }
}

// Checks if PCA9555 is responsive. Refer to Wire.endTransmission() from Arduino for details.
bool PCA9555::begin() {
    // Dar tiempo para que se estabilice el bus I2C
    delay(10);
    
    // Intentar varias veces la inicialización
    for (int intento = 0; intento < 3; intento++) {
        Wire.beginTransmission(_address);
        Wire.write(0x02);
        _error = Wire.endTransmission();

        if (_error == 0) {
            // Configuración inicial
            _valueRegister = 0x0000;          
            _configurationRegister = 0x0000;
            
            // Añadir pequeños delays entre escrituras I2C
            I2CSetValue(_address, NXP_OUTPUT, _valueRegister_low);
            delay(5);
            I2CSetValue(_address, NXP_OUTPUT + 1, _valueRegister_high);
            delay(5);
            I2CSetValue(_address, NXP_CONFIG, _configurationRegister_low);
            delay(5);
            I2CSetValue(_address, NXP_CONFIG + 1, _configurationRegister_high);

            return true;
        }
        
        delay(50);  // Esperar antes del siguiente intento
    }

    // Solo mostrar error después de todos los intentos fallidos
    DEBUG_PRINT("Error al inicializar PCA9555 en la dirección 0x");
    DEBUG_PRINT(_address, HEX);
    DEBUG_PRINT(": ");
    switch (_error) {
        case 1: DEBUG_PRINTLN("Datos demasiado largos para el búfer de envío"); break;
        case 2: DEBUG_PRINTLN("Dirección NACK recibida en la transmisión"); break;
        case 3: DEBUG_PRINTLN("Datos NACK recibidos en la transmisión"); break;
        case 4: DEBUG_PRINTLN("Otro error"); break;
        default: DEBUG_PRINTLN("Error desconocido"); break;
    }
    
    return false;
}

/**
 * @name pinMode
 * @param pin       pin number
 * @param IOMode    mode of pin INPUT or OUTPUT
 * sets the mode of this IO pin
 */
void PCA9555::pinMode(uint8_t pin, uint8_t IOMode) {

    //
    // check if valid pin first
    //
    if (pin <= 15) {
        //
        // now set the correct bit in the configuration register
        //
        if (IOMode == OUTPUT) {
            //
            // mask correct bit to 0 by inverting x so that only
            // the correct bit is LOW. The rest stays HIGH
            //
            _configurationRegister = _configurationRegister & ~(1 << pin);
        } else {
            //
            // or just the required bit to 1
            //
            _configurationRegister = _configurationRegister | (1 << pin);
        }
        //
        // write configuration register to chip
        //
        I2CSetValue(_address, NXP_CONFIG    , _configurationRegister_low);
        I2CSetValue(_address, NXP_CONFIG + 1, _configurationRegister_high);
    }
}
/**
 * @name digitalRead Reads the high/low value of specified pin
 * @param pin
 * @return value of pin
 * Reads the selected pin.
 */
uint8_t PCA9555::digitalRead(uint8_t pin) {
    uint16_t _inputData = 0;
    //
    // we wil only process pins <= 15
    //
    if (pin > 15 ) return 255;
    _inputData  = I2CGetValue(_address, NXP_INPUT);
    _inputData |= I2CGetValue(_address, NXP_INPUT + 1) << 8;
    //
    // now mask the bit required and see if it is a HIGH
    //
    if ((_inputData & (1 << pin)) > 0){
        //
        // the bit is HIGH otherwise we would return a LOW value
        //
        return HIGH;
    } else {
        return LOW;
    }
}

void PCA9555::digitalWrite(uint8_t pin, uint8_t value) {
    //
    // check valid pin first
    //
    if (pin > 15 ){
        _error = 255;            // invalid pin
        return;                  // exit
    }
    //
    // if the value is LOW we will and the register value with correct bit set to zero
    // if the value is HIGH we will or the register value with correct bit set to HIGH
    //
    if (value > 0) {
        //
        // this is a High value so we will or it with the value register
        //
        _valueRegister = _valueRegister | (1 << pin);    // and OR bit in register
    } else {
        //
        // this is a LOW value so we have to AND it with 0 into the _valueRegister
        //
        _valueRegister = _valueRegister & ~(1 << pin);    // AND all bits
    }
    I2CSetValue(_address, NXP_OUTPUT    , _valueRegister_low);
    I2CSetValue(_address, NXP_OUTPUT + 1, _valueRegister_high);
}

// This is the actual ISR
// Stores states of all pins in _stateOfPins
void PCA9555::pinStates(){
  _stateOfPins = I2CGetValue(_address, NXP_INPUT);
  _stateOfPins|= I2CGetValue(_address, NXP_INPUT + 1) << 8;
}

// Returns to user the state of desired pin
uint8_t PCA9555::stateOfPin(uint8_t pin){
  if ((_stateOfPins & (1 << pin)) > 0){
    //
    // the bit is HIGH otherwise we would return a LOW value
    //
    return HIGH;
  } else {
    return LOW;
  }
}

/**
 * @name setClock modifies the clock frequency for I2C communication
 * @param clockFrequency
 * clockFrequency: the value (in Hertz) of desired communication clock.
 * The PCA9555 supports a 400kHz clock.
 * Accepted values are:
 *    10000 low speed mode, supported on some processors
 *    100000, standard mode
 *    400000, fast mode
 */
void PCA9555::setClock(uint32_t clockFrequency){
  Wire.setClock(clockFrequency);
}

void PCA9555::alertISR()
{
  if (instancePointer != 0)
  {
    instancePointer->pinStates(); // Points to the actual ISR
  }
}

//
// low level hardware methods
//

/**
 * @name I2CGetValue
 * @param address Address of I2C chip
 * @param reg    Register to read from
 * @return data in register
 * Reads the data from addressed chip at selected register. \n
 * If the value is above 255, an error is set. \n
 * error codes : \n
 * 256 = either 0 or more than one byte is received from the chip
 */
uint16_t PCA9555::I2CGetValue(uint8_t address, uint8_t reg) {
    uint16_t _inputData;
    //
    // read the address input register
    //
    Wire.beginTransmission(address);          // setup read registers
    Wire.write(reg);
    _error = Wire.endTransmission();
    //
    // ask for 2 bytes to be returned
    //
    if (Wire.requestFrom((int)address, 1) != 1)
    {
        //
        // we are not receing the bytes we need
        //
        return 256;                            // error code is above normal data range
    };
    //
    // read both bytes
    //
    _inputData = Wire.read();
    return _inputData;
}

/**
 * @name I2CSetValue(uint8_t address, uint8_t reg, uint8_t value)
 * @param address Address of I2C chip
 * @param reg    register to write to
 * @param value    value to write to register
 * Write the value given to the register set to selected chip.
 */
void PCA9555::I2CSetValue(uint8_t address, uint8_t reg, uint8_t value){
    //
    // write output register to chip
    //
    Wire.beginTransmission(address);              // setup direction registers
    Wire.write(reg);                              // pointer to configuration register address 0
    Wire.write(value);                            // write config register low byte
    _error = Wire.endTransmission();
}

void PCA9555::sleep() {
    // 1) Prepara registros locales (16 bits) para la configuración y el valor de salida
    //    Empezamos con todo en 0 (por defecto, consideraremos OUTPUT=0 y LOW=0).
    uint16_t tempConfig = 0x0000;  // 0 => OUTPUT, 1 => INPUT
    uint16_t tempOutput = 0x0000;  // 0 => LOW,    1 => HIGH

#ifdef DEVICE_TYPE_BASIC
    // Configuración para dispositivo BASIC
    // Para los pines que sean INPUT (por ejemplo pin 2, 5, 6, 7, 10...15),
    // ponemos su bit correspondiente en 1 dentro de tempConfig.
    // Ejemplo: pin 2 como INPUT => set bit 2 de tempConfig a 1:
    tempConfig |= (1 << 1);   // pin 1 => INPUT
    tempConfig |= (1 << 2);   // pin 2 => INPUT
    tempConfig |= (1 << 4);   // pin 4 => INPUT
    tempConfig |= (1 << 5);   // pin 5 => INPUT
    tempConfig |= (1 << 6);   // pin 6 => INPUT
    tempConfig |= (1 << 11);  // pin 11 => INPUT
    tempConfig |= (1 << 12);  // pin 12 => INPUT
    tempConfig |= (1 << 13);  // pin 13 => INPUT
    tempConfig |= (1 << 14);  // pin 14 => INPUT
    tempConfig |= (1 << 15);  // pin 15 => INPUT
    // Si no se pone un bit en 1 explícitamente, queda en 0 => OUTPUT.

    // Para los pines que son OUTPUT y queramos poner en HIGH (p. ej. pin 1, 4, 9),
    // establecemos el bit correspondiente en tempOutput:
    tempOutput |= (1 << 3);  // pin 3 => HIGH //ss de pt100
    // Los pines OUTPUT sin setear aquí quedan en LOW (por defecto tempOutput=0).
#endif

#ifdef DEVICE_TYPE_MODBUS
    // Configuración para dispositivo MODBUS
    //Power manager commentados para que esten como output bajo
    //tempConfig |= (1 << 0);  // pin 1 => INPUT
    //tempOutput |= (1 << 1);  // pin 1 => INPUT

    //unused pins
    tempConfig |= (1 << 2);  // pin 11 => INPUT
    tempConfig |= (1 << 3);  // pin 12 => INPUT //cs de pt100, gasta menos con estado input flotante
    tempConfig |= (1 << 4);  // pin 12 => INPUT
    tempConfig |= (1 << 5);  // pin 13 => INPUT
    tempConfig |= (1 << 6);  // pin 14 => INPUT
    tempConfig |= (1 << 11);  // pin 11 => INPUT
    tempConfig |= (1 << 12);  // pin 12 => INPUT
    tempConfig |= (1 << 13);  // pin 13 => INPUT
    tempConfig |= (1 << 14);  // pin 14 => INPUT
    tempConfig |= (1 << 15);  // pin 15 => INPUT

    //Actuadores se quedan en output bajo
    tempConfig |= (1 << 7);  // pin 15 => INPUT
    tempConfig |= (1 << 8);  // pin 15 => INPUT

    // //Leds comentados para que sean output bajo
    // tempConfig |= (1 << 9);  // pin 15 => INPUT
    // tempConfig |= (1 << 10);  // pin 15 => INPUT
    tempOutput |= (0 << 9);  // pin 9 => LOW //ss de pt100
    tempOutput |= (0 << 10);  // pin 10 => LOW //ss de pt100
#endif

#ifdef DEVICE_TYPE_ANALOGIC
    // Configuración para dispositivo ANALOGIC
    // Para los pines que sean INPUT, ponemos su bit correspondiente en 1 dentro de tempConfig
    tempConfig |= (1 << 1);   // pin 1 => INPUT
    tempConfig |= (1 << 2);   // pin 2 => INPUT
    tempConfig |= (1 << 4);   // pin 4 => INPUT
    tempConfig |= (1 << 5);   // pin 5 => INPUT
    tempConfig |= (1 << 6);   // pin 6 => INPUT
    tempConfig |= (1 << 10);  // pin 10 => INPUT //Entrada analógica
    tempConfig |= (1 << 11);  // pin 11 => INPUT
    tempConfig |= (1 << 12);  // pin 12 => INPUT
    tempConfig |= (1 << 13);  // pin 13 => INPUT
    tempConfig |= (1 << 14);  // pin 14 => INPUT
    tempConfig |= (1 << 15);  // pin 15 => INPUT
    
    // Para los pines que son OUTPUT y queramos poner en HIGH
    tempOutput |= (1 << 3);   // pin 3 => HIGH //ss de pt100
    tempOutput |= (1 << 8);   // pin 8 => HIGH //Activación de circuito analógico
#endif

    // -------------------------------------------------------------
    // 2) Volcamos estos valores a las variables miembros y escribimos en el PCA9555
    //    Primero el registro de OUTPUT, luego el de CONFIG.
    //    (OJO: cuando un pin es INPUT, da igual el bit de salida que pongas).
    _valueRegister         = tempOutput;
    _configurationRegister = tempConfig;

    I2CSetValue(_address, NXP_OUTPUT, _valueRegister_low);
    I2CSetValue(_address, NXP_OUTPUT + 1, _valueRegister_high);

    I2CSetValue(_address, NXP_CONFIG, _configurationRegister_low);
    I2CSetValue(_address, NXP_CONFIG + 1, _configurationRegister_high);
}

================
File: src/config_manager.cpp
================
#include "config_manager.h"
#include <ArduinoJson.h>
#include <vector>
#include "config.h"
#include "sensor_types.h"
#include <Preferences.h>
#include <Arduino.h> // Incluido para usar Serial

/* =========================================================================
   FUNCIONES AUXILIARES
   ========================================================================= */
// Funciones auxiliares para leer y escribir el JSON completo en cada namespace.
static void writeNamespace(const char* ns, const StaticJsonDocument<JSON_DOC_SIZE_MEDIUM>& doc) {
    Preferences prefs;
    prefs.begin(ns, false);
    String jsonString;
    serializeJson(doc, jsonString);
    // Se usa el mismo nombre del namespace como clave interna
    prefs.putString(ns, jsonString.c_str());
    prefs.end();
}

static void readNamespace(const char* ns, StaticJsonDocument<JSON_DOC_SIZE_MEDIUM>& doc) {
    Preferences prefs;
    prefs.begin(ns, true);
    String jsonString = prefs.getString(ns, "{}");
    prefs.end();
    deserializeJson(doc, jsonString);
}

// Configuración por defecto de sensores NO-modbus
const SensorConfig ConfigManager::defaultConfigs[] = DEFAULT_SENSOR_CONFIGS;

/* =========================================================================
   INICIALIZACIÓN Y CONFIGURACIÓN DEL SISTEMA
   ========================================================================= */
bool ConfigManager::checkInitialized() {
    StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
    readNamespace(NAMESPACE_SYSTEM, doc);
    return doc[KEY_INITIALIZED] | false;
}

void ConfigManager::initializeDefaultConfig() {
    /* -------------------------------------------------------------------------
       1. INICIALIZACIÓN DE CONFIGURACIÓN DEL SISTEMA
       ------------------------------------------------------------------------- */
    // Sistema unificado: NAMESPACE_SYSTEM (incluye system, sleep y device)
    // Común para todos los tipos de dispositivo
    {
        StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
        doc[KEY_STATION_ID] = DEFAULT_STATION_ID;
        doc[KEY_INITIALIZED] = true;
        doc[KEY_SLEEP_TIME] = DEFAULT_TIME_TO_SLEEP;
        doc[KEY_DEVICE_ID] = DEFAULT_DEVICE_ID;
        writeNamespace(NAMESPACE_SYSTEM, doc);
    }
    
#ifdef DEVICE_TYPE_ANALOGIC
    /* -------------------------------------------------------------------------
       2. INICIALIZACIÓN DE SENSORES ANALÓGICOS (Solo para dispositivo analógico)
       ------------------------------------------------------------------------- */
    // NTC 100K: NAMESPACE_NTC100K
    {
        StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
        doc[KEY_NTC100K_T1] = DEFAULT_T1_100K;
        doc[KEY_NTC100K_R1] = DEFAULT_R1_100K;
        doc[KEY_NTC100K_T2] = DEFAULT_T2_100K;
        doc[KEY_NTC100K_R2] = DEFAULT_R2_100K;
        doc[KEY_NTC100K_T3] = DEFAULT_T3_100K;
        doc[KEY_NTC100K_R3] = DEFAULT_R3_100K;
        writeNamespace(NAMESPACE_NTC100K, doc);
    }
    
    // NTC 10K: NAMESPACE_NTC10K
    {
        StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
        doc[KEY_NTC10K_T1] = DEFAULT_T1_10K;
        doc[KEY_NTC10K_R1] = DEFAULT_R1_10K;
        doc[KEY_NTC10K_T2] = DEFAULT_T2_10K;
        doc[KEY_NTC10K_R2] = DEFAULT_R2_10K;
        doc[KEY_NTC10K_T3] = DEFAULT_T3_10K;
        doc[KEY_NTC10K_R3] = DEFAULT_R3_10K;
        writeNamespace(NAMESPACE_NTC10K, doc);
    }
    
    // Conductividad: NAMESPACE_COND
    {
        StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
        doc[KEY_CONDUCT_CT] = CONDUCTIVITY_DEFAULT_TEMP;
        doc[KEY_CONDUCT_CC] = TEMP_COEF_COMPENSATION;
        doc[KEY_CONDUCT_V1] = CONDUCTIVITY_DEFAULT_V1;
        doc[KEY_CONDUCT_T1] = CONDUCTIVITY_DEFAULT_T1;
        doc[KEY_CONDUCT_V2] = CONDUCTIVITY_DEFAULT_V2;
        doc[KEY_CONDUCT_T2] = CONDUCTIVITY_DEFAULT_T2;
        doc[KEY_CONDUCT_V3] = CONDUCTIVITY_DEFAULT_V3;
        doc[KEY_CONDUCT_T3] = CONDUCTIVITY_DEFAULT_T3;
        writeNamespace(NAMESPACE_COND, doc);
    }
    
    // pH: NAMESPACE_PH
    {
        StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
        doc[KEY_PH_V1] = PH_DEFAULT_V1;
        doc[KEY_PH_T1] = PH_DEFAULT_T1;
        doc[KEY_PH_V2] = PH_DEFAULT_V2;
        doc[KEY_PH_T2] = PH_DEFAULT_T2;
        doc[KEY_PH_V3] = PH_DEFAULT_V3;
        doc[KEY_PH_T3] = PH_DEFAULT_T3;
        doc[KEY_PH_CT] = PH_DEFAULT_TEMP;
        writeNamespace(NAMESPACE_PH, doc);
    }
#endif
    
    /* -------------------------------------------------------------------------
       3. INICIALIZACIÓN DE SENSORES NO-MODBUS
       ------------------------------------------------------------------------- */
    {
        Preferences prefs;
        prefs.begin(NAMESPACE_SENSORS, false);
        StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
        JsonArray sensorArray = doc.to<JsonArray>(); // Array raíz

        for (const auto& config : ConfigManager::defaultConfigs) {
            JsonObject sensorObj = sensorArray.createNestedObject();
            sensorObj[KEY_SENSOR] = config.configKey;
            sensorObj[KEY_SENSOR_ID] = config.sensorId;
            sensorObj[KEY_SENSOR_TYPE] = static_cast<int>(config.type);
            sensorObj[KEY_SENSOR_CHANNEL] = config.channel;
            sensorObj[KEY_SENSOR_ID_TEMPERATURE_SENSOR] = config.tempSensorId;
            sensorObj[KEY_SENSOR_ENABLE] = config.enable;
        }
        
        String jsonString;
        serializeJson(doc, jsonString);
        prefs.putString(NAMESPACE_SENSORS, jsonString.c_str());
        prefs.end();
    }
    
    /* -------------------------------------------------------------------------
       4. INICIALIZACIÓN DE CONFIGURACIÓN DE LORA
       ------------------------------------------------------------------------- */
    {
        StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
        doc[KEY_LORA_JOIN_EUI]      = DEFAULT_JOIN_EUI;
        doc[KEY_LORA_DEV_EUI]       = DEFAULT_DEV_EUI;
        doc[KEY_LORA_NWK_KEY]       = DEFAULT_NWK_KEY;
        doc[KEY_LORA_APP_KEY]       = DEFAULT_APP_KEY;
        writeNamespace(NAMESPACE_LORAWAN, doc);
    }

#if defined(DEVICE_TYPE_MODBUS) || defined(DEVICE_TYPE_ANALOGIC)
    /* -------------------------------------------------------------------------
       5. INICIALIZACIÓN DE SENSORES MODBUS
       ------------------------------------------------------------------------- */
    {
        Preferences prefs;
        prefs.begin(NAMESPACE_SENSORS_MODBUS, false);
        StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
        JsonArray sensorArray = doc.to<JsonArray>(); 

        // Cargamos un default (definido en config.h)
        static const ModbusSensorConfig defaultModbusSensors[] = DEFAULT_MODBUS_SENSOR_CONFIGS;
        size_t count = sizeof(defaultModbusSensors)/sizeof(defaultModbusSensors[0]);

        for (size_t i = 0; i < count; i++) {
            JsonObject sensorObj = sensorArray.createNestedObject();
            sensorObj[KEY_MODBUS_SENSOR_ID]    = defaultModbusSensors[i].sensorId;
            sensorObj[KEY_MODBUS_SENSOR_TYPE]  = (int)defaultModbusSensors[i].type;
            sensorObj[KEY_MODBUS_SENSOR_ADDR] = defaultModbusSensors[i].address;
            sensorObj[KEY_MODBUS_SENSOR_ENABLE]   = defaultModbusSensors[i].enable;
        }
        
        String jsonString;
        serializeJson(doc, jsonString);
        prefs.putString(NAMESPACE_SENSORS_MODBUS, jsonString.c_str());
        prefs.end();
    }
#endif
}

void ConfigManager::getSystemConfig(bool &initialized, uint32_t &sleepTime, String &deviceId, String &stationId) {
    StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
    readNamespace(NAMESPACE_SYSTEM, doc);
    initialized = doc[KEY_INITIALIZED] | false;
    sleepTime = doc[KEY_SLEEP_TIME] | DEFAULT_TIME_TO_SLEEP;
    deviceId = String(doc[KEY_DEVICE_ID] | DEFAULT_DEVICE_ID);
    stationId = String(doc[KEY_STATION_ID] | DEFAULT_STATION_ID);
}

void ConfigManager::setSystemConfig(bool initialized, uint32_t sleepTime, const String &deviceId, const String &stationId) {
    StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
    readNamespace(NAMESPACE_SYSTEM, doc);
    doc[KEY_INITIALIZED] = initialized;
    doc[KEY_SLEEP_TIME] = sleepTime;
    doc[KEY_DEVICE_ID] = deviceId;
    doc[KEY_STATION_ID] = stationId;
    writeNamespace(NAMESPACE_SYSTEM, doc);
}

/* =========================================================================
   CONFIGURACIÓN DE SENSORES NO-MODBUS
   ========================================================================= */
std::vector<SensorConfig> ConfigManager::getAllSensorConfigs() {
    std::vector<SensorConfig> configs;
    StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
    readNamespace(NAMESPACE_SENSORS, doc);
    
    if (!doc.is<JsonArray>()) {
        // Si no es un arreglo, no hay nada que leer
        return configs;
    }
    
    JsonArray sensorArray = doc.as<JsonArray>();
    for (JsonObject sensorObj : sensorArray) {
        SensorConfig config;
        const char* cKey = sensorObj[KEY_SENSOR] | "";
        strncpy(config.configKey, cKey, sizeof(config.configKey));
        const char* sensorId = sensorObj[KEY_SENSOR_ID] | "";
        strncpy(config.sensorId, sensorId, sizeof(config.sensorId));
        config.type = static_cast<SensorType>(sensorObj[KEY_SENSOR_TYPE] | 0);
        config.channel = sensorObj[KEY_SENSOR_CHANNEL] | 0;
        const char* tempSensorId = sensorObj[KEY_SENSOR_ID_TEMPERATURE_SENSOR] | "";
        strncpy(config.tempSensorId, tempSensorId, sizeof(config.tempSensorId));
        config.enable = sensorObj[KEY_SENSOR_ENABLE] | false;
        
        configs.push_back(config);
    }
    
    return configs;
}

std::vector<SensorConfig> ConfigManager::getEnabledSensorConfigs() {
    std::vector<SensorConfig> allSensors = getAllSensorConfigs();
    
    std::vector<SensorConfig> enabledSensors;
    for (const auto& sensor : allSensors) {
        if (sensor.enable && strlen(sensor.sensorId) > 0) {
            enabledSensors.push_back(sensor);
        }
    }
    
    return enabledSensors;
}

void ConfigManager::setSensorsConfigs(const std::vector<SensorConfig>& configs) {
    Preferences prefs;
    prefs.begin(NAMESPACE_SENSORS, false);
    StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
    JsonArray sensorArray = doc.to<JsonArray>();
    
    for (const auto& sensor : configs) {
        JsonObject sensorObj = sensorArray.createNestedObject();
        sensorObj[KEY_SENSOR] = sensor.configKey;
        sensorObj[KEY_SENSOR_ID] = sensor.sensorId;
        sensorObj[KEY_SENSOR_TYPE] = static_cast<int>(sensor.type);
        sensorObj[KEY_SENSOR_CHANNEL] = sensor.channel;
        sensorObj[KEY_SENSOR_ID_TEMPERATURE_SENSOR] = sensor.tempSensorId;
        sensorObj[KEY_SENSOR_ENABLE] = sensor.enable;
    }
    
    String jsonString;
    serializeJson(doc, jsonString);
    prefs.putString(NAMESPACE_SENSORS, jsonString.c_str());
    prefs.end();
}

/* =========================================================================
   CONFIGURACIÓN DE LORA
   ========================================================================= */
LoRaConfig ConfigManager::getLoRaConfig() {
    StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
    readNamespace(NAMESPACE_LORAWAN, doc);
    
    LoRaConfig config;
    config.joinEUI  = doc[KEY_LORA_JOIN_EUI] | DEFAULT_JOIN_EUI;
    config.devEUI   = doc[KEY_LORA_DEV_EUI]  | DEFAULT_DEV_EUI;
    config.nwkKey   = doc[KEY_LORA_NWK_KEY]  | DEFAULT_NWK_KEY;
    config.appKey   = doc[KEY_LORA_APP_KEY]  | DEFAULT_APP_KEY;
    
    return config;
}

void ConfigManager::setLoRaConfig(
    const String &joinEUI, 
    const String &devEUI, 
    const String &nwkKey, 
    const String &appKey) {
    StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
    readNamespace(NAMESPACE_LORAWAN, doc);
    
    doc[KEY_LORA_JOIN_EUI] = joinEUI;
    doc[KEY_LORA_DEV_EUI]  = devEUI;
    doc[KEY_LORA_NWK_KEY]  = nwkKey;
    doc[KEY_LORA_APP_KEY]  = appKey;
    
    writeNamespace(NAMESPACE_LORAWAN, doc);
}

/* =========================================================================
   CONFIGURACIÓN DE SENSORES MODBUS
   ========================================================================= */
#if defined(DEVICE_TYPE_MODBUS) || defined(DEVICE_TYPE_ANALOGIC)

void ConfigManager::setModbusSensorsConfigs(const std::vector<ModbusSensorConfig>& configs) {
    Preferences prefs;
    prefs.begin(NAMESPACE_SENSORS_MODBUS, false);
    StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
    JsonArray sensorArray = doc.to<JsonArray>();
    
    for (const auto& sensor : configs) {
        JsonObject sensorObj = sensorArray.createNestedObject();
        sensorObj[KEY_MODBUS_SENSOR_ID] = sensor.sensorId;
        sensorObj[KEY_MODBUS_SENSOR_TYPE] = static_cast<int>(sensor.type);
        sensorObj[KEY_MODBUS_SENSOR_ADDR] = sensor.address;
        sensorObj[KEY_MODBUS_SENSOR_ENABLE] = sensor.enable;
    }
    
    String jsonString;
    serializeJson(doc, jsonString);
    prefs.putString(NAMESPACE_SENSORS_MODBUS, jsonString.c_str());
    prefs.end();
}

std::vector<ModbusSensorConfig> ConfigManager::getAllModbusSensorConfigs() {
    StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
    readNamespace(NAMESPACE_SENSORS_MODBUS, doc);
    
    std::vector<ModbusSensorConfig> configs;
    
    if (doc.is<JsonArray>()) {
        JsonArray array = doc.as<JsonArray>();
        
        for (JsonObject sensorObj : array) {
            ModbusSensorConfig config;
            strlcpy(config.sensorId, sensorObj[KEY_MODBUS_SENSOR_ID] | "", sizeof(config.sensorId));
            config.type = static_cast<ModbusSensorType>(sensorObj[KEY_MODBUS_SENSOR_TYPE] | 0);
            config.address = sensorObj[KEY_MODBUS_SENSOR_ADDR] | 1;
            config.enable = sensorObj[KEY_MODBUS_SENSOR_ENABLE] | false;
            
            configs.push_back(config);
        }
    }
    
    return configs;
}

std::vector<ModbusSensorConfig> ConfigManager::getEnabledModbusSensorConfigs() {
    std::vector<ModbusSensorConfig> all = getAllModbusSensorConfigs();
    std::vector<ModbusSensorConfig> enabled;
    for (auto &m : all) {
        if (m.enable) enabled.push_back(m);
    }
    return enabled;
}

#endif // defined(DEVICE_TYPE_MODBUS) || defined(DEVICE_TYPE_ANALOGIC)

/* =========================================================================
   CONFIGURACIÓN DE SENSORES ANALÓGICOS (Solo para dispositivo analógico)
   ========================================================================= */
#ifdef DEVICE_TYPE_ANALOGIC

void ConfigManager::getNTC100KConfig(double& t1, double& r1, double& t2, double& r2, double& t3, double& r3) {
    StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
    readNamespace(NAMESPACE_NTC100K, doc);
    t1 = doc[KEY_NTC100K_T1] | DEFAULT_T1_100K;
    r1 = doc[KEY_NTC100K_R1] | DEFAULT_R1_100K;
    t2 = doc[KEY_NTC100K_T2] | DEFAULT_T2_100K;
    r2 = doc[KEY_NTC100K_R2] | DEFAULT_R2_100K;
    t3 = doc[KEY_NTC100K_T3] | DEFAULT_T3_100K;
    r3 = doc[KEY_NTC100K_R3] | DEFAULT_R3_100K;
}

void ConfigManager::setNTC100KConfig(double t1, double r1, double t2, double r2, double t3, double r3) {
    StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
    readNamespace(NAMESPACE_NTC100K, doc);
    doc[KEY_NTC100K_T1] = t1;
    doc[KEY_NTC100K_R1] = r1;
    doc[KEY_NTC100K_T2] = t2;
    doc[KEY_NTC100K_R2] = r2;
    doc[KEY_NTC100K_T3] = t3;
    doc[KEY_NTC100K_R3] = r3;
    writeNamespace(NAMESPACE_NTC100K, doc);
}

void ConfigManager::getNTC10KConfig(double& t1, double& r1, double& t2, double& r2, double& t3, double& r3) {
    StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
    readNamespace(NAMESPACE_NTC10K, doc);
    t1 = doc[KEY_NTC10K_T1] | DEFAULT_T1_10K;
    r1 = doc[KEY_NTC10K_R1] | DEFAULT_R1_10K;
    t2 = doc[KEY_NTC10K_T2] | DEFAULT_T2_10K;
    r2 = doc[KEY_NTC10K_R2] | DEFAULT_R2_10K;
    t3 = doc[KEY_NTC10K_T3] | DEFAULT_T3_10K;
    r3 = doc[KEY_NTC10K_R3] | DEFAULT_R3_10K;
}

void ConfigManager::setNTC10KConfig(double t1, double r1, double t2, double r2, double t3, double r3) {
    StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
    readNamespace(NAMESPACE_NTC10K, doc);
    doc[KEY_NTC10K_T1] = t1;
    doc[KEY_NTC10K_R1] = r1;
    doc[KEY_NTC10K_T2] = t2;
    doc[KEY_NTC10K_R2] = r2;
    doc[KEY_NTC10K_T3] = t3;
    doc[KEY_NTC10K_R3] = r3;
    writeNamespace(NAMESPACE_NTC10K, doc);
}

void ConfigManager::getConductivityConfig(float& calTemp, float& coefComp, 
                                           float& v1, float& t1, float& v2, float& t2, float& v3, float& t3) {
    StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
    readNamespace(NAMESPACE_COND, doc);
    calTemp = doc[KEY_CONDUCT_CT] | CONDUCTIVITY_DEFAULT_TEMP;
    coefComp = doc[KEY_CONDUCT_CC] | TEMP_COEF_COMPENSATION;
    v1 = doc[KEY_CONDUCT_V1] | CONDUCTIVITY_DEFAULT_V1;
    t1 = doc[KEY_CONDUCT_T1] | CONDUCTIVITY_DEFAULT_T1;
    v2 = doc[KEY_CONDUCT_V2] | CONDUCTIVITY_DEFAULT_V2;
    t2 = doc[KEY_CONDUCT_T2] | CONDUCTIVITY_DEFAULT_T2;
    v3 = doc[KEY_CONDUCT_V3] | CONDUCTIVITY_DEFAULT_V3;
    t3 = doc[KEY_CONDUCT_T3] | CONDUCTIVITY_DEFAULT_T3;
}

void ConfigManager::setConductivityConfig(float calTemp, float coefComp,
                                           float v1, float t1, float v2, float t2, float v3, float t3) {
    StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
    readNamespace(NAMESPACE_COND, doc);
    doc[KEY_CONDUCT_CT] = calTemp;
    doc[KEY_CONDUCT_CC] = coefComp;
    doc[KEY_CONDUCT_V1] = v1;
    doc[KEY_CONDUCT_T1] = t1;
    doc[KEY_CONDUCT_V2] = v2;
    doc[KEY_CONDUCT_T2] = t2;
    doc[KEY_CONDUCT_V3] = v3;
    doc[KEY_CONDUCT_T3] = t3;
    writeNamespace(NAMESPACE_COND, doc);
}

void ConfigManager::getPHConfig(float& v1, float& t1, float& v2, float& t2, float& v3, float& t3, float& defaultTemp) {
    StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
    readNamespace(NAMESPACE_PH, doc);
    v1 = doc[KEY_PH_V1] | PH_DEFAULT_V1;
    t1 = doc[KEY_PH_T1] | PH_DEFAULT_T1;
    v2 = doc[KEY_PH_V2] | PH_DEFAULT_V2;
    t2 = doc[KEY_PH_T2] | PH_DEFAULT_T2;
    v3 = doc[KEY_PH_V3] | PH_DEFAULT_V3;
    t3 = doc[KEY_PH_T3] | PH_DEFAULT_T3;
    defaultTemp = doc[KEY_PH_CT] | PH_DEFAULT_TEMP;
}

void ConfigManager::setPHConfig(float v1, float t1, float v2, float t2, float v3, float t3, float defaultTemp) {
    StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
    readNamespace(NAMESPACE_PH, doc);
    doc[KEY_PH_V1] = v1;
    doc[KEY_PH_T1] = t1;
    doc[KEY_PH_V2] = v2;
    doc[KEY_PH_T2] = t2;
    doc[KEY_PH_V3] = v3;
    doc[KEY_PH_T3] = t3;
    doc[KEY_PH_CT] = defaultTemp;
    writeNamespace(NAMESPACE_PH, doc);
}
#endif

================
File: src/HardwareManager.cpp
================
/*******************************************************************************************
 * Archivo: src/HardwareManager.cpp
 * Descripción: Implementación de la gestión de hardware del sistema.
 *******************************************************************************************/

#include "HardwareManager.h"
#include "debug.h"

bool HardwareManager::initHardware(PCA9555& ioExpander, PowerManager& powerManager, SensirionI2cSht3x& sht30Sensor) {
    // Inicializar I2C con pines definidos
    Wire.begin(I2C_SDA_PIN, I2C_SCL_PIN);

    // Inicializar SHT30 para reset
    sht30Sensor.begin(Wire, SHT30_I2C_ADDR_44);
    sht30Sensor.stopMeasurement();
    delay(1);
    sht30Sensor.softReset();
    delay(100);
    
    // Inicializar PCA9555 para expansión de I/O
    if (!ioExpander.begin()) {
        DEBUG_PRINTLN("Error al inicializar PCA9555");
        return false;
    }
    
    // Inicializar PowerManager para control de energía
    if (!powerManager.begin()) {
        DEBUG_PRINTLN("Error al inicializar PowerManager");
        return false;
    }
    
    return true;
}

void HardwareManager::initSPI(SPIClass& spi) {
    // Inicializar SPI para comunicación con periféricos
    spi.begin();
}

void HardwareManager::prepareHardwareForSleep(PCA9555& ioExpander) {
    // Apagar buses y periféricos
    Wire.end();
    
    // Poner el PCA9555 en modo sleep
    ioExpander.sleep();
}

================
File: src/LoRaManager.cpp
================
/*******************************************************************************************
 * Archivo: src/LoRaManager.cpp
 * Descripción: Implementación de la gestión de comunicaciones LoRa y LoRaWAN.
 *******************************************************************************************/

#include "LoRaManager.h"
#include <Preferences.h>
#include "debug.h"

// Inicialización de variables estáticas
LoRaWANNode* LoRaManager::node = nullptr;
SX1262* LoRaManager::radioModule = nullptr;

// Referencias externas
extern RTC_DATA_ATTR uint8_t LWsession[RADIOLIB_LORAWAN_SESSION_BUF_SIZE];
extern RTC_DATA_ATTR uint16_t bootCountSinceUnsuccessfulJoin;
extern RTCManager rtcManager;

int16_t LoRaManager::begin(SX1262* radio, const LoRaWANBand_t* region, uint8_t subBand) {
    radioModule = radio;
    int16_t state = radioModule->begin();
    if (state != RADIOLIB_ERR_NONE) {
        DEBUG_PRINTF("Error iniciando radio: %d\n", state);
        return state;
    }
    
    // Crear el nodo LoRaWAN
    node = new LoRaWANNode(radio, region, subBand);
    return RADIOLIB_ERR_NONE;
}

int16_t LoRaManager::lwActivate(LoRaWANNode& node) {
    int16_t state = RADIOLIB_ERR_UNKNOWN;
    Preferences store;
    
    // Obtener configuración LoRa
    LoRaConfig loraConfig = ConfigManager::getLoRaConfig();
    
    // Convertir strings de EUIs a uint64_t
    uint64_t joinEUI = 0, devEUI = 0;
    if (!parseEUIString(loraConfig.joinEUI.c_str(), &joinEUI) ||
        !parseEUIString(loraConfig.devEUI.c_str(), &devEUI)) {
        DEBUG_PRINTLN("Error al parsear EUIs");
        return state;
    }
    
    // Parsear las claves
    uint8_t nwkKey[16], appKey[16];
    parseKeyString(loraConfig.nwkKey, nwkKey, 16);
    parseKeyString(loraConfig.appKey, appKey, 16);

    // Configurar la sesión OTAA
    node.beginOTAA(joinEUI, devEUI, nwkKey, appKey);

    DEBUG_PRINTLN("Recuperando nonces y sesión LoRaWAN");
    store.begin("radiolib");

    // Intentar restaurar nonces si existen
    if (store.isKey("nonces")) {
        uint8_t buffer[RADIOLIB_LORAWAN_NONCES_BUF_SIZE];
        store.getBytes("nonces", buffer, RADIOLIB_LORAWAN_NONCES_BUF_SIZE);
        state = node.setBufferNonces(buffer);
        
        if (state == RADIOLIB_ERR_NONE) {
            // Intentar restaurar sesión desde RTC
            state = node.setBufferSession(LWsession);
            
            if (state == RADIOLIB_ERR_NONE) {
                DEBUG_PRINTLN("Sesión restaurada exitosamente - activando");
                state = node.activateOTAA();
                
                if (state == RADIOLIB_LORAWAN_SESSION_RESTORED) {
                    store.end();
                    return state;
                }
            }
        }
    } else {
        DEBUG_PRINTLN("No hay nonces guardados - iniciando nuevo join");
    }

    // Si llegamos aquí, necesitamos hacer un nuevo join
    state = RADIOLIB_ERR_NETWORK_NOT_JOINED;
    while (state != RADIOLIB_LORAWAN_NEW_SESSION) {
        DEBUG_PRINTLN("Iniciando join a la red LoRaWAN");
        state = node.activateOTAA();

        // Guardar nonces en flash si el join fue exitoso
        if (state == RADIOLIB_LORAWAN_NEW_SESSION) {
            DEBUG_PRINTLN("Join exitoso - Guardando nonces en flash");
            uint8_t buffer[RADIOLIB_LORAWAN_NONCES_BUF_SIZE];
            uint8_t *persist = node.getBufferNonces();
            memcpy(buffer, persist, RADIOLIB_LORAWAN_NONCES_BUF_SIZE);
            store.putBytes("nonces", buffer, RADIOLIB_LORAWAN_NONCES_BUF_SIZE);

            // Solicitar DeviceTime después de un join exitoso
            delay(1000); // Pequeña pausa para estabilización
            node.setDatarate(3);
            
            // Intentar obtener DeviceTime
            DEBUG_PRINTLN("Solicitando DeviceTime...");
            bool macCommandSuccess = node.sendMacCommandReq(RADIOLIB_LORAWAN_MAC_DEVICE_TIME);
            if (macCommandSuccess) {
                // Enviar mensaje vacío para recibir el DeviceTime
                uint8_t fPort = 1;
                uint8_t downlinkPayload[255];
                size_t downlinkSize = 0;
                
                int16_t rxState = node.sendReceive(nullptr, 0, fPort, downlinkPayload, &downlinkSize, true);
                if (rxState == RADIOLIB_ERR_NONE) {
                    // Obtener y procesar DeviceTime
                    uint32_t unixEpoch;
                    uint8_t fraction;
                    int16_t dtState = node.getMacDeviceTimeAns(&unixEpoch, &fraction, true);
                    if (dtState == RADIOLIB_ERR_NONE) {
                        DEBUG_PRINTF("DeviceTime recibido: epoch = %lu s, fraction = %u\n", unixEpoch, fraction);
                        rtcManager.setTimeFromServer(unixEpoch, fraction);
                    } else {
                        DEBUG_PRINTF("Error al obtener DeviceTime: %d\n", dtState);
                    }
                } else {
                    DEBUG_PRINTF("Error al recibir respuesta: %d\n", rxState);
                }
            } else {
                DEBUG_PRINTLN("Error al solicitar DeviceTime: comando no pudo ser encolado");
            }
            
            bootCountSinceUnsuccessfulJoin = 0;
            store.end();
            return RADIOLIB_LORAWAN_NEW_SESSION;
        } else {
            DEBUG_PRINTF("Join falló: %d\n", state);
            bootCountSinceUnsuccessfulJoin++;
            store.end();
            return state;
        }
    }

    store.end();
    return state;
}

/**
 * @brief Envía el payload de sensores fragmentado. 
 *        Se agregó soporte para subvalores en un solo sensor (por ej. SHT30 con T, H).
 */
void LoRaManager::sendFragmentedPayload(const std::vector<SensorReading>& readings, 
                                        LoRaWANNode& node,
                                        const String& deviceId, 
                                        const String& stationId, 
                                        RTCManager& rtcManager) {
    const int MAX_PAYLOAD = 200; // Control de tamaño
    size_t sensorIndex = 0;
    int fragmentNumber = 0;
    
    while (sensorIndex < readings.size()) {
        // Crear un nuevo payload con cabecera
        StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> payload;
        
        // Configurar precisión a 3 decimales para todos los valores flotantes
        payload.clear();
        payload["st"] = stationId;
        payload["d"] = deviceId;
        payload["vt"] = roundTo3Decimals(SensorManager::readBatteryVoltageADC());
        payload["ts"] = rtcManager.getEpochTime();
        JsonArray sensorArray = payload.createNestedArray("s");
        
        String fragmentStr;

        // Agregar lecturas de sensores mientras no se exceda el tamaño
        while (sensorIndex < readings.size()) {
            JsonObject sensorObj = sensorArray.createNestedObject();
            sensorObj["id"] = readings[sensorIndex].sensorId;
            sensorObj["t"]  = readings[sensorIndex].type;

            // --- Soporte para subvalores:
            if (!readings[sensorIndex].subValues.empty()) {
                // Si hay subvalores (ej. SHT30 -> T, H)
                JsonObject multiVals = sensorObj.createNestedObject("v");
                for (auto &sv : readings[sensorIndex].subValues) {
                    multiVals[sv.key] = roundTo3Decimals(sv.value);
                }
            } else {
                // Sensor con un solo valor
                sensorObj["v"] = roundTo3Decimals(readings[sensorIndex].value);
            }

            // Serializar para verificar si excede
            fragmentStr.clear();
            serializeJson(payload, fragmentStr);
            if (fragmentStr.length() > MAX_PAYLOAD) {
                // Retirar la última lectura si excede
                sensorArray.remove(sensorArray.size() - 1);
                break;
            }
            sensorIndex++;
        }
        
        // Serializar el payload final para este fragmento
        fragmentStr.clear();
        serializeJson(payload, fragmentStr);
        DEBUG_PRINTF("Enviando fragmento %d con tamaño %d bytes\n", fragmentNumber, fragmentStr.length());
        DEBUG_PRINTLN(fragmentStr);
        
        uint8_t payloadBytes[MAX_PAYLOAD];
        size_t payloadLength = fragmentStr.length();
        memcpy(payloadBytes, fragmentStr.c_str(), payloadLength);
        
        // Enviar el fragmento
        uint8_t fPort = 1;
        int16_t state = node.sendReceive(payloadBytes, payloadLength, fPort);
        if (state == RADIOLIB_ERR_NONE) {
            DEBUG_PRINTLN("Fragmento enviado correctamente");
        } else {
            DEBUG_PRINTF("Error al enviar fragmento: %d\n", state);
        }
        
        fragmentNumber++;
        // Dormir brevemente entre fragmentos
        delay(500);
    }
}

/**
 * @brief Versión expandida de sendFragmentedPayload que soporta tanto sensores normales como Modbus.
 *        Envía las lecturas en fragmentos, agregando primero las normales y luego las Modbus.
 */
void LoRaManager::sendFragmentedPayload(const std::vector<SensorReading>& normalReadings, 
                                       const std::vector<ModbusSensorReading>& modbusReadings,
                                       LoRaWANNode& node,
                                       const String& deviceId, 
                                       const String& stationId, 
                                       RTCManager& rtcManager) {
    const int MAX_PAYLOAD = 200; // Control de tamaño
    size_t normalIndex = 0;
    size_t modbusIndex = 0;
    int fragmentNumber = 0;
    bool processedAllNormal = false;
    bool processedAllModbus = false;
    
    // Procesar mientras haya datos por enviar
    while (!processedAllNormal || !processedAllModbus) {
        // Crear un nuevo payload con cabecera
        StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> payload;
        payload.clear();
        payload["st"] = stationId;
        payload["d"] = deviceId;
        payload["vt"] = roundTo3Decimals(SensorManager::readBatteryVoltageADC());
        payload["ts"] = rtcManager.getEpochTime();
        JsonArray sensorArray = payload.createNestedArray("s");
        
        String fragmentStr;

        // Primero agregamos lecturas de sensores normales
        while (!processedAllNormal && normalIndex < normalReadings.size()) {
            JsonObject sensorObj = sensorArray.createNestedObject();
            sensorObj["id"] = normalReadings[normalIndex].sensorId;
            sensorObj["t"]  = normalReadings[normalIndex].type;

            // --- Soporte para subvalores:
            if (!normalReadings[normalIndex].subValues.empty()) {
                // Si hay subvalores (ej. SHT30 -> T, H)
                JsonObject multiVals = sensorObj.createNestedObject("v");
                for (auto &sv : normalReadings[normalIndex].subValues) {
                    multiVals[sv.key] = roundTo3Decimals(sv.value);
                }
            } else {
                // Sensor con un solo valor
                sensorObj["v"] = roundTo3Decimals(normalReadings[normalIndex].value);
            }

            // Serializar para verificar si excede
            fragmentStr.clear();
            serializeJson(payload, fragmentStr);
            if (fragmentStr.length() > MAX_PAYLOAD) {
                // Retirar la última lectura si excede
                sensorArray.remove(sensorArray.size() - 1);
                break;
            }
            normalIndex++;
            if (normalIndex >= normalReadings.size()) {
                processedAllNormal = true;
            }
        }
        
        // Luego agregamos lecturas de sensores Modbus si hay espacio
        if (!processedAllModbus && modbusIndex < modbusReadings.size()) {
            while (modbusIndex < modbusReadings.size()) {
                JsonObject sensorObj = sensorArray.createNestedObject();
                sensorObj["id"] = modbusReadings[modbusIndex].sensorId;
                sensorObj["t"]  = modbusReadings[modbusIndex].type + 100; // Offset para distinguir tipos Modbus
                
                // Los sensores Modbus siempre tienen subvalores
                JsonObject multiVals = sensorObj.createNestedObject("v");
                for (auto &sv : modbusReadings[modbusIndex].subValues) {
                    multiVals[sv.key] = roundTo3Decimals(sv.value);
                }

                // Serializar para verificar si excede
                fragmentStr.clear();
                serializeJson(payload, fragmentStr);
                if (fragmentStr.length() > MAX_PAYLOAD) {
                    // Retirar la última lectura si excede
                    sensorArray.remove(sensorArray.size() - 1);
                    break;
                }
                modbusIndex++;
                if (modbusIndex >= modbusReadings.size()) {
                    processedAllModbus = true;
                    break;
                }
            }
        }
        
        // Serializar el payload final para este fragmento
        fragmentStr.clear();
        serializeJson(payload, fragmentStr);
        DEBUG_PRINTF("Enviando fragmento %d con tamaño %d bytes\n", fragmentNumber, fragmentStr.length());
        DEBUG_PRINTLN(fragmentStr);
        
        uint8_t payloadBytes[MAX_PAYLOAD];
        size_t payloadLength = fragmentStr.length();
        memcpy(payloadBytes, fragmentStr.c_str(), payloadLength);
        
        // Enviar el fragmento
        uint8_t fPort = 1;
        int16_t state = node.sendReceive(payloadBytes, payloadLength, fPort);
        if (state == RADIOLIB_ERR_NONE) {
            DEBUG_PRINTLN("Fragmento enviado correctamente");
        } else {
            DEBUG_PRINTF("Error al enviar fragmento: %d\n", state);
        }
        
        fragmentNumber++;
        // Dormir brevemente entre fragmentos
        delay(500);
    }
}

void LoRaManager::prepareForSleep(SX1262* radio) {
    if (radio) {
        radio->sleep(true);
    }
}

void LoRaManager::setDatarate(LoRaWANNode& node, uint8_t datarate) {
    node.setDatarate(datarate);
}

================
File: src/main.cpp
================
#include <Arduino.h>
#include <Wire.h>
#include <SPI.h>
#include <Preferences.h>
#if defined(DEVICE_TYPE_BASIC) || defined(DEVICE_TYPE_ANALOGIC)
#include <OneWire.h>
#include <DallasTemperature.h>
#endif
#include <vector>
#include <ArduinoJson.h>
#include <cmath>

#include "config.h"
#include "debug.h"
#include "PowerManager.h"
#include "MAX31865.h"
#include <RadioLib.h>
#include "RTCManager.h"
#include "sensor_types.h"
#include "SensorManager.h"
#include "nvs_flash.h"
#include "esp_sleep.h"
#include <BLEDevice.h>
#include <BLEServer.h>
#include <BLEAdvertising.h>
#include "config_manager.h"
#include "utilities.h"
#include <SensirionI2cSht3x.h>
#include "LoRaManager.h"
#include "BLE.h"

#include "HardwareManager.h"
#include "SleepManager.h"

//--------------------------------------------------------------------------------------------
// Variables globales
//--------------------------------------------------------------------------------------------
const LoRaWANBand_t Region = LORA_REGION;
const uint8_t subBand = LORA_SUBBAND;

Preferences preferences;
uint32_t timeToSleep;
String deviceId;
String stationId;
bool systemInitialized;

RTCManager rtcManager;
PCA9555 ioExpander(I2C_ADDRESS_PCA9555, I2C_SDA_PIN, I2C_SCL_PIN);
PowerManager powerManager(ioExpander);

SPIClass spi(FSPI);
#ifdef DEVICE_TYPE_ANALOGIC
SPISettings spiAdcSettings(SPI_ADC_CLOCK, MSBFIRST, SPI_MODE1);
#endif
SPISettings spiRtdSettings(SPI_RTD_CLOCK, MSBFIRST, SPI_MODE1);
SPISettings spiRadioSettings(SPI_RADIO_CLOCK, MSBFIRST, SPI_MODE0);

MAX31865_RTD rtd(MAX31865_RTD::RTD_PT100, spi, spiRtdSettings, ioExpander, PT100_CS_PIN);
SensirionI2cSht3x sht30Sensor;

SX1262 radio = new Module(LORA_NSS_PIN, LORA_DIO1_PIN, LORA_RST_PIN, LORA_BUSY_PIN, spi, spiRadioSettings);
LoRaWANNode node(&radio, &Region, subBand);

#if defined(DEVICE_TYPE_BASIC) || defined(DEVICE_TYPE_ANALOGIC)
OneWire oneWire(ONE_WIRE_BUS);
DallasTemperature dallasTemp(&oneWire);
#endif

RTC_DATA_ATTR uint16_t bootCount = 0;
RTC_DATA_ATTR uint16_t bootCountSinceUnsuccessfulJoin = 0;
RTC_DATA_ATTR uint8_t LWsession[RADIOLIB_LORAWAN_SESSION_BUF_SIZE];
Preferences store;

//--------------------------------------------------------------------------------------------
// setup()
//--------------------------------------------------------------------------------------------
void setup() {
    DEBUG_BEGIN(SERIAL_BAUD_RATE);

    
    SleepManager::releaseHeldPins();
    pinMode(CONFIG_PIN, INPUT);

    // Inicialización del NVS y de hardware I2C/IO
    // preferences.clear();
    // nvs_flash_erase();
    // nvs_flash_init();

    // Inicialización de configuración
    if (!ConfigManager::checkInitialized()) {
        DEBUG_PRINTLN("Primera ejecución detectada. Inicializando configuración...");
        ConfigManager::initializeDefaultConfig();
    }
    ConfigManager::getSystemConfig(systemInitialized, timeToSleep, deviceId, stationId);

    // Inicialización de hardware
    if (!HardwareManager::initHardware(ioExpander, powerManager, sht30Sensor)) {
        DEBUG_PRINTLN("Error en la inicialización del hardware");
    }

    // Modo configuración BLE
    if (BLEHandler::checkConfigMode(ioExpander)) {
        return;
    }

    // Inicializar RTC
    if (!rtcManager.begin()) {
        DEBUG_PRINTLN("No se pudo encontrar RTC");
    }

    // Encender 3.3V
    powerManager.power3V3On();

    // Inicializar sensores
    SensorManager::beginSensors();
    
    // Inicializar radio LoRa
    int16_t state = radio.begin();
    if (state != RADIOLIB_ERR_NONE) {
        DEBUG_PRINTF("Error iniciando radio: %d\n", state);
    }

    // Activar LoRaWAN
    state = LoRaManager::lwActivate(node);
    if (state != RADIOLIB_LORAWAN_NEW_SESSION && state != RADIOLIB_LORAWAN_SESSION_RESTORED) {
        DEBUG_PRINTF("Error activando LoRaWAN: %d\n", state);
        SleepManager::goToDeepSleep(timeToSleep, powerManager, ioExpander, &radio, node, LWsession, spi);
        return;
    }

    // Ajustar datarate
    LoRaManager::setDatarate(node, 3);

    ioExpander.pinMode(CONFIG_LED_PIN, OUTPUT);
}

//--------------------------------------------------------------------------------------------
// loop()
//--------------------------------------------------------------------------------------------
void loop() {
    // Verificar si se mantiene presionado para modo config
    if (BLEHandler::checkConfigMode(ioExpander)) {
        return;
    }

    // Obtener todas las lecturas de sensores (normales y Modbus)
    std::vector<SensorReading> normalReadings;
    std::vector<ModbusSensorReading> modbusReadings;

    SensorManager::getAllSensorReadings(normalReadings, modbusReadings);

    LoRaManager::sendFragmentedPayload(normalReadings, modbusReadings, node, deviceId, stationId, rtcManager);

    // Dormir
    SleepManager::goToDeepSleep(timeToSleep, powerManager, ioExpander, &radio, node, LWsession, spi);
}

================
File: src/MAX31865.cpp
================
#include "MAX31865.h"
#include <math.h>   // Para sqrt

/**
 * @brief Constructor con PCA9555.
 */
MAX31865_RTD::MAX31865_RTD(
    ptd_type type,
    SPIClass& spi,
    SPISettings& spiSettings,
    PCA9555& pca,
    uint8_t pcaPinCS
)
{
  _spi = &spi;
  _spiSettings = &spiSettings;
  this->type = type;
  this->_usePCA = true;
  this->_pca = &pca;
  this->_pcaPinCS = pcaPinCS;
  this->_csPinMCU = 0xFF;
}

/**
 * @brief Constructor con pin nativo de MCU.
 */
MAX31865_RTD::MAX31865_RTD(
    ptd_type type,
    SPIClass& spi,
    SPISettings& spiSettings,
    uint8_t csPin
)
{
  _spi = &spi;
  _spiSettings = &spiSettings;
  this->type = type;
  this->_usePCA = false;
  this->_pca = nullptr;
  this->_pcaPinCS = 0xFF;
  this->_csPinMCU = csPin;
}

// -----------------------------------------------------------------------
void MAX31865_RTD::configure(bool v_bias, bool conversion_mode, bool one_shot,
                             bool three_wire, uint8_t fault_cycle, bool fault_clear,
                             bool filter_50hz,
                             uint16_t low_threshold,
                             uint16_t high_threshold)
{
  uint8_t control_bits = 0;
  // Arma la máscara
  control_bits |= (v_bias ? 0x80 : 0);
  control_bits |= (conversion_mode ? 0x40 : 0);
  control_bits |= (one_shot ? 0x20 : 0);
  control_bits |= (three_wire ? 0x10 : 0);
  control_bits |= (fault_cycle & 0b00001100);
  control_bits |= (fault_clear ? 0x02 : 0);
  control_bits |= (filter_50hz ? 0x01 : 0);

  this->configuration_control_bits   = control_bits;
  this->configuration_low_threshold  = low_threshold;
  this->configuration_high_threshold = high_threshold;

  // Llama a reconfigure() para escribir valores
  reconfigure();
}

// -----------------------------------------------------------------------
void MAX31865_RTD::reconfigure()
{
  // Inicia transacción SPI
  _spi->beginTransaction(*_spiSettings);

  // Escribe config
  setCSLow();
  _spi->transfer(0x80); // Dirección de escritura del registro config
  _spi->transfer(this->configuration_control_bits);
  setCSHigh();

  // Umbrales
  setCSLow();
  _spi->transfer(0x83); // Registro de umbrales
  _spi->transfer( (this->configuration_high_threshold >> 8) & 0xFF );
  _spi->transfer(  this->configuration_high_threshold       & 0xFF );
  _spi->transfer( (this->configuration_low_threshold  >> 8) & 0xFF );
  _spi->transfer(  this->configuration_low_threshold        & 0xFF );
  setCSHigh();

  // Cierra transacción
  _spi->endTransaction();
}

// -----------------------------------------------------------------------
uint8_t MAX31865_RTD::read_all()
{
  uint16_t combined_bytes = 0;

  _spi->beginTransaction(*_spiSettings);

  setCSLow();
  // Indica que leeremos desde la dirección 0 (se manda 0x00)
  _spi->transfer(0x00);

  // Orden de lectura: Config, RTD, High Fault Th, Low Fault Th, Status
  measured_configuration = _spi->transfer(0x00);

  combined_bytes  = ((uint16_t)_spi->transfer(0x00) << 8);
  combined_bytes |=          _spi->transfer(0x00);
  measured_resistance = (combined_bytes >> 1);

  combined_bytes  = ((uint16_t)_spi->transfer(0x00) << 8);
  combined_bytes |=          _spi->transfer(0x00);
  measured_high_threshold = (combined_bytes >> 1);

  combined_bytes  = ((uint16_t)_spi->transfer(0x00) << 8);
  combined_bytes |=          _spi->transfer(0x00);
  measured_low_threshold = (combined_bytes >> 1);

  measured_status = _spi->transfer(0x00);

  delayMicroseconds(20);
  setCSHigh();
  _spi->endTransaction();

  // Reconfigura si resistencia=0 o hay falla
  if ((measured_resistance == 0) || (measured_status != 0)) {
    reconfigure();
  }
  return measured_status;
}

// -----------------------------------------------------------------------
double MAX31865_RTD::temperature() const
{
  // Si hay error o resistencia inválida, retornar NAN
  if (measured_status != 0 || measured_resistance == 0) {
    return NAN;
  }

  // Callendar-Van Dusen
  static const double a2 = 2.0 * RTD_B;
  static const double b_sq = (RTD_A * RTD_A);
  double rtd_resistance = (type == RTD_PT100) ? RTD_RESISTANCE_PT100 : RTD_RESISTANCE_PT1000;

  double c = 1.0 - (resistance() / rtd_resistance);
  double D = b_sq - 2.0 * a2 * c;
  
  // Verificar si la ecuación cuadrática tiene solución real
  if (D < 0) {
    return NAN;
  }
  
  double tempC = (-RTD_A + sqrt(D)) / a2;

  return tempC;
}

void MAX31865_RTD::setCSLow() {
  if (_usePCA && _pca) {
    _pca->digitalWrite(_pcaPinCS, LOW);
    delayMicroseconds(5);
  } else {
    digitalWrite(_csPinMCU, LOW);
  }
}

void MAX31865_RTD::setCSHigh() {
  if (_usePCA && _pca) {
    _pca->digitalWrite(_pcaPinCS, HIGH);
  } else {
    digitalWrite(_csPinMCU, HIGH);
  }
}

double MAX31865_RTD::singleMeasurement(uint16_t conversionDelayMs) {
    // Activar BIAS
    uint8_t originalConfig = configuration_control_bits;
    configuration_control_bits |= 0x80;  // Set VBIAS on
    reconfigure();
    
    delay(10);  // Esperar a que VBIAS se estabilice
    
    // Iniciar conversión única
    configuration_control_bits |= 0x20;  // Set one-shot bit
    reconfigure();
    
    // Esperar a que la conversión termine
    delay(conversionDelayMs);
    
    // Leer resultado
    read_all();
    
    // Desactivar BIAS y one-shot
    configuration_control_bits = originalConfig;
    reconfigure();
    
    return temperature();
}

// Nuevo método begin para inicializar los pines
bool MAX31865_RTD::begin() {
    if (_usePCA && _pca) {
        _pca->pinMode(_pcaPinCS, OUTPUT);
        _pca->digitalWrite(_pcaPinCS, HIGH);
    } else {
        pinMode(_csPinMCU, OUTPUT);
        digitalWrite(_csPinMCU, HIGH);
    }
    return true;
}

================
File: src/ModbusMaster.cpp
================
/**
@file
Arduino library for communicating with Modbus slaves over RS232/485 (via RTU protocol).
*/
/*

  ModbusMaster.cpp - Arduino library for communicating with Modbus slaves
  over RS232/485 (via RTU protocol).

  Library:: ModbusMaster

  Copyright:: 2009-2016 Doc Walker

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

*/


/* _____PROJECT INCLUDES_____________________________________________________ */
#include "ModbusMaster.h"


/* _____GLOBAL VARIABLES_____________________________________________________ */


/* _____PUBLIC FUNCTIONS_____________________________________________________ */
/**
Constructor.

Creates class object; initialize it using ModbusMaster::begin().

@ingroup setup
*/
ModbusMaster::ModbusMaster(void)
{
  _idle = 0;
  _preTransmission = 0;
  _postTransmission = 0;
}

/**
Initialize class object.

Assigns the Modbus slave ID and serial port.
Call once class has been instantiated, typically within setup().

@param slave Modbus slave ID (1..255)
@param &serial reference to serial port object (Serial, Serial1, ... Serial3)
@ingroup setup
*/
void ModbusMaster::begin(uint8_t slave, Stream &serial)
{
//  txBuffer = (uint16_t*) calloc(ku8MaxBufferSize, sizeof(uint16_t));
  _u8MBSlave = slave;
  _serial = &serial;
  _u8TransmitBufferIndex = 0;
  u16TransmitBufferLength = 0;
  
#if __MODBUSMASTER_DEBUG__
  pinMode(__MODBUSMASTER_DEBUG_PIN_A__, OUTPUT);
  pinMode(__MODBUSMASTER_DEBUG_PIN_B__, OUTPUT);
#endif
}


void ModbusMaster::beginTransmission(uint16_t u16Address)
{
  _u16WriteAddress = u16Address;
  _u8TransmitBufferIndex = 0;
  u16TransmitBufferLength = 0;
}

// eliminate this function in favor of using existing MB request functions
uint8_t ModbusMaster::requestFrom(uint16_t address, uint16_t quantity)
{
  uint8_t read;
  // clamp to buffer length
  if (quantity > ku8MaxBufferSize)
  {
    quantity = ku8MaxBufferSize;
  }
  // set rx buffer iterator vars
  _u8ResponseBufferIndex = 0;
  _u8ResponseBufferLength = read;

  return read;
}


void ModbusMaster::sendBit(bool data)
{
  uint8_t txBitIndex = u16TransmitBufferLength % 16;
  if ((u16TransmitBufferLength >> 4) < ku8MaxBufferSize)
  {
    if (0 == txBitIndex)
    {
      _u16TransmitBuffer[_u8TransmitBufferIndex] = 0;
    }
    bitWrite(_u16TransmitBuffer[_u8TransmitBufferIndex], txBitIndex, data);
    u16TransmitBufferLength++;
    _u8TransmitBufferIndex = u16TransmitBufferLength >> 4;
  }
}


void ModbusMaster::send(uint16_t data)
{
  if (_u8TransmitBufferIndex < ku8MaxBufferSize)
  {
    _u16TransmitBuffer[_u8TransmitBufferIndex++] = data;
    u16TransmitBufferLength = _u8TransmitBufferIndex << 4;
  }
}


void ModbusMaster::send(uint32_t data)
{
  send(lowWord(data));
  send(highWord(data));
}


void ModbusMaster::send(uint8_t data)
{
  send(word(data));
}









uint8_t ModbusMaster::available(void)
{
  return _u8ResponseBufferLength - _u8ResponseBufferIndex;
}


uint16_t ModbusMaster::receive(void)
{
  if (_u8ResponseBufferIndex < _u8ResponseBufferLength)
  {
    return _u16ResponseBuffer[_u8ResponseBufferIndex++];
  }
  else
  {
    return 0xFFFF;
  }
}








/**
Set idle time callback function (cooperative multitasking).

This function gets called in the idle time between transmission of data
and response from slave. Do not call functions that read from the serial
buffer that is used by ModbusMaster. Use of i2c/TWI, 1-Wire, other
serial ports, etc. is permitted within callback function.

@see ModbusMaster::ModbusMasterTransaction()
*/
void ModbusMaster::idle(void (*idle)())
{
  _idle = idle;
}

/**
Set pre-transmission callback function.

This function gets called just before a Modbus message is sent over serial.
Typical usage of this callback is to enable an RS485 transceiver's
Driver Enable pin, and optionally disable its Receiver Enable pin.

@see ModbusMaster::ModbusMasterTransaction()
@see ModbusMaster::postTransmission()
*/
void ModbusMaster::preTransmission(void (*preTransmission)())
{
  _preTransmission = preTransmission;
}

/**
Set post-transmission callback function.

This function gets called after a Modbus message has finished sending
(i.e. after all data has been physically transmitted onto the serial
bus).

Typical usage of this callback is to enable an RS485 transceiver's
Receiver Enable pin, and disable its Driver Enable pin.

@see ModbusMaster::ModbusMasterTransaction()
@see ModbusMaster::preTransmission()
*/
void ModbusMaster::postTransmission(void (*postTransmission)())
{
  _postTransmission = postTransmission;
}


/**
Retrieve data from response buffer.

@see ModbusMaster::clearResponseBuffer()
@param u8Index index of response buffer array (0x00..0x3F)
@return value in position u8Index of response buffer (0x0000..0xFFFF)
@ingroup buffer
*/
uint16_t ModbusMaster::getResponseBuffer(uint8_t u8Index)
{
  if (u8Index < ku8MaxBufferSize)
  {
    return _u16ResponseBuffer[u8Index];
  }
  else
  {
    return 0xFFFF;
  }
}


/**
Clear Modbus response buffer.

@see ModbusMaster::getResponseBuffer(uint8_t u8Index)
@ingroup buffer
*/
void ModbusMaster::clearResponseBuffer()
{
  uint8_t i;
  
  for (i = 0; i < ku8MaxBufferSize; i++)
  {
    _u16ResponseBuffer[i] = 0;
  }
}


/**
Place data in transmit buffer.

@see ModbusMaster::clearTransmitBuffer()
@param u8Index index of transmit buffer array (0x00..0x3F)
@param u16Value value to place in position u8Index of transmit buffer (0x0000..0xFFFF)
@return 0 on success; exception number on failure
@ingroup buffer
*/
uint8_t ModbusMaster::setTransmitBuffer(uint8_t u8Index, uint16_t u16Value)
{
  if (u8Index < ku8MaxBufferSize)
  {
    _u16TransmitBuffer[u8Index] = u16Value;
    return ku8MBSuccess;
  }
  else
  {
    return ku8MBIllegalDataAddress;
  }
}


/**
Clear Modbus transmit buffer.

@see ModbusMaster::setTransmitBuffer(uint8_t u8Index, uint16_t u16Value)
@ingroup buffer
*/
void ModbusMaster::clearTransmitBuffer()
{
  uint8_t i;
  
  for (i = 0; i < ku8MaxBufferSize; i++)
  {
    _u16TransmitBuffer[i] = 0;
  }
}


/**
Modbus function 0x01 Read Coils.

This function code is used to read from 1 to 2000 contiguous status of 
coils in a remote device. The request specifies the starting address, 
i.e. the address of the first coil specified, and the number of coils. 
Coils are addressed starting at zero.

The coils in the response buffer are packed as one coil per bit of the 
data field. Status is indicated as 1=ON and 0=OFF. The LSB of the first 
data word contains the output addressed in the query. The other coils 
follow toward the high order end of this word and from low order to high 
order in subsequent words.

If the returned quantity is not a multiple of sixteen, the remaining 
bits in the final data word will be padded with zeros (toward the high 
order end of the word).

@param u16ReadAddress address of first coil (0x0000..0xFFFF)
@param u16BitQty quantity of coils to read (1..2000, enforced by remote device)
@return 0 on success; exception number on failure
@ingroup discrete
*/
uint8_t ModbusMaster::readCoils(uint16_t u16ReadAddress, uint16_t u16BitQty)
{
  _u16ReadAddress = u16ReadAddress;
  _u16ReadQty = u16BitQty;
  return ModbusMasterTransaction(ku8MBReadCoils);
}


/**
Modbus function 0x02 Read Discrete Inputs.

This function code is used to read from 1 to 2000 contiguous status of 
discrete inputs in a remote device. The request specifies the starting 
address, i.e. the address of the first input specified, and the number 
of inputs. Discrete inputs are addressed starting at zero.

The discrete inputs in the response buffer are packed as one input per 
bit of the data field. Status is indicated as 1=ON; 0=OFF. The LSB of 
the first data word contains the input addressed in the query. The other 
inputs follow toward the high order end of this word, and from low order 
to high order in subsequent words.

If the returned quantity is not a multiple of sixteen, the remaining 
bits in the final data word will be padded with zeros (toward the high 
order end of the word).

@param u16ReadAddress address of first discrete input (0x0000..0xFFFF)
@param u16BitQty quantity of discrete inputs to read (1..2000, enforced by remote device)
@return 0 on success; exception number on failure
@ingroup discrete
*/
uint8_t ModbusMaster::readDiscreteInputs(uint16_t u16ReadAddress,
  uint16_t u16BitQty)
{
  _u16ReadAddress = u16ReadAddress;
  _u16ReadQty = u16BitQty;
  return ModbusMasterTransaction(ku8MBReadDiscreteInputs);
}


/**
Modbus function 0x03 Read Holding Registers.

This function code is used to read the contents of a contiguous block of 
holding registers in a remote device. The request specifies the starting 
register address and the number of registers. Registers are addressed 
starting at zero.

The register data in the response buffer is packed as one word per 
register.

@param u16ReadAddress address of the first holding register (0x0000..0xFFFF)
@param u16ReadQty quantity of holding registers to read (1..125, enforced by remote device)
@return 0 on success; exception number on failure
@ingroup register
*/
uint8_t ModbusMaster::readHoldingRegisters(uint16_t u16ReadAddress,
  uint16_t u16ReadQty)
{
  _u16ReadAddress = u16ReadAddress;
  _u16ReadQty = u16ReadQty;
  return ModbusMasterTransaction(ku8MBReadHoldingRegisters);
}


/**
Modbus function 0x04 Read Input Registers.

This function code is used to read from 1 to 125 contiguous input 
registers in a remote device. The request specifies the starting 
register address and the number of registers. Registers are addressed 
starting at zero.

The register data in the response buffer is packed as one word per 
register.

@param u16ReadAddress address of the first input register (0x0000..0xFFFF)
@param u16ReadQty quantity of input registers to read (1..125, enforced by remote device)
@return 0 on success; exception number on failure
@ingroup register
*/
uint8_t ModbusMaster::readInputRegisters(uint16_t u16ReadAddress,
  uint8_t u16ReadQty)
{
  _u16ReadAddress = u16ReadAddress;
  _u16ReadQty = u16ReadQty;
  return ModbusMasterTransaction(ku8MBReadInputRegisters);
}


/**
Modbus function 0x05 Write Single Coil.

This function code is used to write a single output to either ON or OFF 
in a remote device. The requested ON/OFF state is specified by a 
constant in the state field. A non-zero value requests the output to be 
ON and a value of 0 requests it to be OFF. The request specifies the 
address of the coil to be forced. Coils are addressed starting at zero.

@param u16WriteAddress address of the coil (0x0000..0xFFFF)
@param u8State 0=OFF, non-zero=ON (0x00..0xFF)
@return 0 on success; exception number on failure
@ingroup discrete
*/
uint8_t ModbusMaster::writeSingleCoil(uint16_t u16WriteAddress, uint8_t u8State)
{
  _u16WriteAddress = u16WriteAddress;
  _u16WriteQty = (u8State ? 0xFF00 : 0x0000);
  return ModbusMasterTransaction(ku8MBWriteSingleCoil);
}


/**
Modbus function 0x06 Write Single Register.

This function code is used to write a single holding register in a 
remote device. The request specifies the address of the register to be 
written. Registers are addressed starting at zero.

@param u16WriteAddress address of the holding register (0x0000..0xFFFF)
@param u16WriteValue value to be written to holding register (0x0000..0xFFFF)
@return 0 on success; exception number on failure
@ingroup register
*/
uint8_t ModbusMaster::writeSingleRegister(uint16_t u16WriteAddress,
  uint16_t u16WriteValue)
{
  _u16WriteAddress = u16WriteAddress;
  _u16WriteQty = 0;
  _u16TransmitBuffer[0] = u16WriteValue;
  return ModbusMasterTransaction(ku8MBWriteSingleRegister);
}


/**
Modbus function 0x0F Write Multiple Coils.

This function code is used to force each coil in a sequence of coils to 
either ON or OFF in a remote device. The request specifies the coil 
references to be forced. Coils are addressed starting at zero.

The requested ON/OFF states are specified by contents of the transmit 
buffer. A logical '1' in a bit position of the buffer requests the 
corresponding output to be ON. A logical '0' requests it to be OFF.

@param u16WriteAddress address of the first coil (0x0000..0xFFFF)
@param u16BitQty quantity of coils to write (1..2000, enforced by remote device)
@return 0 on success; exception number on failure
@ingroup discrete
*/
uint8_t ModbusMaster::writeMultipleCoils(uint16_t u16WriteAddress,
  uint16_t u16BitQty)
{
  _u16WriteAddress = u16WriteAddress;
  _u16WriteQty = u16BitQty;
  return ModbusMasterTransaction(ku8MBWriteMultipleCoils);
}
uint8_t ModbusMaster::writeMultipleCoils()
{
  _u16WriteQty = u16TransmitBufferLength;
  return ModbusMasterTransaction(ku8MBWriteMultipleCoils);
}


/**
Modbus function 0x10 Write Multiple Registers.

This function code is used to write a block of contiguous registers (1 
to 123 registers) in a remote device.

The requested written values are specified in the transmit buffer. Data 
is packed as one word per register.

@param u16WriteAddress address of the holding register (0x0000..0xFFFF)
@param u16WriteQty quantity of holding registers to write (1..123, enforced by remote device)
@return 0 on success; exception number on failure
@ingroup register
*/
uint8_t ModbusMaster::writeMultipleRegisters(uint16_t u16WriteAddress,
  uint16_t u16WriteQty)
{
  _u16WriteAddress = u16WriteAddress;
  _u16WriteQty = u16WriteQty;
  return ModbusMasterTransaction(ku8MBWriteMultipleRegisters);
}

// new version based on Wire.h
uint8_t ModbusMaster::writeMultipleRegisters()
{
  _u16WriteQty = _u8TransmitBufferIndex;
  return ModbusMasterTransaction(ku8MBWriteMultipleRegisters);
}


/**
Modbus function 0x16 Mask Write Register.

This function code is used to modify the contents of a specified holding 
register using a combination of an AND mask, an OR mask, and the 
register's current contents. The function can be used to set or clear 
individual bits in the register.

The request specifies the holding register to be written, the data to be 
used as the AND mask, and the data to be used as the OR mask. Registers 
are addressed starting at zero.

The function's algorithm is:

Result = (Current Contents && And_Mask) || (Or_Mask && (~And_Mask))

@param u16WriteAddress address of the holding register (0x0000..0xFFFF)
@param u16AndMask AND mask (0x0000..0xFFFF)
@param u16OrMask OR mask (0x0000..0xFFFF)
@return 0 on success; exception number on failure
@ingroup register
*/
uint8_t ModbusMaster::maskWriteRegister(uint16_t u16WriteAddress,
  uint16_t u16AndMask, uint16_t u16OrMask)
{
  _u16WriteAddress = u16WriteAddress;
  _u16TransmitBuffer[0] = u16AndMask;
  _u16TransmitBuffer[1] = u16OrMask;
  return ModbusMasterTransaction(ku8MBMaskWriteRegister);
}


/**
Modbus function 0x17 Read Write Multiple Registers.

This function code performs a combination of one read operation and one 
write operation in a single MODBUS transaction. The write operation is 
performed before the read. Holding registers are addressed starting at 
zero.

The request specifies the starting address and number of holding 
registers to be read as well as the starting address, and the number of 
holding registers. The data to be written is specified in the transmit 
buffer.

@param u16ReadAddress address of the first holding register (0x0000..0xFFFF)
@param u16ReadQty quantity of holding registers to read (1..125, enforced by remote device)
@param u16WriteAddress address of the first holding register (0x0000..0xFFFF)
@param u16WriteQty quantity of holding registers to write (1..121, enforced by remote device)
@return 0 on success; exception number on failure
@ingroup register
*/
uint8_t ModbusMaster::readWriteMultipleRegisters(uint16_t u16ReadAddress,
  uint16_t u16ReadQty, uint16_t u16WriteAddress, uint16_t u16WriteQty)
{
  _u16ReadAddress = u16ReadAddress;
  _u16ReadQty = u16ReadQty;
  _u16WriteAddress = u16WriteAddress;
  _u16WriteQty = u16WriteQty;
  return ModbusMasterTransaction(ku8MBReadWriteMultipleRegisters);
}
uint8_t ModbusMaster::readWriteMultipleRegisters(uint16_t u16ReadAddress,
  uint16_t u16ReadQty)
{
  _u16ReadAddress = u16ReadAddress;
  _u16ReadQty = u16ReadQty;
  _u16WriteQty = _u8TransmitBufferIndex;
  return ModbusMasterTransaction(ku8MBReadWriteMultipleRegisters);
}


/* _____PRIVATE FUNCTIONS____________________________________________________ */
/**
Modbus transaction engine.
Sequence:
  - assemble Modbus Request Application Data Unit (ADU),
    based on particular function called
  - transmit request over selected serial port
  - wait for/retrieve response
  - evaluate/disassemble response
  - return status (success/exception)

@param u8MBFunction Modbus function (0x01..0xFF)
@return 0 on success; exception number on failure
*/
uint8_t ModbusMaster::ModbusMasterTransaction(uint8_t u8MBFunction)
{
  uint8_t u8ModbusADU[256];
  uint8_t u8ModbusADUSize = 0;
  uint8_t i, u8Qty;
  uint16_t u16CRC;
  uint32_t u32StartTime;
  uint8_t u8BytesLeft = 8;
  uint8_t u8MBStatus = ku8MBSuccess;
  
  // assemble Modbus Request Application Data Unit
  u8ModbusADU[u8ModbusADUSize++] = _u8MBSlave;
  u8ModbusADU[u8ModbusADUSize++] = u8MBFunction;
  
  switch(u8MBFunction)
  {
    case ku8MBReadCoils:
    case ku8MBReadDiscreteInputs:
    case ku8MBReadInputRegisters:
    case ku8MBReadHoldingRegisters:
    case ku8MBReadWriteMultipleRegisters:
      u8ModbusADU[u8ModbusADUSize++] = highByte(_u16ReadAddress);
      u8ModbusADU[u8ModbusADUSize++] = lowByte(_u16ReadAddress);
      u8ModbusADU[u8ModbusADUSize++] = highByte(_u16ReadQty);
      u8ModbusADU[u8ModbusADUSize++] = lowByte(_u16ReadQty);
      break;
  }
  
  switch(u8MBFunction)
  {
    case ku8MBWriteSingleCoil:
    case ku8MBMaskWriteRegister:
    case ku8MBWriteMultipleCoils:
    case ku8MBWriteSingleRegister:
    case ku8MBWriteMultipleRegisters:
    case ku8MBReadWriteMultipleRegisters:
      u8ModbusADU[u8ModbusADUSize++] = highByte(_u16WriteAddress);
      u8ModbusADU[u8ModbusADUSize++] = lowByte(_u16WriteAddress);
      break;
  }
  
  switch(u8MBFunction)
  {
    case ku8MBWriteSingleCoil:
      u8ModbusADU[u8ModbusADUSize++] = highByte(_u16WriteQty);
      u8ModbusADU[u8ModbusADUSize++] = lowByte(_u16WriteQty);
      break;
      
    case ku8MBWriteSingleRegister:
      u8ModbusADU[u8ModbusADUSize++] = highByte(_u16TransmitBuffer[0]);
      u8ModbusADU[u8ModbusADUSize++] = lowByte(_u16TransmitBuffer[0]);
      break;
      
    case ku8MBWriteMultipleCoils:
      u8ModbusADU[u8ModbusADUSize++] = highByte(_u16WriteQty);
      u8ModbusADU[u8ModbusADUSize++] = lowByte(_u16WriteQty);
      u8Qty = (_u16WriteQty % 8) ? ((_u16WriteQty >> 3) + 1) : (_u16WriteQty >> 3);
      u8ModbusADU[u8ModbusADUSize++] = u8Qty;
      for (i = 0; i < u8Qty; i++)
      {
        switch(i % 2)
        {
          case 0: // i is even
            u8ModbusADU[u8ModbusADUSize++] = lowByte(_u16TransmitBuffer[i >> 1]);
            break;
            
          case 1: // i is odd
            u8ModbusADU[u8ModbusADUSize++] = highByte(_u16TransmitBuffer[i >> 1]);
            break;
        }
      }
      break;
      
    case ku8MBWriteMultipleRegisters:
    case ku8MBReadWriteMultipleRegisters:
      u8ModbusADU[u8ModbusADUSize++] = highByte(_u16WriteQty);
      u8ModbusADU[u8ModbusADUSize++] = lowByte(_u16WriteQty);
      u8ModbusADU[u8ModbusADUSize++] = lowByte(_u16WriteQty << 1);
      
      for (i = 0; i < lowByte(_u16WriteQty); i++)
      {
        u8ModbusADU[u8ModbusADUSize++] = highByte(_u16TransmitBuffer[i]);
        u8ModbusADU[u8ModbusADUSize++] = lowByte(_u16TransmitBuffer[i]);
      }
      break;
      
    case ku8MBMaskWriteRegister:
      u8ModbusADU[u8ModbusADUSize++] = highByte(_u16TransmitBuffer[0]);
      u8ModbusADU[u8ModbusADUSize++] = lowByte(_u16TransmitBuffer[0]);
      u8ModbusADU[u8ModbusADUSize++] = highByte(_u16TransmitBuffer[1]);
      u8ModbusADU[u8ModbusADUSize++] = lowByte(_u16TransmitBuffer[1]);
      break;
  }
  
  // append CRC
  u16CRC = 0xFFFF;
  for (i = 0; i < u8ModbusADUSize; i++)
  {
    u16CRC = crc16_update(u16CRC, u8ModbusADU[i]);
  }
  u8ModbusADU[u8ModbusADUSize++] = lowByte(u16CRC);
  u8ModbusADU[u8ModbusADUSize++] = highByte(u16CRC);
  u8ModbusADU[u8ModbusADUSize] = 0;

  // flush receive buffer before transmitting request
  while (_serial->read() != -1);

  // transmit request
  if (_preTransmission)
  {
    _preTransmission();
  }
  for (i = 0; i < u8ModbusADUSize; i++)
  {
    _serial->write(u8ModbusADU[i]);
  }
  
  u8ModbusADUSize = 0;
  _serial->flush();    // flush transmit buffer
  if (_postTransmission)
  {
    _postTransmission();
  }
  
  // loop until we run out of time or bytes, or an error occurs
  u32StartTime = millis();
  while (u8BytesLeft && !u8MBStatus)
  {
    if (_serial->available())
    {
#if __MODBUSMASTER_DEBUG__
      digitalWrite(__MODBUSMASTER_DEBUG_PIN_A__, true);
#endif
      u8ModbusADU[u8ModbusADUSize++] = _serial->read();
      u8BytesLeft--;
#if __MODBUSMASTER_DEBUG__
      digitalWrite(__MODBUSMASTER_DEBUG_PIN_A__, false);
#endif
    }
    else
    {
#if __MODBUSMASTER_DEBUG__
      digitalWrite(__MODBUSMASTER_DEBUG_PIN_B__, true);
#endif
      if (_idle)
      {
        _idle();
      }
#if __MODBUSMASTER_DEBUG__
      digitalWrite(__MODBUSMASTER_DEBUG_PIN_B__, false);
#endif
    }
    
    // evaluate slave ID, function code once enough bytes have been read
    if (u8ModbusADUSize == 5)
    {
      // verify response is for correct Modbus slave
      if (u8ModbusADU[0] != _u8MBSlave)
      {
        u8MBStatus = ku8MBInvalidSlaveID;
        break;
      }
      
      // verify response is for correct Modbus function code (mask exception bit 7)
      if ((u8ModbusADU[1] & 0x7F) != u8MBFunction)
      {
        u8MBStatus = ku8MBInvalidFunction;
        break;
      }
      
      // check whether Modbus exception occurred; return Modbus Exception Code
      if (bitRead(u8ModbusADU[1], 7))
      {
        u8MBStatus = u8ModbusADU[2];
        break;
      }
      
      // evaluate returned Modbus function code
      switch(u8ModbusADU[1])
      {
        case ku8MBReadCoils:
        case ku8MBReadDiscreteInputs:
        case ku8MBReadInputRegisters:
        case ku8MBReadHoldingRegisters:
        case ku8MBReadWriteMultipleRegisters:
          u8BytesLeft = u8ModbusADU[2];
          break;
          
        case ku8MBWriteSingleCoil:
        case ku8MBWriteMultipleCoils:
        case ku8MBWriteSingleRegister:
        case ku8MBWriteMultipleRegisters:
          u8BytesLeft = 3;
          break;
          
        case ku8MBMaskWriteRegister:
          u8BytesLeft = 5;
          break;
      }
    }
    if ((millis() - u32StartTime) > ku16MBResponseTimeout)
    {
      u8MBStatus = ku8MBResponseTimedOut;
    }
  }
  
  // verify response is large enough to inspect further
  if (!u8MBStatus && u8ModbusADUSize >= 5)
  {
    // calculate CRC
    u16CRC = 0xFFFF;
    for (i = 0; i < (u8ModbusADUSize - 2); i++)
    {
      u16CRC = crc16_update(u16CRC, u8ModbusADU[i]);
    }
    
    // verify CRC
    if (!u8MBStatus && (lowByte(u16CRC) != u8ModbusADU[u8ModbusADUSize - 2] ||
      highByte(u16CRC) != u8ModbusADU[u8ModbusADUSize - 1]))
    {
      u8MBStatus = ku8MBInvalidCRC;
    }
  }

  // disassemble ADU into words
  if (!u8MBStatus)
  {
    // evaluate returned Modbus function code
    switch(u8ModbusADU[1])
    {
      case ku8MBReadCoils:
      case ku8MBReadDiscreteInputs:
        // load bytes into word; response bytes are ordered L, H, L, H, ...
        for (i = 0; i < (u8ModbusADU[2] >> 1); i++)
        {
          if (i < ku8MaxBufferSize)
          {
            _u16ResponseBuffer[i] = word(u8ModbusADU[2 * i + 4], u8ModbusADU[2 * i + 3]);
          }
          
          _u8ResponseBufferLength = i;
        }
        
        // in the event of an odd number of bytes, load last byte into zero-padded word
        if (u8ModbusADU[2] % 2)
        {
          if (i < ku8MaxBufferSize)
          {
            _u16ResponseBuffer[i] = word(0, u8ModbusADU[2 * i + 3]);
          }
          
          _u8ResponseBufferLength = i + 1;
        }
        break;
        
      case ku8MBReadInputRegisters:
      case ku8MBReadHoldingRegisters:
      case ku8MBReadWriteMultipleRegisters:
        // load bytes into word; response bytes are ordered H, L, H, L, ...
        for (i = 0; i < (u8ModbusADU[2] >> 1); i++)
        {
          if (i < ku8MaxBufferSize)
          {
            _u16ResponseBuffer[i] = word(u8ModbusADU[2 * i + 3], u8ModbusADU[2 * i + 4]);
          }
          
          _u8ResponseBufferLength = i;
        }
        break;
    }
  }
  
  _u8TransmitBufferIndex = 0;
  u16TransmitBufferLength = 0;
  _u8ResponseBufferIndex = 0;
  return u8MBStatus;
}

================
File: src/ModbusSensorManager.cpp
================
#include "ModbusSensorManager.h"
#include "ModbusMaster.h"
#include "config.h"    // Para SERIAL_BAUD
#include "debug.h"     // Para DEBUG_END
#include "sensor_types.h" // Para ENV4Keys
#include "sensor_constants.h" // Para SensorKeys
#include "utilities.h" // Para roundTo3Decimals
#include <string.h>

// Crear una instancia global de ModbusMaster
ModbusMaster modbus;

/**
 * @note 
 *  - Se usa la biblioteca ModbusMaster para la comunicación Modbus
 *  - Se asume que el pin DE/RE del transceiver RS485 está atado de forma que cuando
 *    se escribe en Serial, se habilita la transmisión, y al terminar, pasa a recepción.
 */

void ModbusSensorManager::beginModbus() {
    // Configurar Serial usando los parámetros definidos en config.h
    Serial.begin(MODBUS_BAUDRATE, MODBUS_SERIAL_CONFIG);
    
    // Inicializar ModbusMaster
    modbus.begin(0, Serial); // El slave ID se configurará en cada petición
}

void ModbusSensorManager::endModbus() {
    // Finalizar la comunicación Serial de Modbus
    Serial.end();
}

bool ModbusSensorManager::readHoldingRegisters(uint8_t address, uint16_t startReg, uint16_t numRegs, uint16_t* outData) {
    // Guardar los bytes recibidos para depuración posterior
    uint8_t result;
    
    // Establecer el slave ID
    modbus.begin(address, Serial);
    
    // Implementar reintentos de lectura
    for (uint8_t retry = 0; retry < MODBUS_MAX_RETRY; retry++) {
        // Realizar la petición Modbus para leer registros holding
        result = modbus.readHoldingRegisters(startReg, numRegs);
        
        // Verificar si la lectura fue exitosa
        if (result == modbus.ku8MBSuccess) {
            // Extraer datos de los registros
            for (uint8_t i = 0; i < numRegs; i++) {
                outData[i] = modbus.getResponseBuffer(i);
            }
            
            return true;
        }
        
        // Si no es el último intento, continuar con el siguiente intento
        // No hay delay entre intentos ya que el timeout ya se aplicó en la función readHoldingRegisters
        DEBUG_PRINTF("Intento %d fallido, código: %d\n", retry + 1, result);
    }
    
    // Si llegamos aquí, todos los intentos fallaron
    DEBUG_PRINTF("Error Modbus después de %d intentos\n", MODBUS_MAX_RETRY);
    return false;
}

ModbusSensorReading ModbusSensorManager::readEnvSensor(const ModbusSensorConfig &cfg) {
    ModbusSensorReading reading;
    strncpy(reading.sensorId, cfg.sensorId, sizeof(reading.sensorId));
    reading.type = cfg.type;
    reading.subValues.clear();

    // Lectura de 8 registros (500..507)
    const uint16_t startReg = 500;
    const uint16_t numRegs = 8;
    uint16_t rawData[8];
    memset(rawData, 0, sizeof(rawData));

    // Definir las claves para cada valor usando las constantes
    const char* keys[] = {
        ENV4_KEY_HUMIDITY,
        ENV4_KEY_TEMPERATURE,
        ENV4_KEY_PRESSURE,
        ENV4_KEY_ILLUMINATION
    };
    
    bool ok = readHoldingRegisters(cfg.address, startReg, numRegs, rawData);
    if (!ok) {
        // Llenar con NAN si fallo, pero usando las claves correctas
        for (int i=0; i<4; i++){
            SubValue sv;
            strncpy(sv.key, keys[i], sizeof(sv.key));
            sv.value = NAN;
            reading.subValues.push_back(sv);
        }
        return reading;
    }

    // Extraer segun datasheet (versión 4 en 1):
    // rawData[0] = Humedad entera *10
    // rawData[1] = Temp entera *10 (16 bits con posible signo)
    // rawData[5] = Presion *10 (en kPa)
    // rawData[6] = LuxHigh (32 bits -> parte alta)
    // rawData[7] = LuxLow  (32 bits -> parte baja)
    // Los demás registros (ruido, PM2.5, PM10) vienen en 0 y se ignoran

    // Humedad
    {
        SubValue sH;
        strncpy(sH.key, keys[0], sizeof(sH.key)); 
        sH.value = roundTo3Decimals(rawData[0] / 10.0f);
        reading.subValues.push_back(sH);
    }
    // Temperatura
    {
        SubValue sT;
        strncpy(sT.key, keys[1], sizeof(sT.key));
        // Ver si es negativo
        int16_t temp16 = (int16_t)rawData[1];
        sT.value = roundTo3Decimals(temp16 / 10.0f);
        reading.subValues.push_back(sT);
    }
    // Presion
    {
        SubValue sP;
        strncpy(sP.key, keys[2], sizeof(sP.key));
        sP.value = roundTo3Decimals(rawData[5] / 10.0f);  // kPa
        reading.subValues.push_back(sP);
    }
    // Lux
    {
        uint32_t luxHigh = rawData[6];
        uint32_t luxLow  = rawData[7];
        uint32_t fullLux = (luxHigh << 16) | luxLow; 
        SubValue sL;
        strncpy(sL.key, keys[3], sizeof(sL.key));
        sL.value = roundTo3Decimals((float)fullLux);
        reading.subValues.push_back(sL);
    }

    return reading;
}

================
File: src/PowerManager.cpp
================
#include "PowerManager.h"

PowerManager::PowerManager(PCA9555& expander) : ioExpander(expander) {
}

bool PowerManager::begin() {
    // Configurar pines como salidas
    ioExpander.pinMode(POWER_3V3_PIN, OUTPUT);
    
#if defined(DEVICE_TYPE_ANALOGIC) || defined(DEVICE_TYPE_MODBUS)
    ioExpander.pinMode(POWER_12V_PIN, OUTPUT);
#endif

#ifdef DEVICE_TYPE_ANALOGIC
    ioExpander.pinMode(POWER_2V5_PIN, OUTPUT);
#endif
    
    // Asegurar que todas las fuentes están apagadas al inicio
    allPowerOff();
    return true;
}

void PowerManager::power3V3On() {
    ioExpander.digitalWrite(POWER_3V3_PIN, HIGH);
    delay(POWER_STABILIZE_DELAY);
}

void PowerManager::power3V3Off() {
    ioExpander.digitalWrite(POWER_3V3_PIN, LOW);
}

#if defined(DEVICE_TYPE_ANALOGIC) || defined(DEVICE_TYPE_MODBUS)
void PowerManager::power12VOn() {
    ioExpander.digitalWrite(POWER_12V_PIN, HIGH);
    delay(POWER_STABILIZE_DELAY);
}

void PowerManager::power12VOff() {
    ioExpander.digitalWrite(POWER_12V_PIN, LOW);
}
#endif

#ifdef DEVICE_TYPE_ANALOGIC
void PowerManager::power2V5On() {
    ioExpander.digitalWrite(POWER_2V5_PIN, HIGH);
    delay(POWER_STABILIZE_DELAY);
}

void PowerManager::power2V5Off() {
    ioExpander.digitalWrite(POWER_2V5_PIN, LOW);
}
#endif

void PowerManager::allPowerOff() {
#ifdef DEVICE_TYPE_ANALOGIC
    power2V5Off();
#endif
    power3V3Off();
#if defined(DEVICE_TYPE_ANALOGIC) || defined(DEVICE_TYPE_MODBUS)
    power12VOff();
#endif
}

================
File: src/RTCManager.cpp
================
#include "RTCManager.h"
#include "debug.h"

RTCManager::RTCManager() {}

bool RTCManager::begin() {
    // Inicializar el RTC
    if (!rtc.begin()) {
        return false;
    }
    
    // Configurar el RTC con la hora de compilación si no está configurado
    if (rtc.lostPower()) {
        rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));
        DEBUG_PRINTLN("RTC configurado con hora de compilación");
    }
    
    return true;
}

void RTCManager::setFallbackDateTime() {
    rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));
    DEBUG_PRINTLN("RTC configurado con hora de compilación");
}

DateTime RTCManager::getCurrentTime() {
    return rtc.now();
}

void RTCManager::printDateTime() {
    DateTime currentTime = getCurrentTime();
    
    DEBUG_PRINT(currentTime.year(), DEC);
    DEBUG_PRINT('/');
    DEBUG_PRINT(currentTime.month(), DEC);
    DEBUG_PRINT('/');
    DEBUG_PRINT(currentTime.day(), DEC);
    DEBUG_PRINT(" ");
    DEBUG_PRINT(currentTime.hour(), DEC);
    DEBUG_PRINT(':');
    DEBUG_PRINT(currentTime.minute(), DEC);
    DEBUG_PRINT(':');
    DEBUG_PRINTLN(currentTime.second(), DEC);
}

uint32_t RTCManager::getEpochTime() {
    return rtc.now().unixtime();
}

bool RTCManager::setTimeFromServer(uint32_t unixTime, uint8_t fraction) {
    // Convertir el tiempo unix a DateTime
    DateTime serverTime(unixTime);
    
    // Ajustar el RTC con el tiempo del servidor
    rtc.adjust(serverTime);
    
    // Verificar si se ajustó correctamente
    if (abs((int32_t)rtc.now().unixtime() - (int32_t)unixTime) < 10) {
        DEBUG_PRINTLN("RTC actualizado exitosamente con tiempo del servidor");
        return true;
    }
    
    DEBUG_PRINTLN("Error al actualizar RTC con tiempo del servidor");
    return false;
}

================
File: src/SensorManager.cpp
================
#include "SensorManager.h"
#include <Wire.h>
#include <SPI.h>
#if defined(DEVICE_TYPE_BASIC) || defined(DEVICE_TYPE_ANALOGIC)
#include <DallasTemperature.h>
#endif
#include "MAX31865.h"
#include "RTCManager.h"
#include "sensor_types.h"
#include "config.h"
#include <Preferences.h>
#include "config_manager.h"
#include "Debug.h"
#include "sensor_constants.h"  // Para tiempos de estabilización
#include "utilities.h"  // Para roundTo3Decimals

void SensorManager::beginSensors() {
    // Inicializar pines de SPI (SS) y luego SPI
    initializeSPISSPins();
    spi.begin(SPI_SCK_PIN, SPI_MISO_PIN, SPI_MOSI_PIN);

    // Encender alimentación 3.3V
    powerManager.power3V3On();

    // Inicializar RTD y configurarlo
    rtd.begin();
    {
        bool vBias = true;
        bool autoConvert = true;
        bool oneShot = false;
        bool threeWire = false;
        uint8_t faultCycle = 0; // MAX31865_FAULT_DETECTION_NONE
        bool faultClear = true;
        bool filter50Hz = true;
        uint16_t lowTh = 0x0000;
        uint16_t highTh = 0x7fff;
        rtd.configure(vBias, autoConvert, oneShot, threeWire, faultCycle, faultClear, filter50Hz, lowTh, highTh);
    }

#if defined(DEVICE_TYPE_BASIC) || defined(DEVICE_TYPE_ANALOGIC)
    // Inicializar DS18B20
    dallasTemp.begin();
    dallasTemp.setResolution(12);
    // Lectura inicial
    dallasTemp.requestTemperatures();
    delay(750);
    dallasTemp.getTempCByIndex(0);
#endif

    // Inicializar SHT30
    sht30Sensor.begin(Wire, SHT30_I2C_ADDR_44);
    sht30Sensor.stopMeasurement();
    delay(1);
    sht30Sensor.softReset();
    delay(100);
    
    float dummyTemp = 0.0f, dummyHum = 0.0f;
    sht30Sensor.measureSingleShot(REPEATABILITY_HIGH, false, dummyTemp, dummyHum);
    delay(20);
}

void SensorManager::initializeSPISSPins() {
    // Inicializar SS del LORA conectado directamente
    pinMode(LORA_NSS_PIN, OUTPUT);
    digitalWrite(LORA_NSS_PIN, HIGH);

    // Inicializar SS conectados al expansor
    ioExpander.pinMode(PT100_CS_PIN, OUTPUT);
    ioExpander.digitalWrite(PT100_CS_PIN, HIGH);
}

SensorReading SensorManager::getSensorReading(const SensorConfig &cfg) {
    SensorReading reading;
    strncpy(reading.sensorId, cfg.sensorId, sizeof(reading.sensorId) - 1);
    reading.sensorId[sizeof(reading.sensorId) - 1] = '\0';
    reading.type = cfg.type;
    reading.value = NAN;

    readSensorValue(cfg, reading);

    if (!isnan(reading.value)) {
        reading.value = ::roundTo3Decimals(reading.value);
    }
    for (auto &sv : reading.subValues) {
        sv.value = ::roundTo3Decimals(sv.value);
    }

    return reading;
}

float SensorManager::readBatteryVoltageADC() {
#if defined(DEVICE_TYPE_ANALOGIC)
    analogReadResolution(12);
    int reading = analogRead(BATTERY_ADC_PIN);
    if (reading < 0) {
        return NAN;
    }
    float voltage = (reading / 4095.0f) * 3.3f;
    float batteryVoltage = voltage * conversionFactor;
    return ::roundTo3Decimals(batteryVoltage);
#elif defined(DEVICE_TYPE_BASIC) || defined(DEVICE_TYPE_MODBUS)
    analogReadResolution(12);
    int reading = analogRead(BATTERY_PIN);
    if (reading < 0) {
        return NAN;
    }
    float voltage = (reading / 4095.0f) * 3.3f;
    float batteryVoltage = voltage * conversionFactor;
    return ::roundTo3Decimals(batteryVoltage);
#endif
}

float SensorManager::readRtdSensor() {
    uint8_t status = rtd.read_all();
    if (status == 0) {
        return rtd.temperature();
    } else {
        return NAN;
    }
}

#if defined(DEVICE_TYPE_BASIC) || defined(DEVICE_TYPE_ANALOGIC)
float SensorManager::readDallasSensor() {
    dallasTemp.requestTemperatures();
    float temp = dallasTemp.getTempCByIndex(0);
    if (temp == DEVICE_DISCONNECTED_C) {
        return NAN;
    }
    return temp;
}
#endif

void SensorManager::readSht30(float &outTemp, float &outHum) {
    float temperature = 0.0f;
    float humidity = 0.0f;

    int16_t error = sht30Sensor.measureSingleShot(REPEATABILITY_HIGH, false, temperature, humidity);
    delay(20);
    if (error != NO_ERROR) {
        outTemp = NAN;
        outHum = NAN;
        return;
    }
    outTemp = temperature;
    outHum = humidity;
}

float SensorManager::roundTo3Decimals(float value) {
    return ::roundTo3Decimals(value);  // Usa la función global
}

float SensorManager::readSensorValue(const SensorConfig &cfg, SensorReading &reading) {
    switch (cfg.type) {
        case N100K:
        case N10K:
        case WNTC10K:
        case PH:
        case COND:
        case SOILH:
        case CONDH:
            // No implementado pero debe devolver NAN, no cero
            reading.value = NAN; 
            break;

        case RTD:
            reading.value = readRtdSensor();
            break;

#if defined(DEVICE_TYPE_BASIC) || defined(DEVICE_TYPE_ANALOGIC)
        case DS18B20:
            reading.value = readDallasSensor();
            break;
#endif

        case SHT30: {
            float tmp = 0.0f, hum = 0.0f;
            readSht30(tmp, hum);
            reading.subValues.clear();
            {
                SubValue sT; strncpy(sT.key, "T", sizeof(sT.key)); sT.value = tmp;
                reading.subValues.push_back(sT);
            }
            {
                SubValue sH; strncpy(sH.key, "H", sizeof(sH.key)); sH.value = hum;
                reading.subValues.push_back(sH);
            }
            // Asignar el valor principal como NAN si alguno de los valores del sensor falló
            reading.value = (isnan(tmp) || isnan(hum)) ? NAN : tmp;
            break;
        }

        default:
            reading.value = NAN;
            break;
    }
    return reading.value;
}

ModbusSensorReading SensorManager::getModbusSensorReading(const ModbusSensorConfig& cfg) {
    ModbusSensorReading reading;
    
    // Copiar el ID del sensor
    strlcpy(reading.sensorId, cfg.sensorId, sizeof(reading.sensorId));
    reading.type = cfg.type;
    
    // Leer sensor según su tipo
    switch (cfg.type) {
        case ENV4:
            reading = ModbusSensorManager::readEnvSensor(cfg);
            break;
        // Añadir casos para otros tipos de sensores Modbus
        default:
            DEBUG_PRINTLN("Tipo de sensor Modbus no soportado");
            break;
    }
    
    return reading;
}

void SensorManager::getAllSensorReadings(std::vector<SensorReading>& normalReadings, 
                                        std::vector<ModbusSensorReading>& modbusReadings) {
    // Obtener configuraciones de sensores habilitados
    auto enabledNormalSensors = ConfigManager::getEnabledSensorConfigs();
    auto enabledModbusSensors = ConfigManager::getEnabledModbusSensorConfigs();
    
    // Reservar espacio para los vectores
    normalReadings.reserve(enabledNormalSensors.size());
    modbusReadings.reserve(enabledModbusSensors.size());
    
    // Leer sensores normales
    for (const auto &sensor : enabledNormalSensors) {
        normalReadings.push_back(getSensorReading(sensor));
    }
    
    // Si hay sensores Modbus, inicializar comunicación, leerlos y finalizar
    if (!enabledModbusSensors.empty()) {
        // Determinar el tiempo máximo de estabilización necesario
        uint32_t maxStabilizationTime = 0;
        
        // Revisar cada sensor habilitado para encontrar el tiempo máximo
        for (const auto &sensor : enabledModbusSensors) {
            uint32_t sensorStabilizationTime = 0;
            
            // Obtener el tiempo de estabilización según el tipo de sensor
            switch (sensor.type) {
                case ENV4:
                    sensorStabilizationTime = SENSOR_MODBUS_ENV4_STABILIZATION_TIME;
                    break;
                // Añadir casos para otros tipos de sensores Modbus con sus respectivos tiempos
                default:
                    sensorStabilizationTime = 1000; // Tiempo predeterminado si no se especifica
                    break;
            }
            
            // Actualizar el tiempo máximo si este sensor necesita más tiempo
            if (sensorStabilizationTime > maxStabilizationTime) {
                maxStabilizationTime = sensorStabilizationTime;
            }
        }
        
        // Encender alimentación de 12V para sensores Modbus
        #if defined(DEVICE_TYPE_MODBUS) || defined(DEVICE_TYPE_ANALOGIC)
            powerManager.power12VOn();
            DEBUG_PRINTF("Esperando %u ms para estabilización de sensores Modbus\n", maxStabilizationTime);
            delay(maxStabilizationTime);
        #endif
        
        // Inicializar comunicación Modbus antes de comenzar las mediciones
        ModbusSensorManager::beginModbus();
        
        // Leer todos los sensores Modbus
        for (const auto &sensor : enabledModbusSensors) {
            modbusReadings.push_back(getModbusSensorReading(sensor));
        }
        
        // Finalizar comunicación Modbus después de completar todas las lecturas
        ModbusSensorManager::endModbus();
        
        // Apagar alimentación de 12V después de completar las lecturas
        #if defined(DEVICE_TYPE_MODBUS) || defined(DEVICE_TYPE_ANALOGIC)
            powerManager.power12VOff();
        #endif
    }
}

================
File: src/SleepManager.cpp
================
/*******************************************************************************************
 * Archivo: src/SleepManager.cpp
 * Descripción: Implementación de la gestión del modo deep sleep para el ESP32.
 *******************************************************************************************/

#include "SleepManager.h"
#include "debug.h"
#include "LoRaManager.h"

void SleepManager::goToDeepSleep(uint32_t timeToSleep, 
                               PowerManager& powerManager,
                               PCA9555& ioExpander,
                               SX1262* radio,
                               LoRaWANNode& node,
                               uint8_t* LWsession,
                               SPIClass& spi) {
    // Guardar sesión en RTC y otras rutinas de apagado
    uint8_t *persist = node.getBufferSession();
    memcpy(LWsession, persist, RADIOLIB_LORAWAN_SESSION_BUF_SIZE);
    
    // Apagar todos los reguladores
    powerManager.allPowerOff();
    
    // Flush Serial antes de dormir
    DEBUG_FLUSH();
    DEBUG_END();
    
    // Apagar módulos
    LoRaManager::prepareForSleep(radio);
    btStop();

    // Poner el PCA9555 en modo sleep
    ioExpander.sleep();

    // Deshabilitar I2C y SPI
    Wire.end();
    spi.end();
    
    // Configurar el temporizador y GPIO para despertar
    esp_sleep_enable_timer_wakeup(timeToSleep * 1000000ULL);
    gpio_wakeup_enable((gpio_num_t)CONFIG_PIN, GPIO_INTR_LOW_LEVEL);
    esp_sleep_enable_gpio_wakeup();
    esp_deep_sleep_enable_gpio_wakeup(BIT(CONFIG_PIN), ESP_GPIO_WAKEUP_GPIO_LOW);
    
    // Configurar pines para deep sleep
    configurePinsForDeepSleep();
    
    esp_deep_sleep_start();
}

/**
 * @brief Configura los pines no utilizados en alta impedancia para reducir el consumo durante deep sleep.
 */
void SleepManager::configurePinsForDeepSleep() {
    // Configurar pines específicos del módulo LoRa como ANALOG
    pinMode(FLOW_SENSOR_PIN, ANALOG);
    pinMode(BATTERY_PIN, ANALOG);

    pinMode(LORA_RST_PIN, ANALOG);
    pinMode(LORA_BUSY_PIN, ANALOG);
    pinMode(LORA_DIO1_PIN, ANALOG);
    pinMode(SPI_SCK_PIN, ANALOG);
    pinMode(SPI_MISO_PIN, ANALOG);
    pinMode(SPI_MOSI_PIN, ANALOG);

    pinMode(20, ANALOG); //Serial RX
    pinMode(21, ANALOG); //Serial TX

    pinMode(I2C_SDA_PIN, ANALOG); //I2C SDA
    pinMode(I2C_SCL_PIN, ANALOG); //I2C SCL

    pinMode(9, ANALOG); //LORA NSS

    // Configurar explícitamente LORA_NSS_PIN como salida en alto para mantener el chip select del módulo LoRa desactivado
    pinMode(LORA_NSS_PIN, OUTPUT);
    digitalWrite(LORA_NSS_PIN, HIGH);
    gpio_hold_en((gpio_num_t)LORA_NSS_PIN);
}

/**
 * @brief Libera el estado de retención (hold) de los pines que fueron configurados para deep sleep.
 * Esto permite que los pines puedan ser reconfigurados adecuadamente tras salir del deep sleep.
 */
void SleepManager::releaseHeldPins() {
    // Liberar específicamente el pin NSS de LoRa
    gpio_hold_dis((gpio_num_t)LORA_NSS_PIN);
    
    // Liberar otros pines si se ha aplicado retención
    // Nota: Los pines configurados como ANALOG no necesitan liberación específica
    // ya que no se les aplica retención (gpio_hold_en)
}

================
File: src/utilities.cpp
================
#include <Arduino.h>  // Agregar esta línea para definir la clase String
#include <cmath>     // Necesario para pow, round y fabs
#include "utilities.h"

// Función auxiliar para convertir un string tipo 
// "EE,F1,30,98,6A,11,4E,69,D0,DE,8A,DC,D6,8D,28,A6"
// en un array de 16 bytes
void parseKeyString(const String &keyStr, uint8_t *outArray, size_t expectedSize) {
    int index = 0;
    int start = 0;
    while (index < expectedSize && start < keyStr.length()) {
        int comma = keyStr.indexOf(',', start);
        String byteStr;
        if (comma == -1) {
            byteStr = keyStr.substring(start);
            start = keyStr.length();
        } else {
            byteStr = keyStr.substring(start, comma);
            start = comma + 1;
        }
        outArray[index] = (uint8_t)strtol(byteStr.c_str(), NULL, 16);
        index++;
    }
}

bool parseEUIString(const char* euiStr, uint64_t* eui) {
    char temp[3];
    uint8_t bytes[8];
    const char* ptr = euiStr;
    
    // Parsear 8 bytes
    for (int i = 0; i < 8; i++) {
        // Copiar dos caracteres hexadecimales
        strncpy(temp, ptr, 2);
        temp[2] = '\0';
        
        // Convertir string hex a byte
        bytes[i] = strtoul(temp, nullptr, 16);
        
        // Avanzar al siguiente par de caracteres, saltando la coma si existe
        ptr += (ptr[2] == ',') ? 3 : 2;
    }
    
    // Convertir los 8 bytes a uint64_t
    *eui = 0;
    for (int i = 0; i < 8; i++) {
        *eui = (*eui << 8) | bytes[i];
    }
    
    return true;
} 

/**
 * @brief Redondea un valor flotante a un máximo de 3 decimales.
 * @param value Valor a redondear.
 * @return Valor redondeado a 3 decimales.
 */
float roundTo3Decimals(float value) {
    return roundf(value * 1000.0f) / 1000.0f;
}

================
File: test/README
================
This directory is intended for PlatformIO Test Runner and project tests.

Unit Testing is a software testing method by which individual units of
source code, sets of one or more MCU program modules together with associated
control data, usage procedures, and operating procedures, are tested to
determine whether they are fit for use. Unit testing finds problems early
in the development cycle.

More information about PlatformIO Unit Testing:
- https://docs.platformio.org/en/latest/advanced/unit-testing/index.html



================================================================
End of Codebase
================================================================
