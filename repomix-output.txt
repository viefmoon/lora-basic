This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.gitignore
.repomix/bundles.json
include/AdcUtilities.h
include/ADS124S08.h
include/BLE.h
include/clsPCA9555.h
include/config_manager.h
include/config.h
include/debug.h
include/HardwareManager.h
include/LoRaManager.h
include/MAX31865.h
include/ModbusMaster.h
include/ModbusSensorManager.h
include/PowerManager.h
include/sensor_constants.h
include/sensor_types.h
include/SensorManager.h
include/sensors/BatterySensor.h
include/sensors/ConductivitySensor.h
include/sensors/DS18B20Sensor.h
include/sensors/HDS10Sensor.h
include/sensors/NtcManager.h
include/sensors/PHSensor.h
include/sensors/RTDSensor.h
include/sensors/SHT30Sensor.h
include/SleepManager.h
include/util/crc16.h
include/util/word.h
include/utilities.h
lib/README
platformio.ini
src/AdcUtilities.cpp
src/ADS124S08.cpp
src/BLE.cpp
src/clsPCA9555.cpp
src/config_manager.cpp
src/HardwareManager.cpp
src/LoRaManager.cpp
src/main.cpp
src/MAX31865.cpp
src/ModbusMaster.cpp
src/ModbusSensorManager.cpp
src/PowerManager.cpp
src/SensorManager.cpp
src/sensors/BatterySensor.cpp
src/sensors/ConductivitySensor.cpp
src/sensors/DS18B20Sensor.cpp
src/sensors/HDS10Sensor.cpp
src/sensors/NtcManager.cpp
src/sensors/PHSensor.cpp
src/sensors/RTDSensor.cpp
src/sensors/SHT30Sensor.cpp
src/SleepManager.cpp
src/utilities.cpp
test/README

================================================================
Files
================================================================

================
File: .gitignore
================
.pio
.vscode/.browse.c_cpp.db*
.vscode/c_cpp_properties.json
.vscode/launch.json
.vscode/ipch

================
File: .repomix/bundles.json
================
{
  "bundles": {}
}

================
File: include/AdcUtilities.h
================
#ifndef ADC_UTILITIES_H
#define ADC_UTILITIES_H

#include <Arduino.h>

/**
 * @brief Clase para gestionar funciones de utilidad relacionadas con el ADC
 */
class AdcUtilities {
public:
    /**
     * @brief Mide el voltaje diferencial configurando el MUX del ADS124S08.
     * @param muxConfig Valor del registro INPMUX (p.ej. ADS_P_AIN1 | ADS_N_AIN0)
     * @return Voltaje diferencial medido (en V), o NAN en caso de error.
     */
    static float measureAdcDifferential(uint8_t muxConfig);
};

#endif // ADC_UTILITIES_H

================
File: include/BLE.h
================
#ifndef BLE_H
#define BLE_H

#include <Arduino.h>
#include <BLEDevice.h>
#include <BLEServer.h>
#include <BLEAdvertising.h>
#include <BLECharacteristic.h>
#include <ArduinoJson.h>
#include "clsPCA9555.h"
#include "config.h"
#include "config_manager.h"
#include "debug.h"

// Clase para gestionar toda la funcionalidad BLE
class BLEHandler {
public:
    /**
     * @brief Verifica si se mantuvo presionado el botón de configuración y activa el modo BLE.
     * @param ioExpander Referencia al expansor de I/O para controlar el LED
     * @return true si se activó el modo BLE, false en caso contrario
     */
    static bool checkConfigMode(PCA9555& ioExpander);

    /**
     * @brief Inicializa el BLE con el nombre del dispositivo basado en el devEUI
     * @param devEUI Identificador único del dispositivo
     * @return Puntero al servidor BLE creado
     */
    static BLEServer* initBLE(const String& devEUI);

    /**
     * @brief Configura los servicios y características BLE
     * @param pServer Servidor BLE donde se configurarán los servicios
     * @return Puntero al servicio BLE creado
     */
    static BLEService* setupService(BLEServer* pServer);

    /**
     * @brief Ejecuta el bucle de parpadeo del LED en modo configuración
     * @param ioExpander Referencia al expansor de I/O para controlar el LED
     */
    static void runConfigLoop(PCA9555& ioExpander);

private:
    // Callback para eventos del servidor BLE
    class ServerCallbacks: public BLEServerCallbacks {
    public:
        void onConnect(BLEServer* pServer) override;
        void onDisconnect(BLEServer* pServer) override;
    };

    // Callback para configuración del sistema
    class SystemConfigCallback: public BLECharacteristicCallbacks {
        void onWrite(BLECharacteristic *pCharacteristic) override;
        void onRead(BLECharacteristic *pCharacteristic) override;
    };

#ifdef DEVICE_TYPE_ANALOGIC
    // Callback para NTC 100K
    class NTC100KConfigCallback: public BLECharacteristicCallbacks {
        void onWrite(BLECharacteristic *pCharacteristic) override;
        void onRead(BLECharacteristic *pCharacteristic) override;
    };

    // Callback para NTC 10K
    class NTC10KConfigCallback: public BLECharacteristicCallbacks {
        void onWrite(BLECharacteristic *pCharacteristic) override;
        void onRead(BLECharacteristic *pCharacteristic) override;
    };

    // Callback para Conductividad
    class ConductivityConfigCallback: public BLECharacteristicCallbacks {
        void onWrite(BLECharacteristic *pCharacteristic) override;
        void onRead(BLECharacteristic *pCharacteristic) override;
    };

    // Callback para pH
    class PHConfigCallback: public BLECharacteristicCallbacks {
        void onWrite(BLECharacteristic *pCharacteristic) override;
        void onRead(BLECharacteristic *pCharacteristic) override;
    };
#endif

    // Callback para configuración de sensores
#if defined(DEVICE_TYPE_BASIC) || defined(DEVICE_TYPE_ANALOGIC) || defined(DEVICE_TYPE_MODBUS)
    class SensorsConfigCallback: public BLECharacteristicCallbacks {
        void onWrite(BLECharacteristic *pCharacteristic) override;
        void onRead(BLECharacteristic *pCharacteristic) override;
    };
#endif

    // Callback para configuración de LoRa
    class LoRaConfigCallback: public BLECharacteristicCallbacks {
        void onWrite(BLECharacteristic *pCharacteristic) override;
        void onRead(BLECharacteristic *pCharacteristic) override;
    };
};

#endif // BLE_H

================
File: include/clsPCA9555.h
================
/*
 * clsPCA9555.h
 *
 *  Created on: 27 jul. 2015
 *      Author: Nico
 */

#ifndef CLSPCA9555_H_
#define CLSPCA9555_H_

#if defined(ARDUINO) && ARDUINO >= 100
#include "Arduino.h"
#else
#include "WProgram.h"
#endif

#define DEBUG 0

#include "config.h"

/** enum with names of ports ED0 - ED15 */
enum {
    ED0, ED1, ED2 , ED3 , ED4 , ED5 , ED6 , ED7 ,
    ED8, ED9, ED10, ED11, ED12, ED13, ED14, ED15
};

/** enum with names of the ports as they're referred to on the TI datasheet */
enum {
    P00, P01, P02, P03, P04, P05, P06, P07,
    P10, P11, P12, P13, P14, P15, P16, P17,
};

//
// PCA9555 defines
//
#define NXP_INPUT      0
#define NXP_OUTPUT     2
#define NXP_INVERT     4
#define NXP_CONFIG     6

class PCA9555 {
public:
    PCA9555(uint8_t address, int sda, int scl, int interruptPin = -1);
    PCA9555(uint8_t address, int interruptPin = -1);
    void pinMode(uint8_t pin, uint8_t IOMode );          // pinMode
    uint8_t digitalRead(uint8_t pin);                    // digitalRead
    void digitalWrite(uint8_t pin, uint8_t value );      // digitalWrite
    uint8_t stateOfPin(uint8_t pin);                     // Actual ISR
    void setClock(uint32_t clockFrequency);              // Clock speed
    bool begin();                                        // Checks if PCA is responsive
    void sleep();

private:
    static PCA9555* instancePointer;
    static void alertISR(void); // Function pointing to actual ISR
    void pinStates();           // Function tied to interrupt

    //
    // low level methods
    //
    uint16_t I2CGetValue(uint8_t address, uint8_t reg);
    void I2CSetValue(uint8_t address, uint8_t reg, uint8_t value);

    union {
        struct {
            uint8_t _stateOfPins_low;          // low order byte
            uint8_t _stateOfPins_high;         // high order byte
        };
        uint16_t _stateOfPins;                 // 16 bits presentation
    };
    union {
        struct {
            uint8_t _configurationRegister_low;          // low order byte
            uint8_t _configurationRegister_high;         // high order byte
        };
        uint16_t _configurationRegister;                 // 16 bits presentation
    };
    union {
        struct {
            uint8_t _valueRegister_low;                  // low order byte
            uint8_t _valueRegister_high;                 // high order byte
        };
        uint16_t _valueRegister;
    };
    uint8_t _address;                                    // address of port this class is supporting
    int _error;                                          // error code from I2C
    int _sda;
    int _scl;
};


#endif /* CLSPCA9555_H_ */

================
File: include/debug.h
================
/*******************************************************************************************
 * Archivo: include/debug.h
 * Descripción: Sistema de depuración configurable para mensajes por Serial
 *******************************************************************************************/

#ifndef DEBUG_H
#define DEBUG_H

#include <Arduino.h>
#include "config.h"

// Si DEBUG_ENABLED está definido en config.h, las macros de depuración estarán activas
// Si no está definido, las macros se compilarán como código vacío

#ifdef DEBUG_ENABLED
    #define DEBUG_BEGIN(baud)     Serial.begin(baud)
    #define DEBUG_PRINT(...)      Serial.print(__VA_ARGS__)
    #define DEBUG_PRINTLN(...)    Serial.println(__VA_ARGS__)
    #define DEBUG_PRINTF(...)     Serial.printf(__VA_ARGS__)
    #define DEBUG_FLUSH()         Serial.flush()
    #define DEBUG_END()           Serial.end()
#else
    #define DEBUG_BEGIN(baud)     Serial.begin(baud)  // Mantenemos Serial.begin por compatibilidad
    #define DEBUG_PRINT(...)      {}
    #define DEBUG_PRINTLN(...)    {}
    #define DEBUG_PRINTF(...)     {}
    #define DEBUG_FLUSH()         Serial.flush()      // Mantenemos Serial.flush por seguridad
    #define DEBUG_END()           Serial.end()        // Mantenemos Serial.end por seguridad
#endif

#endif // DEBUG_H

================
File: include/MAX31865.h
================
#ifndef _MAX31865_H
#define _MAX31865_H

#include <stdint.h>
#include <SPI.h>
#include "clsPCA9555.h"


#define MAX31865_FAULT_HIGH_THRESHOLD  ( 1 << 7 )
#define MAX31865_FAULT_LOW_THRESHOLD   ( 1 << 6 )
#define MAX31865_FAULT_REFIN           ( 1 << 5 )
#define MAX31865_FAULT_REFIN_FORCE     ( 1 << 4 )
#define MAX31865_FAULT_RTDIN_FORCE     ( 1 << 3 )
#define MAX31865_FAULT_VOLTAGE         ( 1 << 2 )

#define MAX31865_FAULT_DETECTION_NONE      ( 0x00 << 2 )
#define MAX31865_FAULT_DETECTION_AUTO      ( 0x01 << 2 )
#define MAX31865_FAULT_DETECTION_MANUAL_1  ( 0x02 << 2 )
#define MAX31865_FAULT_DETECTION_MANUAL_2  ( 0x03 << 2 )



/* RTD data, RTD current, and measurement reference
   voltage. The ITS-90 standard is used; other RTDs
   may have coefficients defined by the DIN 43760 or
   the U.S. Industrial (American) standard. */
#define RTD_A_ITS90         3.9080e-3
#define RTD_A_USINDUSTRIAL  3.9692e-3
#define RTD_A_DIN43760      3.9848e-3
#define RTD_B_ITS90         -5.870e-7
#define RTD_B_USINDUSTRIAL  -5.8495e-7
#define RTD_B_DIN43760      -5.8019e-7
/* RTD coefficient C is required only for temperatures
   below 0 deg. C.  The selected RTD coefficient set
   is specified below. */
#define SELECT_RTD_HELPER(x) x
#define SELECT_RTD(x) SELECT_RTD_HELPER(x)
#define RTD_A         SELECT_RTD(RTD_A_ITS90)
#define RTD_B         SELECT_RTD(RTD_B_ITS90)
/*
 * The reference resistor on the hardware; see the MAX31865 datasheet
 * for details.  The values 400 and 4000 Ohm are recommended values for
 * the PT100 and PT1000.
 */
#define RTD_RREF_PT100         430 /* Ohm */
#define RTD_RREF_PT1000       4000 /* Ohm */
/*
 * The RTD resistance at 0 degrees Celcius.  For the PT100, this is 100 Ohm;
 * for the PT1000, it is 1000 Ohm.
 */
#define RTD_RESISTANCE_PT100   100 /* Ohm */
#define RTD_RESISTANCE_PT1000 1000 /* Ohm */

#define RTD_ADC_RESOLUTION  ( 1u << 15 ) /* 15 bits */


/* See the main (MAX31865.cpp) file for documentation of the class methods. */
class MAX31865_RTD
{
public:
  enum ptd_type { RTD_PT100, RTD_PT1000 };

  /**
   * @brief Constructor para usar PCA9555 como CS.
   * @param type         Tipo de RTD (PT100/PT1000)
   * @param spi          Referencia al objeto SPI que usarás (por ej. spiCustom)
   * @param spiSettings  Configuración de SPI (frecuencia, MSB/LSB, modo, etc.)
   * @param pca          Referencia a tu PCA9555
   * @param pcaPinCS     Pin del PCA que actúa como CS
   */
  MAX31865_RTD(
      ptd_type type,
      SPIClass& spi,
      SPISettings& spiSettings,
      PCA9555& pca,
      uint8_t pcaPinCS
  );

    /**
   * @brief Constructor alternativo, usando pin nativo de microcontrolador como CS.
   */
  MAX31865_RTD(
      ptd_type type,
      SPIClass& spi,
      SPISettings& spiSettings,
      uint8_t csPin
  );

  void configure( bool v_bias, bool conversion_mode, bool one_shot, bool three_wire,
                  uint8_t fault_cycle, bool fault_clear, bool filter_50hz,
                  uint16_t low_threshold, uint16_t high_threshold );
  uint8_t read_all( );
  double temperature( ) const;
  uint8_t status( ) const { return( measured_status ); }
  uint16_t low_threshold( ) const { return( measured_low_threshold ); }
  uint16_t high_threshold( ) const  { return( measured_high_threshold ); }
  uint16_t raw_resistance( ) const { return( measured_resistance ); }
  double resistance( ) const
  {
    const double rtd_rref =
      ( this->type == RTD_PT100 ) ? (double)RTD_RREF_PT100 : (double)RTD_RREF_PT1000;
    return( (double)raw_resistance( ) * rtd_rref / (double)RTD_ADC_RESOLUTION );
  }

  // Nuevo método para medición única
  double singleMeasurement(uint16_t conversionDelayMs = 100);

  // Agregar el método begin
  bool begin();

private:
  void reconfigure();
  void setCSLow();
  void setCSHigh();

  /* SPI */
  SPIClass* _spi;           ///< Puntero a la clase SPI
  SPISettings* _spiSettings;   ///< Puntero a SPISettings

  /* PCA9555 / Pin CS */
  PCA9555* _pca = nullptr; 
  uint8_t  _pcaPinCS = 0xFF;
  bool     _usePCA   = false;

  uint8_t  _csPinMCU = 0xFF;     ///< CS pin nativo (si no usamos PCA)

  /* Config RTD */
  ptd_type type;
  uint8_t  configuration_control_bits;
  uint16_t configuration_low_threshold;
  uint16_t configuration_high_threshold;

  /* Valores leídos del dispositivo */
  uint8_t  measured_configuration = 0;
  uint16_t measured_resistance    = 0;
  uint16_t measured_high_threshold= 0;
  uint16_t measured_low_threshold = 0;
  uint8_t  measured_status        = 0;
};

#endif /* _MAX31865_H */

================
File: include/ModbusMaster.h
================
/**
@file
Arduino library for communicating with Modbus slaves over RS232/485 (via RTU protocol).

@defgroup setup ModbusMaster Object Instantiation/Initialization
@defgroup buffer ModbusMaster Buffer Management
@defgroup discrete Modbus Function Codes for Discrete Coils/Inputs
@defgroup register Modbus Function Codes for Holding/Input Registers
@defgroup constant Modbus Function Codes, Exception Codes
*/
/*

  ModbusMaster.h - Arduino library for communicating with Modbus slaves
  over RS232/485 (via RTU protocol).

  Library:: ModbusMaster

  Copyright:: 2009-2016 Doc Walker

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

*/

  
#ifndef ModbusMaster_h
#define ModbusMaster_h


/**
@def __MODBUSMASTER_DEBUG__ (0)
Set to 1 to enable debugging features within class:
  - PIN A cycles for each byte read in the Modbus response
  - PIN B cycles for each millisecond timeout during the Modbus response
*/
#define __MODBUSMASTER_DEBUG__ (0)
#define __MODBUSMASTER_DEBUG_PIN_A__ 4
#define __MODBUSMASTER_DEBUG_PIN_B__ 5

/* _____STANDARD INCLUDES____________________________________________________ */
// include types & constants of Wiring core API
#include "Arduino.h"

/* _____UTILITY MACROS_______________________________________________________ */


/* _____PROJECT INCLUDES_____________________________________________________ */
// functions to calculate Modbus Application Data Unit CRC
#include "util/crc16.h"

// functions to manipulate words
#include "util/word.h"


/* _____CLASS DEFINITIONS____________________________________________________ */
/**
Arduino class library for communicating with Modbus slaves over 
RS232/485 (via RTU protocol).
*/
class ModbusMaster
{
  public:
    ModbusMaster();
   
    void begin(uint8_t, Stream &serial);
    void idle(void (*)());
    void preTransmission(void (*)());
    void postTransmission(void (*)());

    // Modbus exception codes
    /**
    Modbus protocol illegal function exception.
    
    The function code received in the query is not an allowable action for
    the server (or slave). This may be because the function code is only
    applicable to newer devices, and was not implemented in the unit
    selected. It could also indicate that the server (or slave) is in the
    wrong state to process a request of this type, for example because it is
    unconfigured and is being asked to return register values.
    
    @ingroup constant
    */
    static const uint8_t ku8MBIllegalFunction            = 0x01;

    /**
    Modbus protocol illegal data address exception.
    
    The data address received in the query is not an allowable address for 
    the server (or slave). More specifically, the combination of reference 
    number and transfer length is invalid. For a controller with 100 
    registers, the ADU addresses the first register as 0, and the last one 
    as 99. If a request is submitted with a starting register address of 96 
    and a quantity of registers of 4, then this request will successfully 
    operate (address-wise at least) on registers 96, 97, 98, 99. If a 
    request is submitted with a starting register address of 96 and a 
    quantity of registers of 5, then this request will fail with Exception 
    Code 0x02 "Illegal Data Address" since it attempts to operate on 
    registers 96, 97, 98, 99 and 100, and there is no register with address 
    100. 
    
    @ingroup constant
    */
    static const uint8_t ku8MBIllegalDataAddress         = 0x02;
    
    /**
    Modbus protocol illegal data value exception.
    
    A value contained in the query data field is not an allowable value for 
    server (or slave). This indicates a fault in the structure of the 
    remainder of a complex request, such as that the implied length is 
    incorrect. It specifically does NOT mean that a data item submitted for 
    storage in a register has a value outside the expectation of the 
    application program, since the MODBUS protocol is unaware of the 
    significance of any particular value of any particular register.
    
    @ingroup constant
    */
    static const uint8_t ku8MBIllegalDataValue           = 0x03;
    
    /**
    Modbus protocol slave device failure exception.
    
    An unrecoverable error occurred while the server (or slave) was
    attempting to perform the requested action.
    
    @ingroup constant
    */
    static const uint8_t ku8MBSlaveDeviceFailure         = 0x04;

    // Class-defined success/exception codes
    /**
    ModbusMaster success.
    
    Modbus transaction was successful; the following checks were valid:
      - slave ID
      - function code
      - response code
      - data
      - CRC
      
    @ingroup constant
    */
    static const uint8_t ku8MBSuccess                    = 0x00;
    
    /**
    ModbusMaster invalid response slave ID exception.
    
    The slave ID in the response does not match that of the request.
    
    @ingroup constant
    */
    static const uint8_t ku8MBInvalidSlaveID             = 0xE0;
    
    /**
    ModbusMaster invalid response function exception.
    
    The function code in the response does not match that of the request.
    
    @ingroup constant
    */
    static const uint8_t ku8MBInvalidFunction            = 0xE1;
    
    /**
    ModbusMaster response timed out exception.
    
    The entire response was not received within the timeout period, 
    ModbusMaster::ku8MBResponseTimeout. 
    
    @ingroup constant
    */
    static const uint8_t ku8MBResponseTimedOut           = 0xE2;
    
    /**
    ModbusMaster invalid response CRC exception.
    
    The CRC in the response does not match the one calculated.
    
    @ingroup constant
    */
    static const uint8_t ku8MBInvalidCRC                 = 0xE3;
    
    uint16_t getResponseBuffer(uint8_t);
    void     clearResponseBuffer();
    uint8_t  setTransmitBuffer(uint8_t, uint16_t);
    void     clearTransmitBuffer();
    
    void beginTransmission(uint16_t);
    uint8_t requestFrom(uint16_t, uint16_t);
    void sendBit(bool);
    void send(uint8_t);
    void send(uint16_t);
    void send(uint32_t);
    uint8_t available(void);
    uint16_t receive(void);
    
    
    uint8_t  readCoils(uint16_t, uint16_t);
    uint8_t  readDiscreteInputs(uint16_t, uint16_t);
    uint8_t  readHoldingRegisters(uint16_t, uint16_t);
    uint8_t  readInputRegisters(uint16_t, uint8_t);
    uint8_t  writeSingleCoil(uint16_t, uint8_t);
    uint8_t  writeSingleRegister(uint16_t, uint16_t);
    uint8_t  writeMultipleCoils(uint16_t, uint16_t);
    uint8_t  writeMultipleCoils();
    uint8_t  writeMultipleRegisters(uint16_t, uint16_t);
    uint8_t  writeMultipleRegisters();
    uint8_t  maskWriteRegister(uint16_t, uint16_t, uint16_t);
    uint8_t  readWriteMultipleRegisters(uint16_t, uint16_t, uint16_t, uint16_t);
    uint8_t  readWriteMultipleRegisters(uint16_t, uint16_t);
    
  private:
    Stream* _serial;                                             ///< reference to serial port object
    uint8_t  _u8MBSlave;                                         ///< Modbus slave (1..255) initialized in begin()
    static const uint8_t ku8MaxBufferSize                = 64;   ///< size of response/transmit buffers    
    uint16_t _u16ReadAddress;                                    ///< slave register from which to read
    uint16_t _u16ReadQty;                                        ///< quantity of words to read
    uint16_t _u16ResponseBuffer[ku8MaxBufferSize];               ///< buffer to store Modbus slave response; read via GetResponseBuffer()
    uint16_t _u16WriteAddress;                                   ///< slave register to which to write
    uint16_t _u16WriteQty;                                       ///< quantity of words to write
    uint16_t _u16TransmitBuffer[ku8MaxBufferSize];               ///< buffer containing data to transmit to Modbus slave; set via SetTransmitBuffer()
    uint16_t* txBuffer; // from Wire.h -- need to clean this up Rx
    uint8_t _u8TransmitBufferIndex;
    uint16_t u16TransmitBufferLength;
    uint16_t* rxBuffer; // from Wire.h -- need to clean this up Rx
    uint8_t _u8ResponseBufferIndex;
    uint8_t _u8ResponseBufferLength;
    
    // Modbus function codes for bit access
    static const uint8_t ku8MBReadCoils                  = 0x01; ///< Modbus function 0x01 Read Coils
    static const uint8_t ku8MBReadDiscreteInputs         = 0x02; ///< Modbus function 0x02 Read Discrete Inputs
    static const uint8_t ku8MBWriteSingleCoil            = 0x05; ///< Modbus function 0x05 Write Single Coil
    static const uint8_t ku8MBWriteMultipleCoils         = 0x0F; ///< Modbus function 0x0F Write Multiple Coils

    // Modbus function codes for 16 bit access
    static const uint8_t ku8MBReadHoldingRegisters       = 0x03; ///< Modbus function 0x03 Read Holding Registers
    static const uint8_t ku8MBReadInputRegisters         = 0x04; ///< Modbus function 0x04 Read Input Registers
    static const uint8_t ku8MBWriteSingleRegister        = 0x06; ///< Modbus function 0x06 Write Single Register
    static const uint8_t ku8MBWriteMultipleRegisters     = 0x10; ///< Modbus function 0x10 Write Multiple Registers
    static const uint8_t ku8MBMaskWriteRegister          = 0x16; ///< Modbus function 0x16 Mask Write Register
    static const uint8_t ku8MBReadWriteMultipleRegisters = 0x17; ///< Modbus function 0x17 Read Write Multiple Registers
    
    // Modbus timeout [milliseconds]
    static const uint16_t ku16MBResponseTimeout          = 2000; ///< Modbus timeout [milliseconds]
    
    // master function that conducts Modbus transactions
    uint8_t ModbusMasterTransaction(uint8_t u8MBFunction);
    
    // idle callback function; gets called during idle time between TX and RX
    void (*_idle)();
    // preTransmission callback function; gets called before writing a Modbus message
    void (*_preTransmission)();
    // postTransmission callback function; gets called after a Modbus message has been sent
    void (*_postTransmission)();
};
#endif

/**
@example examples/Basic/Basic.pde
@example examples/PhoenixContact_nanoLC/PhoenixContact_nanoLC.pde
@example examples/RS485_HalfDuplex/RS485_HalfDuplex.ino
*/

================
File: include/sensor_constants.h
================
/*******************************************************************************************
 * Archivo: include/sensor_constants.h
 * Descripción: Constantes y definiciones para sensores
 *******************************************************************************************/

#ifndef SENSOR_CONSTANTS_H
#define SENSOR_CONSTANTS_H

/**
 * @brief Claves para sensores específicos
 */
// Claves para el sensor ambiental 4 en 1 (ENV4)
#define ENV4_KEY_HUMIDITY "H"       // Clave para Humedad en sensor ENV4
#define ENV4_KEY_TEMPERATURE "T"    // Clave para Temperatura en sensor ENV4
#define ENV4_KEY_PRESSURE "P"       // Clave para Presión Atmosférica en sensor ENV4
#define ENV4_KEY_ILLUMINATION "Lux" // Clave para Iluminación en sensor ENV4

/**
 * @brief Tiempos de estabilización para sensores (en ms)
 */
// Para sensores Modbus
#define SENSOR_MODBUS_ENV4_STABILIZATION_TIME 5000   // Tiempo de estabilización para sensor ENV4
// Añadir aquí otros tiempos de estabilización

#endif // SENSOR_CONSTANTS_H

================
File: include/sensors/BatterySensor.h
================
#ifndef BATTERY_SENSOR_H
#define BATTERY_SENSOR_H

#include <Arduino.h>
#include "config.h"
#include "debug.h"

/**
 * @brief Clase para manejar la lectura del voltaje de la batería
 */
class BatterySensor {
public:
    /**
     * @brief Lee el voltaje de la batería
     * 
     * @return float Voltaje de la batería en voltios, o NAN si hay error
     */
    static float readVoltage();

private:
    /**
     * @brief Calcula el voltaje real de la batería a partir de la lectura del ADC
     * 
     * El circuito es un divisor de voltaje:
     * 
     * Batería (+) ---- R2 ---- | ---- R1 ---- GND
     *                          |
     *                          +--- ADC Pin
     * 
     * Donde:
     * - R2 es la resistencia de arriba (conectada a la batería)
     * - R1 es la resistencia de abajo (conectada a GND)
     * - La tensión medida por el ADC es V_adc = V_bat * R1 / (R1 + R2)
     * - Por lo tanto, V_bat = V_adc * (R1 + R2) / R1
     * 
     * @param adcVoltage Voltaje medido por el ADC
     * @return float Voltaje real de la batería
     */
    static float calculateBatteryVoltage(float adcVoltage);
};

#endif // BATTERY_SENSOR_H

================
File: include/sensors/ConductivitySensor.h
================
#ifndef CONDUCTIVITY_SENSOR_H
#define CONDUCTIVITY_SENSOR_H

#include <Arduino.h>
#include "config.h"
#include "debug.h"
#include "config_manager.h"

#ifdef DEVICE_TYPE_ANALOGIC

/**
 * @brief Clase para manejar el sensor de conductividad
 */
class ConductivitySensor {
public:
    /**
     * @brief Lee el sensor de conductividad conectado al canal AIN6 del ADC
     * 
     * @return float Valor de conductividad/TDS en ppm, o NAN si hay error
     */
    static float read();

    /**
     * @brief Convierte el voltaje medido a conductividad/TDS en ppm
     * 
     * @param voltage Voltaje medido del sensor
     * @param tempC Temperatura actual del agua para compensación
     * @return float Valor de TDS en ppm (partes por millón)
     */
    static float convertVoltageToConductivity(float voltage, float tempC);
};

#endif // DEVICE_TYPE_ANALOGIC

#endif // CONDUCTIVITY_SENSOR_H

================
File: include/sensors/DS18B20Sensor.h
================
#ifndef DS18B20_SENSOR_H
#define DS18B20_SENSOR_H

#include <Arduino.h>
#include "config.h"
#include "debug.h"

#if defined(DEVICE_TYPE_BASIC) || defined(DEVICE_TYPE_ANALOGIC)
#include <DallasTemperature.h>

// Variable externa
extern DallasTemperature dallasTemp;

/**
 * @brief Clase para manejar el sensor de temperatura DS18B20
 */
class DS18B20Sensor {
public:
    /**
     * @brief Lee la temperatura del sensor DS18B20
     * 
     * @return float Temperatura en °C, o NAN si hay error
     */
    static float read();
};

#endif // defined(DEVICE_TYPE_BASIC) || defined(DEVICE_TYPE_ANALOGIC)

#endif // DS18B20_SENSOR_H

================
File: include/sensors/HDS10Sensor.h
================
#ifndef HDS10_SENSOR_H
#define HDS10_SENSOR_H

#include <Arduino.h>
#include "config.h"
#include "debug.h"

#ifdef DEVICE_TYPE_ANALOGIC

/**
 * @brief Clase para manejar el sensor de humedad HDS10
 */
class HDS10Sensor {
public:
    /**
     * @brief Lee el sensor HDS10 conectado al canal AIN5/AIN8 del ADC
     * 
     * @return float Porcentaje de humedad (0-100%) según calibración definida
     *               o NAN si ocurre un error o no es posible leer
     */
    static float read();

    /**
     * @brief Convierte la resistencia del sensor HDS10 a porcentaje de humedad
     * 
     * @param resistance Resistencia del sensor en ohms
     * @return float Porcentaje de humedad relativa (50-100%)
     */
    static float convertResistanceToHumidity(float resistance);
};

#endif // DEVICE_TYPE_ANALOGIC

#endif // HDS10_SENSOR_H

================
File: include/sensors/NtcManager.h
================
#ifndef NTC_MANAGER_H
#define NTC_MANAGER_H

#include <Arduino.h>

/**
 * @brief Clase para gestionar los cálculos y lecturas de sensores NTC100K
 */
class NtcManager {
public:
    /**
     * @brief Calcula los coeficientes A, B y C de Steinhart-Hart usando 3 puntos (T, R).
     *        T debe estar en Kelvin. R en ohms.
     * @param T1 Temperatura en Kelvin en punto 1
     * @param R1 Resistencia en ohms en punto 1
     * @param T2 Temperatura en Kelvin en punto 2
     * @param R2 Resistencia en ohms en punto 2
     * @param T3 Temperatura en Kelvin en punto 3
     * @param R3 Resistencia en ohms en punto 3
     * @param A [out] Coeficiente A
     * @param B [out] Coeficiente B
     * @param C [out] Coeficiente C
     */
    static void calculateSteinhartHartCoeffs(double T1, double R1,
                                           double T2, double R2,
                                           double T3, double R3,
                                           double &A, double &B, double &C);

    /**
     * @brief Calcula la temperatura (°C) a partir de la resistencia usando la ecuación de Steinhart-Hart.
     * @param resistance Resistencia medida (ohms)
     * @param A Coeficiente A
     * @param B Coeficiente B
     * @param C Coeficiente C
     * @return Temperatura en °C
     */
    static double steinhartHartTemperature(double resistance, double A, double B, double C);

    /**
     * @brief Calcula la resistencia del NTC en el puente de Wheatstone según la disposición descrita
     * @param diffVoltage Voltaje diferencial = (Vneg - 1.25)
     * @return Resistencia medida del NTC (ohms)
     */
    static double computeNtcResistanceFromBridge(double diffVoltage);

    /**
     * @brief Calcula la resistencia del NTC en un divisor de tensión simple.
     * @param voltage Voltaje medido en el punto medio del divisor (V)
     * @param vRef Voltaje de referencia (V), típicamente 2.5V
     * @param rFixed Resistencia fija en el divisor (ohms), típicamente 10000 ohms
     * @param ntcTop Si true, el NTC está conectado a Vref; si false, está conectado a GND
     * @return Resistencia medida del NTC (ohms)
     */
    static double computeNtcResistanceFromVoltageDivider(double voltage, double vRef, double rFixed, bool ntcTop = true);

    /**
     * @brief Obtiene la temperatura de un sensor NTC100K
     * @param configKey "0" o "1"
     * @return Temperatura en °C o NAN en caso de error
     */
    static double readNtc100kTemperature(const char* configKey);

    /**
     * @brief Obtiene la temperatura de un sensor NTC10K
     * @return Temperatura en °C o NAN en caso de error
     */
    static double readNtc10kTemperature();
};

#endif // NTC_MANAGER_H

================
File: include/sensors/PHSensor.h
================
#ifndef PH_SENSOR_H
#define PH_SENSOR_H

#include <Arduino.h>
#include "config.h"
#include "debug.h"
#include "config_manager.h"

#ifdef DEVICE_TYPE_ANALOGIC

/**
 * @brief Clase para manejar el sensor de pH
 */
class PHSensor {
public:
    /**
     * @brief Lee el sensor de pH conectado al canal AIN7 del ADC
     * 
     * @return float Valor de pH (0-14), o NAN si hay error
     */
    static float read();

    /**
     * @brief Convierte el voltaje medido a valor de pH
     * 
     * @param voltage Voltaje medido del sensor de pH
     * @param tempC Temperatura del agua en grados Celsius para compensación
     * @return float Valor de pH (0-14)
     */
    static float convertVoltageToPH(float voltage, float tempC);
};

#endif // DEVICE_TYPE_ANALOGIC

#endif // PH_SENSOR_H

================
File: include/sensors/RTDSensor.h
================
#ifndef RTD_SENSOR_H
#define RTD_SENSOR_H

#include <Arduino.h>
#include "config.h"
#include "debug.h"
#include "MAX31865.h"

// Variable externa
extern MAX31865_RTD rtd;

/**
 * @brief Clase para manejar el sensor de temperatura RTD (PT100)
 */
class RTDSensor {
public:
    /**
     * @brief Lee la temperatura del sensor RTD (PT100)
     * 
     * @return float Temperatura en °C, o NAN si hay error
     */
    static float read();
};

#endif // RTD_SENSOR_H

================
File: include/sensors/SHT30Sensor.h
================
#ifndef SHT30_SENSOR_H
#define SHT30_SENSOR_H

#include <Arduino.h>
#include "config.h"
#include "debug.h"
#include <SensirionI2cSht3x.h>

// Variable externa
extern SensirionI2cSht3x sht30Sensor;

/**
 * @brief Clase para manejar el sensor de temperatura y humedad SHT30
 */
class SHT30Sensor {
public:
    /**
     * @brief Lee temperatura y humedad del sensor SHT30
     * 
     * @param outTemp Variable donde se almacenará la temperatura en °C
     * @param outHum Variable donde se almacenará la humedad relativa en %
     */
    static void read(float &outTemp, float &outHum);
};

#endif // SHT30_SENSOR_H

================
File: include/SleepManager.h
================
/*******************************************************************************************
 * Archivo: include/SleepManager.h
 * Descripción: Gestión del modo deep sleep para el ESP32.
 * Incluye funciones para configurar y entrar en modo de bajo consumo.
 *******************************************************************************************/

#ifndef SLEEP_MANAGER_H
#define SLEEP_MANAGER_H

#include <Arduino.h>
#include "esp_sleep.h"
#include "driver/gpio.h"
#include "PowerManager.h"
#include "clsPCA9555.h"
#include "config.h"
#include <RadioLib.h>
#include <SPI.h>
#include <Wire.h>

class SleepManager {
public:
    /**
     * @brief Configura y entra en modo deep sleep.
     * @param timeToSleep Tiempo en segundos para permanecer en deep sleep
     * @param powerManager Referencia al gestor de energía
     * @param ioExpander Referencia al expansor de I/O
     * @param radio Puntero al módulo de radio LoRa
     * @param node Referencia al nodo LoRaWAN para guardar sesión
     * @param LWsession Buffer para almacenar la sesión LoRaWAN
     * @param spi Referencia al objeto SPI
     */
    static void goToDeepSleep(uint32_t timeToSleep, 
                             PowerManager& powerManager,
                             PCA9555& ioExpander,
                             SX1262* radio,
                             LoRaWANNode& node,
                             uint8_t* LWsession,
                             SPIClass& spi);
    
    /**
     * @brief Configura los pines no utilizados en alta impedancia para reducir el consumo durante deep sleep.
     */
    static void configurePinsForDeepSleep();

    /**
     * @brief Libera el estado de retención (hold) de los pines que fueron configurados para deep sleep.
     * Esto permite que los pines puedan ser reconfigurados adecuadamente tras salir del deep sleep.
     */
    static void releaseHeldPins();
};

#endif // SLEEP_MANAGER_H

================
File: include/util/crc16.h
================
/**
@file
CRC Computations

@defgroup util_crc16 "util/crc16.h": CRC Computations
@code#include "util/crc16.h"@endcode

This header file provides functions for calculating
cyclic redundancy checks (CRC) using common polynomials.
Modified by Doc Walker to be processor-independent (removed inline
assembler to allow it to compile on SAM3X8E processors).

@par References:
Jack Crenshaw's "Implementing CRCs" article in the January 1992 issue of @e
Embedded @e Systems @e Programming. This may be difficult to find, but it
explains CRC's in very clear and concise terms. Well worth the effort to
obtain a copy.

*/
/* Copyright (c) 2002, 2003, 2004  Marek Michalkiewicz
   Copyright (c) 2005, 2007 Joerg Wunsch
   Copyright (c) 2013 Dave Hylands
   Copyright (c) 2013 Frederic Nadeau
   Copyright (c) 2015 Doc Walker
   All rights reserved.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are met:

   * Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.

   * Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.

   * Neither the name of the copyright holders nor the names of
     contributors may be used to endorse or promote products derived
     from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */


#ifndef _UTIL_CRC16_H_
#define _UTIL_CRC16_H_


/** @ingroup util_crc16
    Processor-independent CRC-16 calculation.

    Polynomial: x^16 + x^15 + x^2 + 1 (0xA001)<br>
    Initial value: 0xFFFF

    This CRC is normally used in disk-drive controllers.

    @param uint16_t crc (0x0000..0xFFFF)
    @param uint8_t a (0x00..0xFF)
    @return calculated CRC (0x0000..0xFFFF)
*/
static uint16_t crc16_update(uint16_t crc, uint8_t a)
{
  int i;

  crc ^= a;
  for (i = 0; i < 8; ++i)
  {
    if (crc & 1)
      crc = (crc >> 1) ^ 0xA001;
    else
      crc = (crc >> 1);
  }

  return crc;
}


#endif /* _UTIL_CRC16_H_ */

================
File: include/util/word.h
================
/**
@file
Utility Functions for Manipulating Words

@defgroup util_word "util/word.h": Utility Functions for Manipulating Words
@code#include "util/word.h"@endcode

This header file provides utility functions for manipulating words.

*/
/*

  word.h - Utility Functions for Manipulating Words

  This file is part of ModbusMaster.

  ModbusMaster is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  ModbusMaster is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with ModbusMaster.  If not, see <http://www.gnu.org/licenses/>.

  Written by Doc Walker (Rx)
  Copyright © 2009-2015 Doc Walker <4-20ma at wvfans dot net>

*/


#ifndef _UTIL_WORD_H_
#define _UTIL_WORD_H_


/** @ingroup util_word
    Return low word of a 32-bit integer.

    @param uint32_t ww (0x00000000..0xFFFFFFFF)
    @return low word of input (0x0000..0xFFFF)
*/
static inline uint16_t lowWord(uint32_t ww)
{
  return (uint16_t) ((ww) & 0xFFFF);
}


/** @ingroup util_word
    Return high word of a 32-bit integer.

    @param uint32_t ww (0x00000000..0xFFFFFFFF)
    @return high word of input (0x0000..0xFFFF)
*/
static inline uint16_t highWord(uint32_t ww)
{
  return (uint16_t) ((ww) >> 16);
}


#endif /* _UTIL_WORD_H_ */

================
File: lib/README
================
This directory is intended for project specific (private) libraries.
PlatformIO will compile them to static libraries and link into executable file.

The source code of each library should be placed in an own separate directory
("lib/your_library_name/[here are source files]").

For example, see a structure of the following two libraries `Foo` and `Bar`:

|--lib
|  |
|  |--Bar
|  |  |--docs
|  |  |--examples
|  |  |--src
|  |     |- Bar.c
|  |     |- Bar.h
|  |  |- library.json (optional, custom build options, etc) https://docs.platformio.org/page/librarymanager/config.html
|  |
|  |--Foo
|  |  |- Foo.c
|  |  |- Foo.h
|  |
|  |- README --> THIS FILE
|
|- platformio.ini
|--src
   |- main.c

and a contents of `src/main.c`:
```
#include <Foo.h>
#include <Bar.h>

int main (void)
{
  ...
}

```

PlatformIO Library Dependency Finder will find automatically dependent
libraries scanning project source files.

More information about PlatformIO Library Dependency Finder
- https://docs.platformio.org/page/librarymanager/ldf.html

================
File: src/AdcUtilities.cpp
================
#include "AdcUtilities.h"
#include "config_manager.h"
#include "debug.h"

#ifdef DEVICE_TYPE_ANALOGIC
#include "ADS124S08.h"
extern ADS124S08 ADC;

float AdcUtilities::measureAdcDifferential(uint8_t muxConfig)
{
    // Configurar MUX
    ADC.regWrite(INPMUX_ADDR_MASK, muxConfig);
    
    // Iniciar lectura
    uint8_t dummy1 = 0, dummy2 = 0;
    int32_t rawData = ADC.dataRead(&dummy1, &dummy2, &dummy2);
    if (rawData & 0x00800000) {
        // Extender signo si el bit 23 está en 1
        rawData |= 0xFF000000;
    }

    // Convertir a voltaje asumiendo referencia interna de 2.5V
    // ADC de 24 bits => rango ±2^23
    float voltage = (float)rawData / 8388608.0f * 2.5f;
    return voltage;
}

#endif // DEVICE_TYPE_ANALOGIC

================
File: src/ModbusMaster.cpp
================
/**
@file
Arduino library for communicating with Modbus slaves over RS232/485 (via RTU protocol).
*/
/*

  ModbusMaster.cpp - Arduino library for communicating with Modbus slaves
  over RS232/485 (via RTU protocol).

  Library:: ModbusMaster

  Copyright:: 2009-2016 Doc Walker

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

*/


/* _____PROJECT INCLUDES_____________________________________________________ */
#include "ModbusMaster.h"


/* _____GLOBAL VARIABLES_____________________________________________________ */


/* _____PUBLIC FUNCTIONS_____________________________________________________ */
/**
Constructor.

Creates class object; initialize it using ModbusMaster::begin().

@ingroup setup
*/
ModbusMaster::ModbusMaster(void)
{
  _idle = 0;
  _preTransmission = 0;
  _postTransmission = 0;
}

/**
Initialize class object.

Assigns the Modbus slave ID and serial port.
Call once class has been instantiated, typically within setup().

@param slave Modbus slave ID (1..255)
@param &serial reference to serial port object (Serial, Serial1, ... Serial3)
@ingroup setup
*/
void ModbusMaster::begin(uint8_t slave, Stream &serial)
{
//  txBuffer = (uint16_t*) calloc(ku8MaxBufferSize, sizeof(uint16_t));
  _u8MBSlave = slave;
  _serial = &serial;
  _u8TransmitBufferIndex = 0;
  u16TransmitBufferLength = 0;
  
#if __MODBUSMASTER_DEBUG__
  pinMode(__MODBUSMASTER_DEBUG_PIN_A__, OUTPUT);
  pinMode(__MODBUSMASTER_DEBUG_PIN_B__, OUTPUT);
#endif
}


void ModbusMaster::beginTransmission(uint16_t u16Address)
{
  _u16WriteAddress = u16Address;
  _u8TransmitBufferIndex = 0;
  u16TransmitBufferLength = 0;
}

// eliminate this function in favor of using existing MB request functions
uint8_t ModbusMaster::requestFrom(uint16_t address, uint16_t quantity)
{
  uint8_t read;
  // clamp to buffer length
  if (quantity > ku8MaxBufferSize)
  {
    quantity = ku8MaxBufferSize;
  }
  // set rx buffer iterator vars
  _u8ResponseBufferIndex = 0;
  _u8ResponseBufferLength = read;

  return read;
}


void ModbusMaster::sendBit(bool data)
{
  uint8_t txBitIndex = u16TransmitBufferLength % 16;
  if ((u16TransmitBufferLength >> 4) < ku8MaxBufferSize)
  {
    if (0 == txBitIndex)
    {
      _u16TransmitBuffer[_u8TransmitBufferIndex] = 0;
    }
    bitWrite(_u16TransmitBuffer[_u8TransmitBufferIndex], txBitIndex, data);
    u16TransmitBufferLength++;
    _u8TransmitBufferIndex = u16TransmitBufferLength >> 4;
  }
}


void ModbusMaster::send(uint16_t data)
{
  if (_u8TransmitBufferIndex < ku8MaxBufferSize)
  {
    _u16TransmitBuffer[_u8TransmitBufferIndex++] = data;
    u16TransmitBufferLength = _u8TransmitBufferIndex << 4;
  }
}


void ModbusMaster::send(uint32_t data)
{
  send(lowWord(data));
  send(highWord(data));
}


void ModbusMaster::send(uint8_t data)
{
  send(word(data));
}









uint8_t ModbusMaster::available(void)
{
  return _u8ResponseBufferLength - _u8ResponseBufferIndex;
}


uint16_t ModbusMaster::receive(void)
{
  if (_u8ResponseBufferIndex < _u8ResponseBufferLength)
  {
    return _u16ResponseBuffer[_u8ResponseBufferIndex++];
  }
  else
  {
    return 0xFFFF;
  }
}








/**
Set idle time callback function (cooperative multitasking).

This function gets called in the idle time between transmission of data
and response from slave. Do not call functions that read from the serial
buffer that is used by ModbusMaster. Use of i2c/TWI, 1-Wire, other
serial ports, etc. is permitted within callback function.

@see ModbusMaster::ModbusMasterTransaction()
*/
void ModbusMaster::idle(void (*idle)())
{
  _idle = idle;
}

/**
Set pre-transmission callback function.

This function gets called just before a Modbus message is sent over serial.
Typical usage of this callback is to enable an RS485 transceiver's
Driver Enable pin, and optionally disable its Receiver Enable pin.

@see ModbusMaster::ModbusMasterTransaction()
@see ModbusMaster::postTransmission()
*/
void ModbusMaster::preTransmission(void (*preTransmission)())
{
  _preTransmission = preTransmission;
}

/**
Set post-transmission callback function.

This function gets called after a Modbus message has finished sending
(i.e. after all data has been physically transmitted onto the serial
bus).

Typical usage of this callback is to enable an RS485 transceiver's
Receiver Enable pin, and disable its Driver Enable pin.

@see ModbusMaster::ModbusMasterTransaction()
@see ModbusMaster::preTransmission()
*/
void ModbusMaster::postTransmission(void (*postTransmission)())
{
  _postTransmission = postTransmission;
}


/**
Retrieve data from response buffer.

@see ModbusMaster::clearResponseBuffer()
@param u8Index index of response buffer array (0x00..0x3F)
@return value in position u8Index of response buffer (0x0000..0xFFFF)
@ingroup buffer
*/
uint16_t ModbusMaster::getResponseBuffer(uint8_t u8Index)
{
  if (u8Index < ku8MaxBufferSize)
  {
    return _u16ResponseBuffer[u8Index];
  }
  else
  {
    return 0xFFFF;
  }
}


/**
Clear Modbus response buffer.

@see ModbusMaster::getResponseBuffer(uint8_t u8Index)
@ingroup buffer
*/
void ModbusMaster::clearResponseBuffer()
{
  uint8_t i;
  
  for (i = 0; i < ku8MaxBufferSize; i++)
  {
    _u16ResponseBuffer[i] = 0;
  }
}


/**
Place data in transmit buffer.

@see ModbusMaster::clearTransmitBuffer()
@param u8Index index of transmit buffer array (0x00..0x3F)
@param u16Value value to place in position u8Index of transmit buffer (0x0000..0xFFFF)
@return 0 on success; exception number on failure
@ingroup buffer
*/
uint8_t ModbusMaster::setTransmitBuffer(uint8_t u8Index, uint16_t u16Value)
{
  if (u8Index < ku8MaxBufferSize)
  {
    _u16TransmitBuffer[u8Index] = u16Value;
    return ku8MBSuccess;
  }
  else
  {
    return ku8MBIllegalDataAddress;
  }
}


/**
Clear Modbus transmit buffer.

@see ModbusMaster::setTransmitBuffer(uint8_t u8Index, uint16_t u16Value)
@ingroup buffer
*/
void ModbusMaster::clearTransmitBuffer()
{
  uint8_t i;
  
  for (i = 0; i < ku8MaxBufferSize; i++)
  {
    _u16TransmitBuffer[i] = 0;
  }
}


/**
Modbus function 0x01 Read Coils.

This function code is used to read from 1 to 2000 contiguous status of 
coils in a remote device. The request specifies the starting address, 
i.e. the address of the first coil specified, and the number of coils. 
Coils are addressed starting at zero.

The coils in the response buffer are packed as one coil per bit of the 
data field. Status is indicated as 1=ON and 0=OFF. The LSB of the first 
data word contains the output addressed in the query. The other coils 
follow toward the high order end of this word and from low order to high 
order in subsequent words.

If the returned quantity is not a multiple of sixteen, the remaining 
bits in the final data word will be padded with zeros (toward the high 
order end of the word).

@param u16ReadAddress address of first coil (0x0000..0xFFFF)
@param u16BitQty quantity of coils to read (1..2000, enforced by remote device)
@return 0 on success; exception number on failure
@ingroup discrete
*/
uint8_t ModbusMaster::readCoils(uint16_t u16ReadAddress, uint16_t u16BitQty)
{
  _u16ReadAddress = u16ReadAddress;
  _u16ReadQty = u16BitQty;
  return ModbusMasterTransaction(ku8MBReadCoils);
}


/**
Modbus function 0x02 Read Discrete Inputs.

This function code is used to read from 1 to 2000 contiguous status of 
discrete inputs in a remote device. The request specifies the starting 
address, i.e. the address of the first input specified, and the number 
of inputs. Discrete inputs are addressed starting at zero.

The discrete inputs in the response buffer are packed as one input per 
bit of the data field. Status is indicated as 1=ON; 0=OFF. The LSB of 
the first data word contains the input addressed in the query. The other 
inputs follow toward the high order end of this word, and from low order 
to high order in subsequent words.

If the returned quantity is not a multiple of sixteen, the remaining 
bits in the final data word will be padded with zeros (toward the high 
order end of the word).

@param u16ReadAddress address of first discrete input (0x0000..0xFFFF)
@param u16BitQty quantity of discrete inputs to read (1..2000, enforced by remote device)
@return 0 on success; exception number on failure
@ingroup discrete
*/
uint8_t ModbusMaster::readDiscreteInputs(uint16_t u16ReadAddress,
  uint16_t u16BitQty)
{
  _u16ReadAddress = u16ReadAddress;
  _u16ReadQty = u16BitQty;
  return ModbusMasterTransaction(ku8MBReadDiscreteInputs);
}


/**
Modbus function 0x03 Read Holding Registers.

This function code is used to read the contents of a contiguous block of 
holding registers in a remote device. The request specifies the starting 
register address and the number of registers. Registers are addressed 
starting at zero.

The register data in the response buffer is packed as one word per 
register.

@param u16ReadAddress address of the first holding register (0x0000..0xFFFF)
@param u16ReadQty quantity of holding registers to read (1..125, enforced by remote device)
@return 0 on success; exception number on failure
@ingroup register
*/
uint8_t ModbusMaster::readHoldingRegisters(uint16_t u16ReadAddress,
  uint16_t u16ReadQty)
{
  _u16ReadAddress = u16ReadAddress;
  _u16ReadQty = u16ReadQty;
  return ModbusMasterTransaction(ku8MBReadHoldingRegisters);
}


/**
Modbus function 0x04 Read Input Registers.

This function code is used to read from 1 to 125 contiguous input 
registers in a remote device. The request specifies the starting 
register address and the number of registers. Registers are addressed 
starting at zero.

The register data in the response buffer is packed as one word per 
register.

@param u16ReadAddress address of the first input register (0x0000..0xFFFF)
@param u16ReadQty quantity of input registers to read (1..125, enforced by remote device)
@return 0 on success; exception number on failure
@ingroup register
*/
uint8_t ModbusMaster::readInputRegisters(uint16_t u16ReadAddress,
  uint8_t u16ReadQty)
{
  _u16ReadAddress = u16ReadAddress;
  _u16ReadQty = u16ReadQty;
  return ModbusMasterTransaction(ku8MBReadInputRegisters);
}


/**
Modbus function 0x05 Write Single Coil.

This function code is used to write a single output to either ON or OFF 
in a remote device. The requested ON/OFF state is specified by a 
constant in the state field. A non-zero value requests the output to be 
ON and a value of 0 requests it to be OFF. The request specifies the 
address of the coil to be forced. Coils are addressed starting at zero.

@param u16WriteAddress address of the coil (0x0000..0xFFFF)
@param u8State 0=OFF, non-zero=ON (0x00..0xFF)
@return 0 on success; exception number on failure
@ingroup discrete
*/
uint8_t ModbusMaster::writeSingleCoil(uint16_t u16WriteAddress, uint8_t u8State)
{
  _u16WriteAddress = u16WriteAddress;
  _u16WriteQty = (u8State ? 0xFF00 : 0x0000);
  return ModbusMasterTransaction(ku8MBWriteSingleCoil);
}


/**
Modbus function 0x06 Write Single Register.

This function code is used to write a single holding register in a 
remote device. The request specifies the address of the register to be 
written. Registers are addressed starting at zero.

@param u16WriteAddress address of the holding register (0x0000..0xFFFF)
@param u16WriteValue value to be written to holding register (0x0000..0xFFFF)
@return 0 on success; exception number on failure
@ingroup register
*/
uint8_t ModbusMaster::writeSingleRegister(uint16_t u16WriteAddress,
  uint16_t u16WriteValue)
{
  _u16WriteAddress = u16WriteAddress;
  _u16WriteQty = 0;
  _u16TransmitBuffer[0] = u16WriteValue;
  return ModbusMasterTransaction(ku8MBWriteSingleRegister);
}


/**
Modbus function 0x0F Write Multiple Coils.

This function code is used to force each coil in a sequence of coils to 
either ON or OFF in a remote device. The request specifies the coil 
references to be forced. Coils are addressed starting at zero.

The requested ON/OFF states are specified by contents of the transmit 
buffer. A logical '1' in a bit position of the buffer requests the 
corresponding output to be ON. A logical '0' requests it to be OFF.

@param u16WriteAddress address of the first coil (0x0000..0xFFFF)
@param u16BitQty quantity of coils to write (1..2000, enforced by remote device)
@return 0 on success; exception number on failure
@ingroup discrete
*/
uint8_t ModbusMaster::writeMultipleCoils(uint16_t u16WriteAddress,
  uint16_t u16BitQty)
{
  _u16WriteAddress = u16WriteAddress;
  _u16WriteQty = u16BitQty;
  return ModbusMasterTransaction(ku8MBWriteMultipleCoils);
}
uint8_t ModbusMaster::writeMultipleCoils()
{
  _u16WriteQty = u16TransmitBufferLength;
  return ModbusMasterTransaction(ku8MBWriteMultipleCoils);
}


/**
Modbus function 0x10 Write Multiple Registers.

This function code is used to write a block of contiguous registers (1 
to 123 registers) in a remote device.

The requested written values are specified in the transmit buffer. Data 
is packed as one word per register.

@param u16WriteAddress address of the holding register (0x0000..0xFFFF)
@param u16WriteQty quantity of holding registers to write (1..123, enforced by remote device)
@return 0 on success; exception number on failure
@ingroup register
*/
uint8_t ModbusMaster::writeMultipleRegisters(uint16_t u16WriteAddress,
  uint16_t u16WriteQty)
{
  _u16WriteAddress = u16WriteAddress;
  _u16WriteQty = u16WriteQty;
  return ModbusMasterTransaction(ku8MBWriteMultipleRegisters);
}

// new version based on Wire.h
uint8_t ModbusMaster::writeMultipleRegisters()
{
  _u16WriteQty = _u8TransmitBufferIndex;
  return ModbusMasterTransaction(ku8MBWriteMultipleRegisters);
}


/**
Modbus function 0x16 Mask Write Register.

This function code is used to modify the contents of a specified holding 
register using a combination of an AND mask, an OR mask, and the 
register's current contents. The function can be used to set or clear 
individual bits in the register.

The request specifies the holding register to be written, the data to be 
used as the AND mask, and the data to be used as the OR mask. Registers 
are addressed starting at zero.

The function's algorithm is:

Result = (Current Contents && And_Mask) || (Or_Mask && (~And_Mask))

@param u16WriteAddress address of the holding register (0x0000..0xFFFF)
@param u16AndMask AND mask (0x0000..0xFFFF)
@param u16OrMask OR mask (0x0000..0xFFFF)
@return 0 on success; exception number on failure
@ingroup register
*/
uint8_t ModbusMaster::maskWriteRegister(uint16_t u16WriteAddress,
  uint16_t u16AndMask, uint16_t u16OrMask)
{
  _u16WriteAddress = u16WriteAddress;
  _u16TransmitBuffer[0] = u16AndMask;
  _u16TransmitBuffer[1] = u16OrMask;
  return ModbusMasterTransaction(ku8MBMaskWriteRegister);
}


/**
Modbus function 0x17 Read Write Multiple Registers.

This function code performs a combination of one read operation and one 
write operation in a single MODBUS transaction. The write operation is 
performed before the read. Holding registers are addressed starting at 
zero.

The request specifies the starting address and number of holding 
registers to be read as well as the starting address, and the number of 
holding registers. The data to be written is specified in the transmit 
buffer.

@param u16ReadAddress address of the first holding register (0x0000..0xFFFF)
@param u16ReadQty quantity of holding registers to read (1..125, enforced by remote device)
@param u16WriteAddress address of the first holding register (0x0000..0xFFFF)
@param u16WriteQty quantity of holding registers to write (1..121, enforced by remote device)
@return 0 on success; exception number on failure
@ingroup register
*/
uint8_t ModbusMaster::readWriteMultipleRegisters(uint16_t u16ReadAddress,
  uint16_t u16ReadQty, uint16_t u16WriteAddress, uint16_t u16WriteQty)
{
  _u16ReadAddress = u16ReadAddress;
  _u16ReadQty = u16ReadQty;
  _u16WriteAddress = u16WriteAddress;
  _u16WriteQty = u16WriteQty;
  return ModbusMasterTransaction(ku8MBReadWriteMultipleRegisters);
}
uint8_t ModbusMaster::readWriteMultipleRegisters(uint16_t u16ReadAddress,
  uint16_t u16ReadQty)
{
  _u16ReadAddress = u16ReadAddress;
  _u16ReadQty = u16ReadQty;
  _u16WriteQty = _u8TransmitBufferIndex;
  return ModbusMasterTransaction(ku8MBReadWriteMultipleRegisters);
}


/* _____PRIVATE FUNCTIONS____________________________________________________ */
/**
Modbus transaction engine.
Sequence:
  - assemble Modbus Request Application Data Unit (ADU),
    based on particular function called
  - transmit request over selected serial port
  - wait for/retrieve response
  - evaluate/disassemble response
  - return status (success/exception)

@param u8MBFunction Modbus function (0x01..0xFF)
@return 0 on success; exception number on failure
*/
uint8_t ModbusMaster::ModbusMasterTransaction(uint8_t u8MBFunction)
{
  uint8_t u8ModbusADU[256];
  uint8_t u8ModbusADUSize = 0;
  uint8_t i, u8Qty;
  uint16_t u16CRC;
  uint32_t u32StartTime;
  uint8_t u8BytesLeft = 8;
  uint8_t u8MBStatus = ku8MBSuccess;
  
  // assemble Modbus Request Application Data Unit
  u8ModbusADU[u8ModbusADUSize++] = _u8MBSlave;
  u8ModbusADU[u8ModbusADUSize++] = u8MBFunction;
  
  switch(u8MBFunction)
  {
    case ku8MBReadCoils:
    case ku8MBReadDiscreteInputs:
    case ku8MBReadInputRegisters:
    case ku8MBReadHoldingRegisters:
    case ku8MBReadWriteMultipleRegisters:
      u8ModbusADU[u8ModbusADUSize++] = highByte(_u16ReadAddress);
      u8ModbusADU[u8ModbusADUSize++] = lowByte(_u16ReadAddress);
      u8ModbusADU[u8ModbusADUSize++] = highByte(_u16ReadQty);
      u8ModbusADU[u8ModbusADUSize++] = lowByte(_u16ReadQty);
      break;
  }
  
  switch(u8MBFunction)
  {
    case ku8MBWriteSingleCoil:
    case ku8MBMaskWriteRegister:
    case ku8MBWriteMultipleCoils:
    case ku8MBWriteSingleRegister:
    case ku8MBWriteMultipleRegisters:
    case ku8MBReadWriteMultipleRegisters:
      u8ModbusADU[u8ModbusADUSize++] = highByte(_u16WriteAddress);
      u8ModbusADU[u8ModbusADUSize++] = lowByte(_u16WriteAddress);
      break;
  }
  
  switch(u8MBFunction)
  {
    case ku8MBWriteSingleCoil:
      u8ModbusADU[u8ModbusADUSize++] = highByte(_u16WriteQty);
      u8ModbusADU[u8ModbusADUSize++] = lowByte(_u16WriteQty);
      break;
      
    case ku8MBWriteSingleRegister:
      u8ModbusADU[u8ModbusADUSize++] = highByte(_u16TransmitBuffer[0]);
      u8ModbusADU[u8ModbusADUSize++] = lowByte(_u16TransmitBuffer[0]);
      break;
      
    case ku8MBWriteMultipleCoils:
      u8ModbusADU[u8ModbusADUSize++] = highByte(_u16WriteQty);
      u8ModbusADU[u8ModbusADUSize++] = lowByte(_u16WriteQty);
      u8Qty = (_u16WriteQty % 8) ? ((_u16WriteQty >> 3) + 1) : (_u16WriteQty >> 3);
      u8ModbusADU[u8ModbusADUSize++] = u8Qty;
      for (i = 0; i < u8Qty; i++)
      {
        switch(i % 2)
        {
          case 0: // i is even
            u8ModbusADU[u8ModbusADUSize++] = lowByte(_u16TransmitBuffer[i >> 1]);
            break;
            
          case 1: // i is odd
            u8ModbusADU[u8ModbusADUSize++] = highByte(_u16TransmitBuffer[i >> 1]);
            break;
        }
      }
      break;
      
    case ku8MBWriteMultipleRegisters:
    case ku8MBReadWriteMultipleRegisters:
      u8ModbusADU[u8ModbusADUSize++] = highByte(_u16WriteQty);
      u8ModbusADU[u8ModbusADUSize++] = lowByte(_u16WriteQty);
      u8ModbusADU[u8ModbusADUSize++] = lowByte(_u16WriteQty << 1);
      
      for (i = 0; i < lowByte(_u16WriteQty); i++)
      {
        u8ModbusADU[u8ModbusADUSize++] = highByte(_u16TransmitBuffer[i]);
        u8ModbusADU[u8ModbusADUSize++] = lowByte(_u16TransmitBuffer[i]);
      }
      break;
      
    case ku8MBMaskWriteRegister:
      u8ModbusADU[u8ModbusADUSize++] = highByte(_u16TransmitBuffer[0]);
      u8ModbusADU[u8ModbusADUSize++] = lowByte(_u16TransmitBuffer[0]);
      u8ModbusADU[u8ModbusADUSize++] = highByte(_u16TransmitBuffer[1]);
      u8ModbusADU[u8ModbusADUSize++] = lowByte(_u16TransmitBuffer[1]);
      break;
  }
  
  // append CRC
  u16CRC = 0xFFFF;
  for (i = 0; i < u8ModbusADUSize; i++)
  {
    u16CRC = crc16_update(u16CRC, u8ModbusADU[i]);
  }
  u8ModbusADU[u8ModbusADUSize++] = lowByte(u16CRC);
  u8ModbusADU[u8ModbusADUSize++] = highByte(u16CRC);
  u8ModbusADU[u8ModbusADUSize] = 0;

  // flush receive buffer before transmitting request
  while (_serial->read() != -1);

  // transmit request
  if (_preTransmission)
  {
    _preTransmission();
  }
  for (i = 0; i < u8ModbusADUSize; i++)
  {
    _serial->write(u8ModbusADU[i]);
  }
  
  u8ModbusADUSize = 0;
  _serial->flush();    // flush transmit buffer
  if (_postTransmission)
  {
    _postTransmission();
  }
  
  // loop until we run out of time or bytes, or an error occurs
  u32StartTime = millis();
  while (u8BytesLeft && !u8MBStatus)
  {
    if (_serial->available())
    {
#if __MODBUSMASTER_DEBUG__
      digitalWrite(__MODBUSMASTER_DEBUG_PIN_A__, true);
#endif
      u8ModbusADU[u8ModbusADUSize++] = _serial->read();
      u8BytesLeft--;
#if __MODBUSMASTER_DEBUG__
      digitalWrite(__MODBUSMASTER_DEBUG_PIN_A__, false);
#endif
    }
    else
    {
#if __MODBUSMASTER_DEBUG__
      digitalWrite(__MODBUSMASTER_DEBUG_PIN_B__, true);
#endif
      if (_idle)
      {
        _idle();
      }
#if __MODBUSMASTER_DEBUG__
      digitalWrite(__MODBUSMASTER_DEBUG_PIN_B__, false);
#endif
    }
    
    // evaluate slave ID, function code once enough bytes have been read
    if (u8ModbusADUSize == 5)
    {
      // verify response is for correct Modbus slave
      if (u8ModbusADU[0] != _u8MBSlave)
      {
        u8MBStatus = ku8MBInvalidSlaveID;
        break;
      }
      
      // verify response is for correct Modbus function code (mask exception bit 7)
      if ((u8ModbusADU[1] & 0x7F) != u8MBFunction)
      {
        u8MBStatus = ku8MBInvalidFunction;
        break;
      }
      
      // check whether Modbus exception occurred; return Modbus Exception Code
      if (bitRead(u8ModbusADU[1], 7))
      {
        u8MBStatus = u8ModbusADU[2];
        break;
      }
      
      // evaluate returned Modbus function code
      switch(u8ModbusADU[1])
      {
        case ku8MBReadCoils:
        case ku8MBReadDiscreteInputs:
        case ku8MBReadInputRegisters:
        case ku8MBReadHoldingRegisters:
        case ku8MBReadWriteMultipleRegisters:
          u8BytesLeft = u8ModbusADU[2];
          break;
          
        case ku8MBWriteSingleCoil:
        case ku8MBWriteMultipleCoils:
        case ku8MBWriteSingleRegister:
        case ku8MBWriteMultipleRegisters:
          u8BytesLeft = 3;
          break;
          
        case ku8MBMaskWriteRegister:
          u8BytesLeft = 5;
          break;
      }
    }
    if ((millis() - u32StartTime) > ku16MBResponseTimeout)
    {
      u8MBStatus = ku8MBResponseTimedOut;
    }
  }
  
  // verify response is large enough to inspect further
  if (!u8MBStatus && u8ModbusADUSize >= 5)
  {
    // calculate CRC
    u16CRC = 0xFFFF;
    for (i = 0; i < (u8ModbusADUSize - 2); i++)
    {
      u16CRC = crc16_update(u16CRC, u8ModbusADU[i]);
    }
    
    // verify CRC
    if (!u8MBStatus && (lowByte(u16CRC) != u8ModbusADU[u8ModbusADUSize - 2] ||
      highByte(u16CRC) != u8ModbusADU[u8ModbusADUSize - 1]))
    {
      u8MBStatus = ku8MBInvalidCRC;
    }
  }

  // disassemble ADU into words
  if (!u8MBStatus)
  {
    // evaluate returned Modbus function code
    switch(u8ModbusADU[1])
    {
      case ku8MBReadCoils:
      case ku8MBReadDiscreteInputs:
        // load bytes into word; response bytes are ordered L, H, L, H, ...
        for (i = 0; i < (u8ModbusADU[2] >> 1); i++)
        {
          if (i < ku8MaxBufferSize)
          {
            _u16ResponseBuffer[i] = word(u8ModbusADU[2 * i + 4], u8ModbusADU[2 * i + 3]);
          }
          
          _u8ResponseBufferLength = i;
        }
        
        // in the event of an odd number of bytes, load last byte into zero-padded word
        if (u8ModbusADU[2] % 2)
        {
          if (i < ku8MaxBufferSize)
          {
            _u16ResponseBuffer[i] = word(0, u8ModbusADU[2 * i + 3]);
          }
          
          _u8ResponseBufferLength = i + 1;
        }
        break;
        
      case ku8MBReadInputRegisters:
      case ku8MBReadHoldingRegisters:
      case ku8MBReadWriteMultipleRegisters:
        // load bytes into word; response bytes are ordered H, L, H, L, ...
        for (i = 0; i < (u8ModbusADU[2] >> 1); i++)
        {
          if (i < ku8MaxBufferSize)
          {
            _u16ResponseBuffer[i] = word(u8ModbusADU[2 * i + 3], u8ModbusADU[2 * i + 4]);
          }
          
          _u8ResponseBufferLength = i;
        }
        break;
    }
  }
  
  _u8TransmitBufferIndex = 0;
  u16TransmitBufferLength = 0;
  _u8ResponseBufferIndex = 0;
  return u8MBStatus;
}

================
File: src/sensors/BatterySensor.cpp
================
#include "sensors/BatterySensor.h"

#ifdef DEVICE_TYPE_ANALOGIC
#include "ADS124S08.h"
#include "AdcUtilities.h"
extern ADS124S08 ADC;
#endif

/**
 * @brief Lee el voltaje de la batería
 * 
 * @return float Voltaje de la batería en voltios, o NAN si hay error
 */
float BatterySensor::readVoltage() {
#ifdef DEVICE_TYPE_ANALOGIC
    // En DEVICE_TYPE_ANALOGIC, usamos el ADC externo para mayor precisión
    // Configurar el multiplexor para leer AIN9 con referencia a AINCOM (tierra)
    uint8_t muxConfig = ADS_P_AIN9 | ADS_N_AINCOM;
    
    // Asegurarse de que el ADC esté despierto
    ADC.sendCommand(WAKE_OPCODE_MASK);
    
    // Leer voltaje diferencial entre AIN9 y COMMON
    float voltage = AdcUtilities::measureAdcDifferential(muxConfig);
#else
    // Configurar la resolución del ADC a 12 bits
    analogReadResolution(12);
    
    // En otros tipos de dispositivo, usar BATTERY_PIN
    int reading = analogRead(BATTERY_PIN);
    
    // Verificar lectura válida
    if (reading < 0) {
        return NAN;
    }

    // Convertir la lectura del ADC a voltaje (para ADC de 12 bits, la máxima lectura es 4095)
    float voltage = (reading / 4095.0f) * 3.3f;
#endif

    // Calcular el voltaje real de la batería
    float batteryVoltage = calculateBatteryVoltage(voltage);
    return batteryVoltage;
}

/**
 * @brief Calcula el voltaje real de la batería a partir de la lectura del ADC
 * 
 * En config.h, las constantes están definidas como:
 * const double R1 = 470000.0;  // Resistencia conectada a GND
 * const double R2 = 1500000.0; // Resistencia conectada a la batería
 * 
 * @param adcVoltage Voltaje medido por el ADC
 * @return float Voltaje real de la batería
 */
float BatterySensor::calculateBatteryVoltage(float adcVoltage) {
    // Usando las constantes definidas en config.h
    // El voltaje de la batería se calcula como:
    // V_bat = V_adc * (R1 + R2) / R1
    return adcVoltage * ((R1 + R2) / R1);
}

================
File: src/sensors/DS18B20Sensor.cpp
================
#include "sensors/DS18B20Sensor.h"

#if defined(DEVICE_TYPE_BASIC) || defined(DEVICE_TYPE_ANALOGIC)

/**
 * @brief Lee la temperatura del sensor DS18B20
 * 
 * @return float Temperatura en °C, o NAN si hay error
 */
float DS18B20Sensor::read() {
    dallasTemp.requestTemperatures();
    float temp = dallasTemp.getTempCByIndex(0);
    if (temp == DEVICE_DISCONNECTED_C) {
        return NAN;
    }
    return temp;
}

#endif // defined(DEVICE_TYPE_BASIC) || defined(DEVICE_TYPE_ANALOGIC)

================
File: src/sensors/NtcManager.cpp
================
#include "sensors/NtcManager.h"
#include <cmath>  // Para fabs() y otras funciones matemáticas
#include "config_manager.h"
#include "debug.h"
#include "config.h"  // Para acceder a NTC_TEMP_MIN y NTC_TEMP_MAX

#ifdef DEVICE_TYPE_ANALOGIC
#include "ADS124S08.h"
#include "AdcUtilities.h"
extern ADS124S08 ADC;

void NtcManager::calculateSteinhartHartCoeffs(double T1, double R1,
                                          double T2, double R2,
                                          double T3, double R3,
                                          double &A, double &B, double &C) 
{
    // Ecuación de Steinhart-Hart:
    // 1/T = A + B*ln(R) + C*(ln(R))^3
    
    double L1 = log(R1);
    double L2 = log(R2);
    double L3 = log(R3);
    
    double Y1 = 1.0 / T1;
    double Y2 = 1.0 / T2;
    double Y3 = 1.0 / T3;
    
    // Resolver sistema de ecuaciones para encontrar A, B, C
    double L1_3 = L1 * L1 * L1;
    double L2_3 = L2 * L2 * L2;
    double L3_3 = L3 * L3 * L3;
    
    double denominator = (L2 - L1) * (L3 - L1) * (L3 - L2);
    
    // Protección contra división por cero
    if (fabs(denominator) < 1e-10) {
        // Asignar NAN para indicar claramente el error
        A = NAN;
        B = NAN;
        C = NAN;
        return;
    }
    
    // Calcular C
    C = ((Y2 - Y1) * (L3 - L1) - (Y3 - Y1) * (L2 - L1)) / 
        ((L2_3 - L1_3) * (L3 - L1) - (L3_3 - L1_3) * (L2 - L1));
    
    // Calcular B
    B = ((Y2 - Y1) - C * (L2_3 - L1_3)) / (L2 - L1);
    
    // Calcular A
    A = Y1 - B * L1 - C * L1_3;
}

double NtcManager::steinhartHartTemperature(double resistance, double A, double B, double C) 
{
    if (resistance <= 0.0) {
        return NAN;
    }
    double lnR = log(resistance);
    double invT = A + B * lnR + C * lnR*lnR*lnR;  // 1/T en Kelvin^-1
    double tempK = 1.0 / invT;                   // Kelvin
    double tempC = tempK - 273.15;               // °C
    return tempC;
}

double NtcManager::computeNtcResistanceFromBridge(double diffVoltage)
{
    // La rama de referencia es 1.25 V. 
    // diffVoltage = (Vneg - 1.25)
    
    // Corregimos la interpretación del voltaje diferencial:
    // Para NTC, cuando la temperatura aumenta, la resistencia disminuye y el voltaje Vneg aumenta
    // Por lo tanto, diffVoltage aumenta con la temperatura
    
    // Vneg = diffVoltage + 1.25
    double Vneg = diffVoltage + 1.25;
    
    // Validación de rangos
    if (Vneg <= 0.0 || Vneg >= 2.5) {
        return -1.0;  // Indica valor inválido
    }
    
    // Fórmula corregida: Si Vneg aumenta (mayor temperatura), Rntc debe disminuir
    double Rntc = 100000.0 * ((2.5 - Vneg) / Vneg);
    
    return Rntc;
}

double NtcManager::computeNtcResistanceFromVoltageDivider(double voltage, double vRef, double rFixed, bool ntcTop)
{
    // Validación de rangos
    if (voltage <= 0.0 || voltage >= vRef) {
        return -1.0;  // Indica valor inválido
    }
    
    // Calcular resistencia del NTC
    double Rntc;
    
    if (ntcTop) {
        // NTC conectado a Vref (arriba) y resistencia fija a GND (abajo)
        // Fórmula: Rntc = rFixed * (vRef - voltage) / voltage
        Rntc = rFixed * ((vRef - voltage) / voltage);
    } else {
        // NTC conectado a GND (abajo) y resistencia fija a Vref (arriba)
        // Fórmula: Rntc = rFixed * voltage / (vRef - voltage)
        Rntc = rFixed * (voltage / (vRef - voltage));
    }
    
    return Rntc;
}

double NtcManager::readNtc100kTemperature(const char* configKey) {
    // Obtener calibración NTC100K de la configuración
    double t1=25.0, r1=100000.0, t2=35.0, r2=64770.0, t3=45.0, r3=42530.0;
    ConfigManager::getNTC100KConfig(t1, r1, t2, r2, t3, r3);

    // Pasar °C a Kelvin
    double T1K = t1 + 273.15;
    double T2K = t2 + 273.15;
    double T3K = t3 + 273.15;

    // Calcular coeficientes Steinhart-Hart
    double A=0, B=0, C=0;
    calculateSteinhartHartCoeffs(T1K, r1, T2K, r2, T3K, r3, A, B, C);
    
    // Elegir canal según sensorId: "NTC1" => AIN1+/AIN0-, "NTC2" => AIN3+/AIN2-
    uint8_t muxConfig = 0; 
    if (strcmp(configKey, "0") == 0) {
        muxConfig = ADS_P_AIN1 | ADS_N_AIN0;  // AIN1+ / AIN0-
    } else if (strcmp(configKey, "1") == 0) {
        muxConfig = ADS_P_AIN3 | ADS_N_AIN2;  // AIN3+ / AIN2-
    } else {
        // Si no coincide con "NTC1" ni "NTC2", retornamos NAN
        return NAN;
    }

    // Medir voltaje diferencial
    float diffVoltage = AdcUtilities::measureAdcDifferential(muxConfig);
    if (isnan(diffVoltage)) {
        return NAN;
    }

    // Calcular la resistencia NTC en ohms
    double Rntc = computeNtcResistanceFromBridge(diffVoltage);
    if (Rntc <= 0.0) {
        return NAN;
    }

    // Usar Steinhart-Hart para calcular la temperatura en °C
    double tempC = steinhartHartTemperature(Rntc, A, B, C);
    
    // Validar que el valor de temperatura está dentro de los límites aceptables
    if (isnan(tempC) || tempC < NTC_TEMP_MIN || tempC > NTC_TEMP_MAX) {
        return NAN;
    }
    
    return tempC;
}

double NtcManager::readNtc10kTemperature() {
    // Obtener calibración NTC10K de la configuración
    // Usando valores por defecto para un NTC10K común
    double t1=25.0, r1=10000.0, t2=50.0, r2=3893.0, t3=85.0, r3=1218.0;
    ConfigManager::getNTC10KConfig(t1, r1, t2, r2, t3, r3);

    // Pasar °C a Kelvin
    double T1K = t1 + 273.15;
    double T2K = t2 + 273.15;
    double T3K = t3 + 273.15;

    // Calcular coeficientes Steinhart-Hart
    double A=0, B=0, C=0;
    calculateSteinhartHartCoeffs(T1K, r1, T2K, r2, T3K, r3, A, B, C);

    // NTC3 está en el canal AIN11 con AINCOM
    uint8_t muxConfig = ADS_P_AIN11 | ADS_N_AIN8;
    
    // Medir voltaje single-ended
    float voltage = AdcUtilities::measureAdcDifferential(muxConfig);
    if (isnan(voltage)) {
        return NAN;
    }

    // Calcular la resistencia NTC
    // El NTC en NTC3 está conectado entre 2.5V y el punto medio con resistencia de 10k a GND
    double vRef = 2.5; // Voltaje de referencia
    double rFixed = 10000.0; // Resistencia fija (10k)
    bool ntcTop = true; // NTC está conectado a Vref (arriba)
    
    double Rntc = computeNtcResistanceFromVoltageDivider(voltage, vRef, rFixed, ntcTop);
    if (Rntc <= 0.0) {
        return NAN;
    }

    // Usar Steinhart-Hart para calcular la temperatura en °C
    double tempC = steinhartHartTemperature(Rntc, A, B, C);
    
    // Validar que el valor de temperatura está dentro de los límites aceptables
    if (isnan(tempC) || tempC < NTC_TEMP_MIN || tempC > NTC_TEMP_MAX) {
        return NAN;
    }
    
    return tempC;
}

#endif // DEVICE_TYPE_ANALOGIC

================
File: src/sensors/RTDSensor.cpp
================
#include "sensors/RTDSensor.h"

/**
 * @brief Lee la temperatura del sensor RTD (PT100)
 * 
 * @return float Temperatura en °C, o NAN si hay error
 */
float RTDSensor::read() {
    uint8_t status = rtd.read_all();
    if (status == 0) {
        return rtd.temperature();
    } else {
        return NAN;
    }
}

================
File: src/sensors/SHT30Sensor.cpp
================
#include "sensors/SHT30Sensor.h"

/**
 * @brief Lee temperatura y humedad del sensor SHT30
 * 
 * @param outTemp Variable donde se almacenará la temperatura en °C
 * @param outHum Variable donde se almacenará la humedad relativa en %
 */
void SHT30Sensor::read(float &outTemp, float &outHum) {
    float temperature = 0.0f;
    float humidity = 0.0f;

    int16_t error = sht30Sensor.measureSingleShot(REPEATABILITY_HIGH, false, temperature, humidity);
    delay(20);
    if (error != NO_ERROR) {
        outTemp = NAN;
        outHum = NAN;
        return;
    }
    outTemp = temperature;
    outHum = humidity;
}

================
File: test/README
================
This directory is intended for PlatformIO Test Runner and project tests.

Unit Testing is a software testing method by which individual units of
source code, sets of one or more MCU program modules together with associated
control data, usage procedures, and operating procedures, are tested to
determine whether they are fit for use. Unit testing finds problems early
in the development cycle.

More information about PlatformIO Unit Testing:
- https://docs.platformio.org/en/latest/advanced/unit-testing/index.html

================
File: include/ADS124S08.h
================
/* --COPYRIGHT--,BSD
 * Copyright (c) 2016, Texas Instruments Incorporated
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * --/COPYRIGHT--*/
/*
 * ADS124S08.h
 *
 */
#ifndef ADS124S08_H_
#define ADS124S08_H_

#include <SPI.h>
#include "clsPCA9555.h"
#include "config.h"

#ifdef DEVICE_TYPE_ANALOGIC

/* Start definitions */
#define NUM_REGISTERS 18
/*
 * Address masks used for register addressing with
 * either a REGRD of REGWR mask
 *
 */
#define ID_ADDR_MASK		0x00
#define STATUS_ADDR_MASK	0x01
#define INPMUX_ADDR_MASK	0x02
#define PGA_ADDR_MASK		0x03
#define DATARATE_ADDR_MASK	0x04
#define REF_ADDR_MASK		0x05
#define IDACMAG_ADDR_MASK	0x06
#define IDACMUX_ADDR_MASK	0x07
#define VBIAS_ADDR_MASK		0x08
#define SYS_ADDR_MASK		0x09
#define OFCAL0_ADDR_MASK	0x0A
#define OFCAL1_ADDR_MASK	0x0B
#define OFCAL2_ADDR_MASK	0x0C
#define FSCAL0_ADDR_MASK	0x0D
#define FSCAL1_ADDR_MASK	0x0E
#define FSCAL2_ADDR_MASK	0x0F
#define GPIODAT_ADDR_MASK	0x10
#define GPIOCON_ADDR_MASK	0x11

/* Opcode masks (or "Commands" if you will...) */
#define NOP_OPCODE_MASK		0x00
#define WAKE_OPCODE_MASK	0x02
#define SLEEP_OPCODE_MASK	0x04
#define RESET_OPCODE_MASK	0x06
#define START_OPCODE_MASK	0x08
#define STOP_OPCODE_MASK	0x0A
#define SFOCAL_OPCODE_MASK	0x19
#define SYOCAL_OPCODE_MASK	0x16
#define SYGCAL_OPCODE_MASK	0x17
#define RDATA_OPCODE_MASK	0x12
#define REGRD_OPCODE_MASK	0x20
#define REGWR_OPCODE_MASK	0x40

/* Register sub masks */
/* ADS124S08 Register 0 (ID) Definition
 *   Bit 7   |   Bit 6   |   Bit 5   |   Bit 4   |   Bit 3   |   Bit 2   |   Bit 1   |   Bit 0
 *--------------------------------------------------------------------------------------------
 *        			RESERVED[4:0]      			 			 |  	      DEV_ID[2:0]
 *
 */
/* Define ID (revision) */
#define ADS_ID_A				0x00
#define ADS_ID_B				0x80
/* Define VER (device version) */
#define ADS_124S08				0x00
#define ADS_124S06				0x01
#define ADS_114S08				0x04
#define ADS_114S06				0x05
/* ADS124S08 Register 1 (STATUS) Definition */
/*   Bit 7   |   Bit 6   |   Bit 5   |   Bit 4   |   Bit 3   |   Bit 2   |   Bit 1   |   Bit 0
 *--------------------------------------------------------------------------------------------
 *   FL_POR  |    nRDY   | FL_P_RAILP| FL_P_RAILN| FL_N_RAILP| FL_N_RAILN| FL_REF_L1 | FL_REF_L0
 *
 */
#define ADS_FL_POR				0x80
#define ADS_RDY					0x40
#define ADS_FL_P_RAILP			0x20
#define ADS_FL_P_RAILN			0x10
#define ADS_FL_N_RAILP			0x08
#define ADS_FL_N_RAILN			0x04
#define ADS_FL_REF_L1			0x02
#define ADS_FL_REF_L0			0x10
/* ADS124S08 Register 2 (INPMUX) Definition */
/*   Bit 7   |   Bit 6   |   Bit 5   |   Bit 4   |   Bit 3   |   Bit 2   |   Bit 1   |   Bit 0
 *--------------------------------------------------------------------------------------------
 *         			MUXP[3:0]   				 |       			MUXN[3:0]
 *
 */
/* Define the ADC positive input channels (MUXP) */
#define ADS_P_AIN0				0x00
#define ADS_P_AIN1				0x10
#define ADS_P_AIN2				0x20
#define ADS_P_AIN3				0x30
#define ADS_P_AIN4				0x40
#define ADS_P_AIN5				0x50
#define ADS_P_AIN6				0x60
#define ADS_P_AIN7				0x70
#define ADS_P_AIN8				0x80
#define ADS_P_AIN9				0x90
#define ADS_P_AIN10				0xA0
#define ADS_P_AIN11				0xB0
#define ADS_P_AINCOM			0xC0
/* Define the ADC negative input channels (MUXN)*/
#define ADS_N_AIN0				0x00
#define ADS_N_AIN1				0x01
#define ADS_N_AIN2				0x02
#define ADS_N_AIN3				0x03
#define ADS_N_AIN4				0x04
#define ADS_N_AIN5				0x05
#define ADS_N_AIN6				0x06
#define ADS_N_AIN7				0x07
#define ADS_N_AIN8				0x08
#define ADS_N_AIN9				0x09
#define ADS_N_AIN10				0x0A
#define ADS_N_AIN11				0x0B
#define ADS_N_AINCOM			0x0C
/* ADS124S08 Register 3 (PGA) Definition */
/*   Bit 7   |   Bit 6   |   Bit 5   |   Bit 4   |   Bit 3   |   Bit 2   |   Bit 1   |   Bit 0
 *--------------------------------------------------------------------------------------------
 *   		DELAY[2:0]		     	 |      PGA_EN[1:0]      |              GAIN[2:0]
 *
 */
/* Define conversion delay in tmod clock periods */
#define ADS_DELAY_14			0x00
#define ADS_DELAY_25			0x20
#define ADS_DELAY_64			0x40
#define ADS_DELAY_256			0x60
#define ADS_DELAY_1024			0x80
#define ADS_DELAY_2048			0xA0
#define ADS_DELAY_4096			0xC0
#define ADS_DELAY_1				0xE0
/* Define PGA control */
#define ADS_PGA_BYPASS			0x00
#define ADS_PGA_ENABLED			0x08
/* Define Gain */
#define ADS_GAIN_1				0x00
#define ADS_GAIN_2				0x01
#define ADS_GAIN_4				0x02
#define ADS_GAIN_8				0x03
#define ADS_GAIN_16				0x04
#define ADS_GAIN_32				0x05
#define ADS_GAIN_64				0x06
#define ADS_GAIN_128			0x07
/* ADS124S08 Register 4 (DATARATE) Definition */
/*   Bit 7   |   Bit 6   |   Bit 5   |   Bit 4   |   Bit 3   |   Bit 2   |   Bit 1   |   Bit 0
 *--------------------------------------------------------------------------------------------
 *   G_CHOP  |    CLK    |    MODE   |   FILTER  | 				  DR[3:0]
 *
 */
#define ADS_GLOBALCHOP			0x80
#define ADS_CLKSEL_EXT			0x40
#define ADS_CONVMODE_SS			0x20
#define ADS_FILTERTYPE_LL		0x10
/* Define the data rate */
#define ADS_DR_2_5				0x00
#define ADS_DR_5				0x01
#define ADS_DR_10				0x02
#define ADS_DR_16				0x03
#define ADS_DR_20				0x04
#define ADS_DR_50				0x05
#define ADS_DR_60				0x06
#define ADS_DR_100				0x07
#define ADS_DR_200				0x08
#define ADS_DR_400				0x09
#define ADS_DR_800				0x0A
#define ADS_DR_1000				0x0B
#define ADS_DR_2000				0x0C
#define ADS_DR_4000				0x0D
/* ADS124S08 Register 5 (REF) Definition */
/*   Bit 7   |   Bit 6   |   Bit 5   |   Bit 4   |   Bit 3   |   Bit 2   |   Bit 1   |   Bit 0
 *--------------------------------------------------------------------------------------------
 *	  FL_REF_EN[1:0]	 | nREFP_BUF | nREFN_BUF | 		REFSEL[1:0]		 | 		REFCON[1:0]
 *
 */
#define ADS_FLAG_REF_DISABLE	0x00
#define ADS_FLAG_REF_EN_L0		0x40
#define ADS_FLAG_REF_EN_BOTH	0x80
#define ADS_FLAG_REF_EN_10M		0xC0
#define ADS_REFP_BYP_DISABLE	0x20
#define ADS_REFP_BYP_ENABLE		0x00
#define ADS_REFN_BYP_DISABLE	0x10
#define ADS_REFN_BYP_ENABLE		0x00
#define ADS_REFSEL_P0			0x00
#define ADS_REFSEL_P1			0x04
#define ADS_REFSEL_INT			0x08
#define ADS_REFINT_OFF			0x00
#define ADS_REFINT_ON_PDWN		0x01
#define ADS_REFINT_ON_ALWAYS	0x02
/* ADS124S08 Register 6 (IDACMAG) Definition */
/*   Bit 7   |   Bit 6   |   Bit 5   |   Bit 4   |   Bit 3   |   Bit 2   |   Bit 1   |   Bit 0
 *--------------------------------------------------------------------------------------------
 * FL_RAIL_EN|	  PSW	 |     0     | 		0	 | 			    	IMAG[3:0]
 *
 */
#define ADS_FLAG_RAIL_ENABLE	0x80
#define ADS_FLAG_RAIL_DISABLE	0x00
#define ADS_PSW_OPEN			0x00
#define ADS_PSW_CLOSED			0x40
#define ADS_IDACMAG_OFF			0x00
#define ADS_IDACMAG_10			0x01
#define ADS_IDACMAG_50			0x02
#define ADS_IDACMAG_100			0x03
#define ADS_IDACMAG_250			0x04
#define ADS_IDACMAG_500			0x05
#define ADS_IDACMAG_750			0x06
#define ADS_IDACMAG_1000		0x07
#define ADS_IDACMAG_1500		0x08
#define ADS_IDACMAG_2000		0x09
/* ADS124S08 Register 7 (IDACMUX) Definition */
/*   Bit 7   |   Bit 6   |   Bit 5   |   Bit 4   |   Bit 3   |   Bit 2   |   Bit 1   |   Bit 0
 *--------------------------------------------------------------------------------------------
 *                    I2MUX[3:0]                 |                   I1MUX[3:0]
 *
 */
/* Define IDAC2 Output */
#define ADS_IDAC2_A0			0x00
#define ADS_IDAC2_A1			0x10
#define ADS_IDAC2_A2			0x20
#define ADS_IDAC2_A3			0x30
#define ADS_IDAC2_A4			0x40
#define ADS_IDAC2_A5			0x50
#define ADS_IDAC2_A6			0x60
#define ADS_IDAC2_A7			0x70
#define ADS_IDAC2_A8			0x80
#define ADS_IDAC2_A9			0x90
#define ADS_IDAC2_A10			0xA0
#define ADS_IDAC2_A11			0xB0
#define ADS_IDAC2_AINCOM		0xC0
#define ADS_IDAC2_OFF			0xF0
/* Define IDAC1 Output */
#define ADS_IDAC1_A0			0x00
#define ADS_IDAC1_A1			0x01
#define ADS_IDAC1_A2			0x02
#define ADS_IDAC1_A3			0x03
#define ADS_IDAC1_A4			0x04
#define ADS_IDAC1_A5			0x05
#define ADS_IDAC1_A6			0x06
#define ADS_IDAC1_A7			0x07
#define ADS_IDAC1_A8			0x08
#define ADS_IDAC1_A9			0x09
#define ADS_IDAC1_A10			0x0A
#define ADS_IDAC1_A11			0x0B
#define ADS_IDAC1_AINCOM		0x0C
#define ADS_IDAC1_OFF			0x0F
/* ADS124S08 Register 8 (VBIAS) Definition */
/*   Bit 7   |   Bit 6   |   Bit 5   |   Bit 4   |   Bit 3   |   Bit 2   |   Bit 1   |   Bit 0
 *--------------------------------------------------------------------------------------------
 *  VB_LEVEL | 	VB_AINC  |  VB_AIN5  |  VB_AIN4  |  VB_AIN3  |  VB_AIN2  |  VB_AIN1  |  VB_AIN0
 *
 */
#define ADS_VBIAS_LVL_DIV2		0x00
#define ADS_VBIAS_LVL_DIV12		0x80
/* Define VBIAS here */
#define ADS_VB_AINC				0x40
#define ADS_VB_AIN5				0x20
#define ADS_VB_AIN4				0x10
#define ADS_VB_AIN3				0x08
#define ADS_VB_AIN2				0x04
#define ADS_VB_AIN1				0x02
#define ADS_VB_AIN0				0x01
/* ADS124S08 Register 9 (SYS) Definition */
/*   Bit 7   |   Bit 6   |   Bit 5   |   Bit 4   |   Bit 3   |   Bit 2   |   Bit 1   |   Bit 0
 *--------------------------------------------------------------------------------------------
 *			   SYS_MON[2:0]			 |	   CAL_SAMP[1:0]     |  TIMEOUT  | 	  CRC	 | SENDSTAT
 *
 */
#define ADS_SYS_MON_OFF			0x00
#define ADS_SYS_MON_SHORT		0x20
#define ADS_SYS_MON_TEMP		0x40
#define ADS_SYS_MON_ADIV4		0x60
#define ADS_SYS_MON_DDIV4		0x80
#define ADS_SYS_MON_BCS_2		0xA0
#define ADS_SYS_MON_BCS_1		0xC0
#define ADS_SYS_MON_BCS_10		0xE0
#define ADS_CALSAMPLE_1			0x00
#define ADS_CALSAMPLE_4			0x08
#define ADS_CALSAMPLE_8			0x10
#define ADS_CALSAMPLE_16		0x18
#define ADS_TIMEOUT_DISABLE		0x00
#define ADS_TIMEOUT_ENABLE		0x04
#define ADS_CRC_DISABLE			0x00
#define ADS_CRC_ENABLE			0x02
#define ADS_SENDSTATUS_DISABLE	0x00
#define ADS_SENDSTATUS_ENABLE	0x01
/* ADS124S08 Register A (OFCAL0) Definition */
/*   Bit 7   |   Bit 6   |   Bit 5   |   Bit 4   |   Bit 3   |   Bit 2   |   Bit 1   |   Bit 0
 *--------------------------------------------------------------------------------------------
 *                                         OFC[7:0]
 *
 */
/* ADS124S08 Register B (OFCAL1) Definition */
/*   Bit 7   |   Bit 6   |   Bit 5   |   Bit 4   |   Bit 3   |   Bit 2   |   Bit 1   |   Bit 0
 *--------------------------------------------------------------------------------------------
 *                                         OFC[15:8]
 *
 */
/* ADS124S08 Register C (OFCAL2) Definition */
/*   Bit 7   |   Bit 6   |   Bit 5   |   Bit 4   |   Bit 3   |   Bit 2   |   Bit 1   |   Bit 0
 *--------------------------------------------------------------------------------------------
 *                                         OFC[23:16]
 *
 */
/* ADS124S08 Register D (FSCAL0) Definition */
/*   Bit 7   |   Bit 6   |   Bit 5   |   Bit 4   |   Bit 3   |   Bit 2   |   Bit 1   |   Bit 0
 *--------------------------------------------------------------------------------------------
 *                                         FSC[7:0]
 *
 */
/* ADS124S08 Register E (FSCAL1) Definition */
/*   Bit 7   |   Bit 6   |   Bit 5   |   Bit 4   |   Bit 3   |   Bit 2   |   Bit 1   |   Bit 0
 *--------------------------------------------------------------------------------------------
 *                                         FSC[15:8]
 *
 */
/* ADS124S08 Register F (FSCAL2) Definition */
/*   Bit 7   |   Bit 6   |   Bit 5   |   Bit 4   |   Bit 3   |   Bit 2   |   Bit 1   |   Bit 0
 *--------------------------------------------------------------------------------------------
 *                                         FSC[23:16]
 *
 */
/* ADS124S08 Register 10 (GPIODAT) Definition */
/*   Bit 7   |   Bit 6   |   Bit 5   |   Bit 4   |   Bit 3   |   Bit 2   |   Bit 1   |   Bit 0
 *--------------------------------------------------------------------------------------------
 *                      DIR[3:0]    			 | 					DAT[3:0]
 *
 */
/* Define GPIO direction (0-Output; 1-Input) here */
#define ADS_GPIO0_DIR_INPUT		0x10
#define ADS_GPIO1_DIR_INPUT		0x20
#define ADS_GPIO2_DIR_INPUT		0x40
#define ADS_GPIO3_DIR_INPUT		0x80
/*
 *
 */
/* Define GPIO data here */
/*
 *
 */
/* ADS124S08 Register 11 (GPIOCON) Definition */
/*   Bit 7   |   Bit 6   |   Bit 5   |   Bit 4   |   Bit 3   |   Bit 2   |   Bit 1   |   Bit 0
 *--------------------------------------------------------------------------------------------
 *     0	 |	   0	 |	   0	 |	   0     |                    CON[3:0]
 *
 */
/* Define GPIO configuration (0-Analog Input; 1-GPIO) here */
#define ADS_GPIO0_DIR_INPUT		0x10
#define ADS_GPIO1_DIR_INPUT		0x20
#define ADS_GPIO2_DIR_INPUT		0x40
#define ADS_GPIO3_DIR_INPUT		0x80
/*
 *
 */
/* Lengths of conversion data components */
#define DATA_LENGTH			3
#define STATUS_LENGTH		1
#define CRC_LENGTH			1
/*
 * The time we have to wait for the CS GPIO to actually
 * pull down before we start sending SCLKs
 *
 */
#define CHIP_SELECT_WAIT_TIME	0

/* Flag to signal that we are in the process of collecting data */
#define DATA_MODE_NORMAL	0x00
#define DATA_MODE_STATUS	0x01
#define DATA_MODE_CRC		0x02

 /* The clock rate of the internal XTAL... */
#define DEVICE_ICLK 16384000

/* Set the SPI SCLK speed */
#define SPI_SPEED 5000000
/*
 * The TIVA has a 4 to 16 bit word size, to handle  32 bit words the TIVA needs to assemble
 * two groups of words together.  32 bits comprises of 2x16 words (or 4x8 words).
*/
#define SPI_WORD_SIZE 8

class ADS124S08
{
	// Device command prototypes
	public:
		ADS124S08(PCA9555& ioExpander, SPIClass& spi, SPISettings& spiSettings);
		void init();
		void ADS124S08_Reset();
		void begin();
		char regRead(unsigned int regnum);
		void readRegs(unsigned int regnum, unsigned int count, uint8_t *data);
		void regWrite(unsigned int regnum, unsigned char data);
		void writeRegs(unsigned int regnum, unsigned int howmuch, unsigned char *data);
		void reStart(void);
		void sendCommand(uint8_t op_code);
		int  rData(uint8_t *dStatus, uint8_t *dData, uint8_t *dCRC);
		int  dataRead(uint8_t *dStatus, uint8_t *dData, uint8_t *dCRC);
		void selectDeviceCSLow(void);
		void releaseChipSelect(void);
		void assertStart(void);
		void deassertStart(void);
		bool converting;
		uint8_t registers[NUM_REGISTERS];
  private:
		bool fStart;
		void DRDY_int(void);
		PCA9555* _ioExpander;  // Puntero al expansor IO
		SPIClass* _spi;        // Puntero a la interfaz SPI
		SPISettings _spiSettings; // Configuración SPI
		bool _initialized;     // Flag para indicar si se ha inicializado
};

#endif // DEVICE_TYPE_ANALOGIC

#endif /* ADS124S08_H_ */

================
File: include/HardwareManager.h
================
/*******************************************************************************************
 * Archivo: include/HardwareManager.h
 * Descripción: Gestión de inicialización y configuración del hardware del sistema.
 * Incluye funciones para inicialización de periféricos y control de energía.
 *******************************************************************************************/

#ifndef HARDWARE_MANAGER_H
#define HARDWARE_MANAGER_H

#include <Arduino.h>
#include <Wire.h>
#include <SPI.h>
#include "config.h"
#include "PowerManager.h"
#include "clsPCA9555.h"
#include <SensirionI2cSht3x.h>

class HardwareManager {
public:
    /**
     * @brief Inicializa el bus I2C, la expansión de I/O y el PowerManager.
     * @param ioExpander Referencia al expansor de I/O
     * @param powerManager Referencia al gestor de energía
     * @param sht30Sensor Referencia al sensor SHT30
     * @param spi Referencia a la interfaz SPI
     * @return true si la inicialización fue exitosa, false en caso contrario
     */
    static bool initHardware(PCA9555& ioExpander, PowerManager& powerManager, SensirionI2cSht3x& sht30Sensor, SPIClass& spi);

    /**
     * @brief Inicializa los pines de selección SPI (SS)
     */
    static void initializeSPISSPins();

};

#endif // HARDWARE_MANAGER_H

================
File: include/PowerManager.h
================
#ifndef POWER_MANAGER_H
#define POWER_MANAGER_H

#include "clsPCA9555.h"
#include "config.h"

class PowerManager {
private:
    PCA9555& ioExpander;

public:
    PowerManager(PCA9555& expander);
    void begin();

    // Método común para todos los dispositivos
    void power3V3On();
    void power3V3Off();
    
    // Métodos disponibles solo para dispositivos ANALOGIC y MODBUS
#if defined(DEVICE_TYPE_ANALOGIC) || defined(DEVICE_TYPE_MODBUS)
    void power12VOn();
    void power12VOff();
#endif

    // Método disponible solo para dispositivo ANALOGIC
#ifdef DEVICE_TYPE_ANALOGIC
    void power2V5On();
    void power2V5Off();
#endif

    void allPowerOff();
};

#endif

================
File: src/PowerManager.cpp
================
#include "PowerManager.h"

PowerManager::PowerManager(PCA9555& expander) : ioExpander(expander) {
}

void PowerManager::begin() {
    // Configurar pines como salidas
    ioExpander.pinMode(POWER_3V3_PIN, OUTPUT);
    
#if defined(DEVICE_TYPE_ANALOGIC) || defined(DEVICE_TYPE_MODBUS)
    ioExpander.pinMode(POWER_12V_PIN, OUTPUT);
#endif

#ifdef DEVICE_TYPE_ANALOGIC
    ioExpander.pinMode(POWER_2V5_PIN, OUTPUT);
#endif
    
    // Asegurar que todas las fuentes están apagadas al inicio
    allPowerOff();
}

void PowerManager::power3V3On() {
    ioExpander.digitalWrite(POWER_3V3_PIN, HIGH);
    delay(POWER_STABILIZE_DELAY);
}

void PowerManager::power3V3Off() {
    ioExpander.digitalWrite(POWER_3V3_PIN, LOW);
}

#if defined(DEVICE_TYPE_ANALOGIC) || defined(DEVICE_TYPE_MODBUS)
void PowerManager::power12VOn() {
    ioExpander.digitalWrite(POWER_12V_PIN, HIGH);
    delay(POWER_STABILIZE_DELAY);
}

void PowerManager::power12VOff() {
    ioExpander.digitalWrite(POWER_12V_PIN, LOW);
}
#endif

#ifdef DEVICE_TYPE_ANALOGIC
void PowerManager::power2V5On() {
    ioExpander.digitalWrite(POWER_2V5_PIN, HIGH);
    delay(POWER_STABILIZE_DELAY);
}

void PowerManager::power2V5Off() {
    ioExpander.digitalWrite(POWER_2V5_PIN, LOW);
}
#endif

void PowerManager::allPowerOff() {
#ifdef DEVICE_TYPE_ANALOGIC
    power2V5Off();
#endif
    power3V3Off();
#if defined(DEVICE_TYPE_ANALOGIC) || defined(DEVICE_TYPE_MODBUS)
    power12VOff();
#endif
}

================
File: src/sensors/ConductivitySensor.cpp
================
#include "sensors/ConductivitySensor.h"

#ifdef DEVICE_TYPE_ANALOGIC

#include <cmath>
#include "ADS124S08.h"
#include "AdcUtilities.h"
#include "sensors/NtcManager.h"

// Variables globales declaradas en main.cpp
extern ADS124S08 ADC;

/**
 * @brief Convierte el voltaje medido a valor de conductividad/TDS en ppm
 * 
 * @param voltage Voltaje medido del sensor
 * @param tempC Temperatura del agua en grados Celsius para compensación
 * @return float Valor de TDS en ppm (partes por millón)
 */
float ConductivitySensor::convertVoltageToConductivity(float voltage, float tempC) {
    float calTemp, coefComp, V1, T1, V2, T2, V3, T3;
    ConfigManager::getConductivityConfig(calTemp, coefComp, V1, T1, V2, T2, V3, T3);

    // Si tempC es NAN, usar la temperatura de calibración como valor por defecto
    if (isnan(tempC)) {
        tempC = calTemp;
    }

    // Matriz para resolver el sistema de ecuaciones
    // Basado en 3 puntos de calibración
    const double det = V1*V1*(V2 - V3) - V1*(V2*V2 - V3*V3) + (V2*V2*V3 - V2*V3*V3);
    
    // Calcular coeficientes solo si el determinante no es cero
    if(fabs(det) > 1e-6) {
        const double a = (T1*(V2 - V3) - T2*(V1 - V3) + T3*(V1 - V2)) / det;
        const double b = (T1*(V3*V3 - V2*V2) + T2*(V1*V1 - V3*V3) + T3*(V2*V2 - V1*V1)) / det;
        const double c = (T1*(V2*V2*V3 - V2*V3*V3) - T2*(V1*V1*V3 - V1*V3*V3) + T3*(V1*V1*V2 - V1*V2*V2)) / det;
        
        // Aplicar compensación de temperatura
        const double compensation = 1.0 + coefComp * (tempC - calTemp);
        double compensatedVoltage = voltage / compensation;
        double conductivity = a * (compensatedVoltage * compensatedVoltage) 
                    + b * compensatedVoltage 
                    + c;

        return fmax(conductivity, 0.0);
    }
    else {
        return NAN;
    }
}

/**
 * @brief Lee el sensor de conductividad conectado al canal AIN6 del ADC
 * 
 * @return float Valor de conductividad/TDS en ppm, o NAN si hay error
 */
float ConductivitySensor::read() {
    // Asegurarse de que el ADC esté despierto
    ADC.sendCommand(WAKE_OPCODE_MASK);
    
    // Configurar el multiplexor para leer AIN6 con referencia a AINCOM (tierra)
    uint8_t muxConfig = ADS_P_AIN6 | ADS_N_AINCOM;
    
    // Realizar una única lectura del sensor
    float voltage = AdcUtilities::measureAdcDifferential(muxConfig);
    
    // Verificar si el voltaje es válido
    if (isnan(voltage) || voltage <= 0.0f || voltage >= 2.5f) {
        return NAN;
    }
    
    // Obtener temperatura únicamente del sensor NTC10K
    float waterTemp = NtcManager::readNtc10kTemperature();
    
    // Convertir a conductividad con compensación de temperatura
    float tdsValue = convertVoltageToConductivity(voltage, waterTemp);
    return tdsValue;
}

#endif // DEVICE_TYPE_ANALOGIC

================
File: src/sensors/HDS10Sensor.cpp
================
#include "sensors/HDS10Sensor.h"

#ifdef DEVICE_TYPE_ANALOGIC

#include <cmath>
#include "ADS124S08.h"
#include "AdcUtilities.h"

// Variables globales declaradas en main.cpp
extern ADS124S08 ADC;

/**
 * @brief Convierte la resistencia del sensor HDS10 a porcentaje de humedad usando interpolación logarítmica
 * @param sensorR Resistencia del sensor en ohms
 * @return Porcentaje de humedad relativa (50-100%)
 */
float HDS10Sensor::convertResistanceToHumidity(float sensorR) {
    // Tabla de valores aproximados de la curva "Average" del sensor
    // Valores en kΩ vs. %HR
    static const float Rvals[] = { 1.0f,   2.0f,   5.0f,   10.0f,  50.0f,  100.0f, 200.0f };
    static const float Hvals[] = { 50.0f, 60.0f, 70.0f,  80.0f, 90.0f, 95.0f, 100.0f };
    static const int   NPOINTS = sizeof(Rvals)/sizeof(Rvals[0]);
    
    // Pasar ohms a kΩ
    float Rk = sensorR * 1e-3f;
    
    // Si está por debajo de la primera resistencia, limitamos a Hvals[0]
    if (Rk <= Rvals[0]) {
        return Hvals[0];
    }
    
    // Si está por encima de la última resistencia, limitamos a Hvals[NPOINTS-1]
    if (Rk >= Rvals[NPOINTS-1]) {
        return Hvals[NPOINTS-1];
    }

    // Buscar en qué tramo cae Rk
    for (int i=0; i < NPOINTS-1; i++) {
        float R1 = Rvals[i];
        float R2 = Rvals[i+1];
        if (Rk >= R1 && Rk <= R2) {
            // Interpolación logarítmica entre R1 y R2
            float logR   = log10(Rk);
            float logR1  = log10(R1);
            float logR2  = log10(R2);

            float HR1 = Hvals[i];
            float HR2 = Hvals[i+1];

            float humidity = HR1 + (HR2 - HR1) * ((logR - logR1) / (logR2 - logR1));
            return humidity;
        }
    }

    // Deberíamos haber retornado dentro del for, pero por seguridad:
    return Hvals[NPOINTS-1];
}

/**
 * @brief Lee el sensor HDS10 conectado al canal AIN5/AIN8 del ADC
 * 
 * @return float Porcentaje de humedad (0-100%) según calibración definida
 *               o NAN si ocurre un error o no es posible leer
 */
float HDS10Sensor::read() {
    // Asegurarse de que el ADC esté despierto
    ADC.sendCommand(WAKE_OPCODE_MASK);
    
    // Configurar el multiplexor para leer AIN5 con referencia a AIN8
    uint8_t muxConfig = ADS_P_AIN5 | ADS_N_AIN8;
    
    // Usar AdcUtilities para leer el voltaje diferencial
    float voltage = AdcUtilities::measureAdcDifferential(muxConfig);
    
    // Verificar si el voltaje está en rango válido
    if (voltage <= 0.0f || voltage >= 2.5f) {
        return NAN; // Valor fuera de rango
    }
    
    // Calcular la resistencia del sensor basado en el divisor de voltaje correcto
    // El circuito es: 2.5V --- R1(220K) --- [Punto de medición] --- R2(220K) --- HDS10 --- GND
    // Y estamos midiendo la caída de voltaje en R2+HDS10
    
    float r1 = 220000.0f; // Primera resistencia de 220K
    float r2 = 220000.0f; // Segunda resistencia de 220K
    
    // Calculamos la corriente en el circuito (que es la misma en toda la serie)
    // I = (2.5V - voltage) / R1
    float current = (2.5f - voltage) / r1;
    
    // El voltaje medido es la caída en R2+HDS10
    // voltage = I * (R2 + HDS10)
    // Por lo tanto, HDS10 = voltage/I - R2
    float sensorR = (voltage / current) - r2;
    
    if (sensorR < 0.0f) {
        return NAN; // Valor no válido
    }
    
    // Usar la función de conversión basada en interpolación logarítmica
    float percentage = convertResistanceToHumidity(sensorR);
    
    return percentage;
}

#endif // DEVICE_TYPE_ANALOGIC

================
File: src/sensors/PHSensor.cpp
================
#include "sensors/PHSensor.h"

#ifdef DEVICE_TYPE_ANALOGIC

#include <cmath>
#include "ADS124S08.h"
#include "AdcUtilities.h"
#include "sensors/NtcManager.h"

// Variables globales declaradas en main.cpp
extern ADS124S08 ADC;

/**
 * @brief Convierte el voltaje medido a valor de pH
 * 
 * @param voltage Voltaje medido del sensor de pH
 * @param tempC Temperatura del agua en grados Celsius para compensación
 * @return float Valor de pH (0-14)
 */
float PHSensor::convertVoltageToPH(float voltage, float tempC) {
    float V1, T1, V2, T2, V3, T3, TEMP_CAL;
    ConfigManager::getPHConfig(V1, T1, V2, T2, V3, T3, TEMP_CAL);

    // Si solutionTemp es NAN, usar la temperatura de calibración como valor por defecto
    if (isnan(tempC)) {
        tempC = TEMP_CAL;
    }

    // Datos de calibración (pH, voltaje)
    const double pH_calib[] = {T1, T2, T3};
    const double V_calib[] = {V1, V2, V3};
    const int n = 3; // Número de puntos de calibración

    // Calcular sumatorias necesarias para mínimos cuadrados
    double sum_pH = 0.0;
    double sum_V = 0.0;
    double sum_pHV = 0.0;
    double sum_pH2 = 0.0;

    for (int i = 0; i < n; i++) {
        sum_pH += pH_calib[i];
        sum_V += V_calib[i];
        sum_pHV += pH_calib[i] * V_calib[i];
        sum_pH2 += pH_calib[i] * pH_calib[i];
    }

    // Calcular la pendiente S usando mínimos cuadrados
    double S_CAL = ((n * sum_pHV) - (sum_pH * sum_V)) / ((n * sum_pH2) - (sum_pH * sum_pH));

    // Calcular el offset E0 usando mínimos cuadrados
    double E0 = ((sum_V) + (S_CAL * sum_pH)) / n;

    // Ajustar la pendiente según la temperatura actual usando la ecuación de Nernst
    const double tempK = (tempC + 273.15);
    const double tempCalK = (TEMP_CAL + 273.15);
    const double S_T = S_CAL * (tempK / tempCalK);

    // Calcular pH usando la ecuación de Nernst ajustada: pH = (E0 - E) / S(T)
    double pH = ((E0 + voltage) / S_T);
    // Limitar el pH a un rango físicamente posible (0-14)
    pH = constrain(pH, 0.0, 14.0);

    return pH;
}

/**
 * @brief Lee el sensor de pH conectado al canal AIN7 del ADC
 * 
 * @return float Valor de pH (0-14), o NAN si hay error
 */
float PHSensor::read() {
    // Asegurarse de que el ADC esté despierto
    ADC.sendCommand(WAKE_OPCODE_MASK);
    
    // Configurar el multiplexor para leer AIN7 con referencia a AINCOM (tierra)
    uint8_t muxConfig = ADS_P_AIN7 | ADS_N_AINCOM;
    
    // Realizar una única lectura del sensor
    float voltage = AdcUtilities::measureAdcDifferential(muxConfig);
    
    // Verificar si el voltaje es válido
    if (isnan(voltage) || voltage < -2.5f || voltage > 2.5f) {
        return NAN;
    }
    
    // Obtener temperatura únicamente del sensor NTC10K
    float waterTemp = NtcManager::readNtc10kTemperature();
    
    // Convertir a pH con compensación de temperatura
    float pHValue = convertVoltageToPH(voltage, waterTemp);
    
    return pHValue;
}

#endif // DEVICE_TYPE_ANALOGIC

================
File: include/ModbusSensorManager.h
================
#ifndef MODBUS_SENSOR_MANAGER_H
#define MODBUS_SENSOR_MANAGER_H

#include <Arduino.h>
#include <vector>
#include "sensor_types.h"
#include "config.h"  // Para las definiciones de tipo de dispositivo

#if defined(DEVICE_TYPE_ANALOGIC) || defined(DEVICE_TYPE_MODBUS)

/**
 * @brief Clase para manejar la lectura de sensores Modbus.
 *        Usa Serial por defecto. Asegurarse de no usar debug durante la medición.
 *        Utiliza la biblioteca ModbusMaster para comunicación.
 */
class ModbusSensorManager {
public:
    /**
     * @brief Inicializa el bus RS485/Modbus (configura Serial a 9600, 8N1, etc.)
     *        Debe llamarse una sola vez al principio.
     */
    static void beginModbus();

    /**
     * @brief Finaliza la comunicación Modbus (cierra Serial)
     *        Debe llamarse después de completar todas las lecturas Modbus
     */
    static void endModbus();

    /**
     * @brief Lee un sensor Modbus de tipo ENV_SENSOR (ejemplo del datasheet).
     *        Regresa la lectura con subvalores (T, H, Ruido, PM2.5, PM10, Presión, Iluminación).
     * @param cfg Configuración del sensor (dirección, etc.)
     * @return Estructura ModbusSensorReading con los subvalores.
     */
    static ModbusSensorReading readEnvSensor(const ModbusSensorConfig &cfg);

private:
    /**
     * @brief Envía un frame Modbus (Función 0x03) y recibe la respuesta utilizando ModbusMaster.
     *        Para simplificar el ejemplo, se hace una lectura consecutiva de registros.
     * @param address Dirección Modbus del dispositivo
     * @param startReg Registro inicial
     * @param numRegs  Cantidad de registros
     * @param outData  Buffer de salida donde se almacenan los valores de cada registro
     * @return true si la lectura fue exitosa, false en caso de error
     */
    static bool readHoldingRegisters(uint8_t address, uint16_t startReg, uint16_t numRegs, uint16_t* outData);
};

#endif // defined(DEVICE_TYPE_ANALOGIC) || defined(DEVICE_TYPE_MODBUS)

#endif // MODBUS_SENSOR_MANAGER_H

================
File: src/ADS124S08.cpp
================
/* --COPYRIGHT--,BSD
 * Copyright (c) 2016, Texas Instruments Incorporated
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * --/COPYRIGHT--*/

#include "ADS124S08.h"
#include "debug.h"

#ifdef DEVICE_TYPE_ANALOGIC

/*
 * This class is based on the ADS124S08.c provided by TI and adapted for use with
 * Particle Photon and other Arduino-like MCU's.
 *
 * Note that the confusingly named "selectDeviceCSLow"
 * actually selects the device and that "releaseChipSelect" deselects it. Not obvious
 * from the naming, but according to the datasheet CS is active LOW.
 */

/*
 * Writes the nCS pin low and waits a while for the device to finish working before
 * handing control back to the caller for a SPI transfer.
 */
void ADS124S08::selectDeviceCSLow(void){
	if (_initialized) {
		_ioExpander->digitalWrite(ADS124S08_CS_PIN, LOW);
	}
}

/*
 * Pulls the nCS pin high. Performs no waiting.
 */
void ADS124S08::releaseChipSelect(void){
	if (_initialized) {
		_ioExpander->digitalWrite(ADS124S08_CS_PIN, HIGH);
	}
}

/*
 * Constructor - solo almacena referencias a los objetos pasados
 */
ADS124S08::ADS124S08(PCA9555& ioExpander, SPIClass& spi, SPISettings& spiSettings)
{
	_ioExpander = &ioExpander;
	_spi = &spi;
	_spiSettings = spiSettings;
	_initialized = false;
	fStart = false;
}

/*
 * Inicializa el dispositivo para su uso
 * Configura los pines y registros
 */
void ADS124S08::init()
{
	if (_initialized) return;
	
	_ioExpander->pinMode(ADS124S08_START_PIN, OUTPUT);
	_ioExpander->pinMode(ADS124S08_RST_PIN, OUTPUT);
	_ioExpander->pinMode(ADS124S08_DRDY_PIN, INPUT);

	_ioExpander->digitalWrite(ADS124S08_START_PIN, LOW);
	_ioExpander->digitalWrite(ADS124S08_RST_PIN, HIGH);

	/* Default register settings */
	registers[ID_ADDR_MASK] 			= 0x08;
	registers[STATUS_ADDR_MASK] 	= 0x80;
	registers[INPMUX_ADDR_MASK]		= 0x01;
	registers[PGA_ADDR_MASK] 			= 0x00;
	registers[DATARATE_ADDR_MASK] = 0x14;
	registers[REF_ADDR_MASK] 			= 0x10;
	registers[IDACMAG_ADDR_MASK] 	= 0x00;
	registers[IDACMUX_ADDR_MASK] 	= 0xFF;
	registers[VBIAS_ADDR_MASK] 		= 0x00;
	registers[SYS_ADDR_MASK]			= 0x10;
	registers[OFCAL0_ADDR_MASK] 	= 0x00;
	registers[OFCAL1_ADDR_MASK] 	= 0x00;
	registers[OFCAL2_ADDR_MASK] 	= 0x00;
	registers[FSCAL0_ADDR_MASK] 	= 0x00;
	registers[FSCAL1_ADDR_MASK] 	= 0x00;
	registers[FSCAL2_ADDR_MASK] 	= 0x40;
	registers[GPIODAT_ADDR_MASK] 	= 0x00;
	registers[GPIOCON_ADDR_MASK]	= 0x00;
	
	_initialized = true;
}

/*
 * Resetea el ADS124S08 usando el pin RST_PIN
 * Secuencia de reset: HIGH -> LOW -> HIGH con delays entre cada cambio
 */
void ADS124S08::ADS124S08_Reset()
{
	if (!_initialized) return;
					// Esperar 100 mSec
	_ioExpander->digitalWrite(ADS124S08_RST_PIN, LOW);
	delayMicroseconds(100);
	_ioExpander->digitalWrite(ADS124S08_RST_PIN, HIGH);
}

void ADS124S08::begin()
{
	if (!_initialized) {
		init();
	}
	
	// Resetear el ADC antes de comenzar
	ADS124S08_Reset();
	
	_spi->begin();
	_spi->beginTransaction(_spiSettings);
	_spi->endTransaction();
}

/*
 * Reads a single register contents from the specified address
 *
 * \param regnum identifies which address to read
 *
 */
char ADS124S08::regRead(unsigned int regnum)
{
	if (!_initialized) return 0;
	
	int i;
	uint8_t ulDataTx[3];
	uint8_t ulDataRx[3];
	ulDataTx[0] = REGRD_OPCODE_MASK + (regnum & 0x1f);
	ulDataTx[1] = 0x00;
	ulDataTx[2] = 0x00;
	selectDeviceCSLow();

	_spi->beginTransaction(_spiSettings);

	for(i = 0; i < 3; i++)
		ulDataRx[i] = _spi->transfer(ulDataTx[i]);
	if(regnum < NUM_REGISTERS)
			registers[regnum] = ulDataRx[2];

	_spi->endTransaction();

	releaseChipSelect();
	return ulDataRx[2];
}

/*
 * Reads a group of registers starting at the specified address
 *
 * \param regnum is addr_mask 8-bit mask of the register from which we start reading
 * \param count The number of registers we wish to read
 * \param *location pointer to the location in memory to write the data
 *
 */
void ADS124S08::readRegs(unsigned int regnum, unsigned int count, uint8_t *data)
{
	if (!_initialized) return;
	
	int i;
	uint8_t ulDataTx[2];
	ulDataTx[0] = REGRD_OPCODE_MASK + (regnum & 0x1f);
	ulDataTx[1] = count-1;
	selectDeviceCSLow();

	_spi->beginTransaction(_spiSettings);
	
	_spi->transfer(ulDataTx[0]);
	_spi->transfer(ulDataTx[1]);
	for(i = 0; i < count; i++)
	{
		data[i] = _spi->transfer(0);
		if(regnum+i < NUM_REGISTERS)
			registers[regnum+i] = data[i];
	}
	
	_spi->endTransaction();
	
	releaseChipSelect();
}

/*
 * Writes a single of register with the specified data
 *
 * \param regnum addr_mask 8-bit mask of the register to which we start writing
 * \param data to be written
 *
 */
void ADS124S08::regWrite(unsigned int regnum, unsigned char data)
{
	if (!_initialized) return;
	
	uint8_t ulDataTx[3];
	ulDataTx[0] = REGWR_OPCODE_MASK + (regnum & 0x1f);
	ulDataTx[1] = 0x00;
	ulDataTx[2] = data;
	selectDeviceCSLow();
	
	_spi->beginTransaction(_spiSettings);
	
	_spi->transfer(ulDataTx[0]);
	_spi->transfer(ulDataTx[1]);
	_spi->transfer(ulDataTx[2]);
	
	_spi->endTransaction();
	
	releaseChipSelect();
	return;
}

/*
 * Writes a group of registers starting at the specified address
 *
 * \param regnum is addr_mask 8-bit mask of the register from which we start writing
 * \param count The number of registers we wish to write
 * \param *location pointer to the location in memory to read the data
 *
 */
void ADS124S08::writeRegs(unsigned int regnum, unsigned int howmuch, unsigned char *data)
{
	if (!_initialized) return;
	
	unsigned int i;
	uint8_t ulDataTx[2];
	ulDataTx[0] = REGWR_OPCODE_MASK + (regnum & 0x1f);
	ulDataTx[1] = howmuch-1;
	selectDeviceCSLow();
	
	_spi->beginTransaction(_spiSettings);
	
	_spi->transfer(ulDataTx[0]);
	_spi->transfer(ulDataTx[1]);
	for(i=0; i < howmuch; i++)
	{
		_spi->transfer(data[i]);
		if(regnum+i < NUM_REGISTERS)
			registers[regnum+i] = data[i];
	}
	
	_spi->endTransaction();
	
	releaseChipSelect();
	return;
}

/*
 * Sends a command to the ADS124S08
 *
 * \param op_code is the command being issued
 *
 */
void ADS124S08::sendCommand(uint8_t op_code)
{
	if (!_initialized) return;
	
	selectDeviceCSLow();
	
	_spi->beginTransaction(_spiSettings);
	_spi->transfer(op_code);
	_spi->endTransaction();

	releaseChipSelect();
	return;
}

/*
 * Sends a STOP/START command sequence to the ADS124S08 to restart conversions (SYNC)
 *
 */
void ADS124S08::reStart(void)
{
	if (!_initialized) return;
	
	sendCommand(STOP_OPCODE_MASK);
	sendCommand(START_OPCODE_MASK);
	return;
}

/*
 * Sets the GPIO hardware START pin high (red LED)
 *
 */
void ADS124S08::assertStart()
{
	if (!_initialized) return;
	
	fStart = true;
	_ioExpander->digitalWrite(ADS124S08_START_PIN, HIGH);
}

/*
 * Sets the GPIO hardware START pin low
 *
 */
void ADS124S08::deassertStart()
{
	if (!_initialized) return;
	
	fStart = false;
	_ioExpander->digitalWrite(ADS124S08_START_PIN, LOW);
}

/*
 * Reads data using the RDATA command
 * Espera a que el pin DRDY esté en LOW (activo bajo) para indicar que los datos están listos
 * antes de enviar el comando RDATA y leer los datos del ADC.
 */
int ADS124S08::rData(uint8_t *dStatus, uint8_t *dData, uint8_t *dCRC)
{
	if (!_initialized) return -1;
	
	// Esperar a que el pin DRDY esté en LOW (datos disponibles)
	// DRDY es activo bajo, por lo que cuando está en LOW, los datos están listos
	uint32_t timeout = millis() + 100; // Timeout de 100 ms
	while (_ioExpander->digitalRead(ADS124S08_DRDY_PIN) == HIGH) {
		// Si se supera el timeout, retornar error
		if (millis() > timeout) {
			return -1;
		}
		delayMicroseconds(100); // Pequeña pausa para no saturar el CPU
	}
	
	int result = -1;
	selectDeviceCSLow();

	_spi->beginTransaction(_spiSettings);

	// according to datasheet chapter 9.5.4.2 Read Data by RDATA Command
	sendCommand(RDATA_OPCODE_MASK);

	// if the Status byte is set - grab it
	uint8_t shouldWeReceiveTheStatusByte = (registers[SYS_ADDR_MASK] & 0x01) == DATA_MODE_STATUS;
	if(shouldWeReceiveTheStatusByte)
	{
		dStatus[0] = _spi->transfer(0x00);
	}

	// get the conversion data (3 bytes)
	uint8_t data[3];
	data[0] = _spi->transfer(0x00);
	data[1] = _spi->transfer(0x00);
	data[2] = _spi->transfer(0x00);
	
	// Armar el entero de 24 bits con extensión de signo
	uint32_t raw = ((uint32_t)data[0] << 16) | ((uint32_t)data[1] << 8) | data[2];
	
	// Extender el signo si el bit 23 es 1
	if (raw & 0x800000) {
		raw |= 0xFF000000;  // Extensión de signo
	}
	
	result = (int)raw;

	// is CRC enabled?
	uint8_t isCrcEnabled = (registers[SYS_ADDR_MASK] & 0x02) == DATA_MODE_CRC;
	if(isCrcEnabled)
	{
		dCRC[0] = _spi->transfer(0x00);
	}

	_spi->endTransaction();

	releaseChipSelect();
	return result;
}

/*
 *
 * Read the last conversion result
 * Espera a que el pin DRDY esté en LOW (activo bajo) para indicar que los datos están listos
 * antes de leer los datos del ADC.
 *
 */
int ADS124S08::dataRead(uint8_t *dStatus, uint8_t *dData, uint8_t *dCRC)
{
	if (!_initialized) return -1;
	
	// Esperar a que el pin DRDY esté en LOW (datos disponibles)
	// DRDY es activo bajo, por lo que cuando está en LOW, los datos están listos
	uint32_t timeout = millis() + 100; // Timeout de 100 ms
	while (_ioExpander->digitalRead(ADS124S08_DRDY_PIN) == HIGH) {
		// Si se supera el timeout, retornar error
		if (millis() > timeout) {
			return -1;
		}
		delayMicroseconds(100); // Pequeña pausa para no saturar el CPU
	}
	
	uint8_t xcrc;
	uint8_t xstatus;
	int iData = 0;
	selectDeviceCSLow();
	
	_spi->beginTransaction(_spiSettings);
	
	if((registers[SYS_ADDR_MASK] & 0x01) == DATA_MODE_STATUS)
	{
		xstatus = _spi->transfer(0x00);
		dStatus[0] = (uint8_t)xstatus;
	}

	// get the conversion data (3 bytes)
	uint8_t data[3];
	data[0] = _spi->transfer(0x00);
	data[1] = _spi->transfer(0x00);
	data[2] = _spi->transfer(0x00);

	// Armar el entero de 24 bits con extensión de signo
	uint32_t raw = ((uint32_t)data[0] << 16) | ((uint32_t)data[1] << 8) | data[2];
	
	// Extender el signo si el bit 23 es 1
	if (raw & 0x800000) {
		raw |= 0xFF000000;  // Extensión de signo
	}
	
	iData = (int)raw;
	
	if((registers[SYS_ADDR_MASK] & 0x02) == DATA_MODE_CRC)
	{
		xcrc = _spi->transfer(0x00);
		dCRC[0] = (uint8_t)xcrc;
	}
	
	_spi->endTransaction();
	
	releaseChipSelect();
	return iData;
}

#endif // DEVICE_TYPE_ANALOGIC

================
File: src/BLE.cpp
================
/*******************************************************************************************
 * Archivo: src/BLE.cpp
 * Descripción: Implementación unificada de la gestión BLE para el ESP32.
 *******************************************************************************************/

#include "BLE.h"

// Implementación de los métodos de la clase ServerCallbacks
void BLEHandler::ServerCallbacks::onConnect(BLEServer* pServer) {
    DEBUG_PRINTLN(F("BLE Cliente conectado"));
}

void BLEHandler::ServerCallbacks::onDisconnect(BLEServer* pServer) {
    DEBUG_PRINTLN(F("BLE Cliente desconectado, reiniciando publicidad..."));
    pServer->getAdvertising()->start();
}

// Implementación de los métodos de BLEHandler
bool BLEHandler::checkConfigMode(PCA9555& ioExpander) {
    if (digitalRead(CONFIG_PIN) == LOW) {
        DEBUG_PRINTLN("Modo configuración activado");
        unsigned long startTime = millis();
        while (digitalRead(CONFIG_PIN) == LOW) {
            if (millis() - startTime >= CONFIG_TRIGGER_TIME) {
                // Obtener configuración LoRa para el nombre BLE
                LoRaConfig loraConfig = ConfigManager::getLoRaConfig();
                String bleName = BLE_DEVICE_PREFIX + String(loraConfig.devEUI);
                
                // Inicializar BLE
                BLEDevice::init(bleName.c_str());
                BLEServer* pServer = BLEDevice::createServer();
                pServer->setCallbacks(new ServerCallbacks());
                
                // Configurar servicio BLE
                BLEService* pService = setupService(pServer);
                
                // Configurar publicidad BLE
                BLEAdvertising* pAdvertising = BLEDevice::getAdvertising();
                pAdvertising->addServiceUUID(pService->getUUID());
                pAdvertising->setScanResponse(true);
                pAdvertising->setMinPreferred(0x06);
                pAdvertising->setMinPreferred(0x12);
                pAdvertising->start();
                
                // Entrar en bucle de configuración
                runConfigLoop(ioExpander);
                return true;
            }
        }
    }
    return false;
}

BLEServer* BLEHandler::initBLE(const String& devEUI) {
    String bleName = BLE_DEVICE_PREFIX + devEUI;
    BLEDevice::init(bleName.c_str());
    BLEServer* pServer = BLEDevice::createServer();
    pServer->setCallbacks(new ServerCallbacks());
    return pServer;
}

void BLEHandler::runConfigLoop(PCA9555& ioExpander) {
    // Bucle de parpadeo del LED de configuración
    while (true) {
        ioExpander.digitalWrite(CONFIG_LED_PIN, HIGH);
        delay(500);
        ioExpander.digitalWrite(CONFIG_LED_PIN, LOW);
        delay(500);
    }
}

// Implementación de la configuración del servicio BLE
BLEService* BLEHandler::setupService(BLEServer* pServer) {
    // Crear el servicio de configuración utilizando el UUID definido
    BLEService* pService = pServer->createService(BLEUUID(BLE_SERVICE_UUID));

    // Característica del sistema - común para todos los tipos de dispositivo
    BLECharacteristic* pSystemChar = pService->createCharacteristic(
        BLEUUID(BLE_CHAR_SYSTEM_UUID),
        BLECharacteristic::PROPERTY_READ | BLECharacteristic::PROPERTY_WRITE
    );
    pSystemChar->setCallbacks(new SystemConfigCallback());

#ifdef DEVICE_TYPE_ANALOGIC
    // Para dispositivo analógico, se utilizan todas las callbacks
    
    // Característica para configuración NTC 100K
    BLECharacteristic* pNTC100KChar = pService->createCharacteristic(
        BLEUUID(BLE_CHAR_NTC100K_UUID),
        BLECharacteristic::PROPERTY_READ | BLECharacteristic::PROPERTY_WRITE
    );
    pNTC100KChar->setCallbacks(new NTC100KConfigCallback());
    
    // Característica para configuración NTC 10K
    BLECharacteristic* pNTC10KChar = pService->createCharacteristic(
        BLEUUID(BLE_CHAR_NTC10K_UUID),
        BLECharacteristic::PROPERTY_READ | BLECharacteristic::PROPERTY_WRITE
    );
    pNTC10KChar->setCallbacks(new NTC10KConfigCallback());
    
    // Característica para configuración de Conductividad
    BLECharacteristic* pCondChar = pService->createCharacteristic(
        BLEUUID(BLE_CHAR_CONDUCTIVITY_UUID),
        BLECharacteristic::PROPERTY_READ | BLECharacteristic::PROPERTY_WRITE
    );
    pCondChar->setCallbacks(new ConductivityConfigCallback());
    
    // Característica para configuración de pH
    BLECharacteristic* pPHChar = pService->createCharacteristic(
        BLEUUID(BLE_CHAR_PH_UUID),
        BLECharacteristic::PROPERTY_READ | BLECharacteristic::PROPERTY_WRITE
    );
    pPHChar->setCallbacks(new PHConfigCallback());
#endif

    // Característica para configuración de Sensores - común para BASIC y ANALOGIC
#if defined(DEVICE_TYPE_BASIC) || defined(DEVICE_TYPE_ANALOGIC) || defined(DEVICE_TYPE_MODBUS)
    BLECharacteristic* pSensorsChar = pService->createCharacteristic(
        BLEUUID(BLE_CHAR_SENSORS_UUID),
        BLECharacteristic::PROPERTY_READ | BLECharacteristic::PROPERTY_WRITE
    );
    pSensorsChar->setCallbacks(new SensorsConfigCallback());
#endif
    
    // Característica para configuración de LoRa - común para todos los tipos
    BLECharacteristic* pLoRaConfigChar = pService->createCharacteristic(
        BLEUUID(BLE_CHAR_LORA_CONFIG_UUID),
        BLECharacteristic::PROPERTY_READ | BLECharacteristic::PROPERTY_WRITE
    );
    pLoRaConfigChar->setCallbacks(new LoRaConfigCallback());
    
    pService->start();
    return pService;
}

// Implementación de SystemConfigCallback
void BLEHandler::SystemConfigCallback::onWrite(BLECharacteristic *pCharacteristic) {
    DEBUG_PRINTLN(F("DEBUG: SystemConfigCallback onWrite - JSON recibido:"));
    DEBUG_PRINTLN(pCharacteristic->getValue().c_str());
    
    // Se espera un JSON de la forma: { "system": { "initialized": <bool>, "sleep_time": <valor>, "device_id": "<valor>" } }
    StaticJsonDocument<JSON_DOC_SIZE_SMALL> doc;
    DeserializationError error = deserializeJson(doc, pCharacteristic->getValue());
    if (error) {
        DEBUG_PRINT(F("Error deserializando System config: "));
        DEBUG_PRINTLN(error.c_str());
        return;
    }
    JsonObject obj = doc[NAMESPACE_SYSTEM];
    bool initialized = obj[KEY_INITIALIZED] | false;
    uint32_t sleepTime = obj[KEY_SLEEP_TIME] | DEFAULT_TIME_TO_SLEEP;
    String deviceId = obj[KEY_DEVICE_ID] | "";
    String stationId = obj[KEY_STATION_ID] | "";
    
    DEBUG_PRINT(F("DEBUG: Configuración de sistema parseada: initialized="));
    DEBUG_PRINT(initialized);
    DEBUG_PRINT(F(", sleepTime="));
    DEBUG_PRINT(sleepTime);
    DEBUG_PRINT(F(", deviceId="));
    DEBUG_PRINT(deviceId);
    DEBUG_PRINT(F(", stationId="));
    DEBUG_PRINTLN(stationId);
    
    ConfigManager::setSystemConfig(initialized, sleepTime, deviceId, stationId);
}

void BLEHandler::SystemConfigCallback::onRead(BLECharacteristic *pCharacteristic) {
    bool initialized;
    uint32_t sleepTime;
    String deviceId;
    String stationId;
    ConfigManager::getSystemConfig(initialized, sleepTime, deviceId, stationId);
    
    StaticJsonDocument<JSON_DOC_SIZE_SMALL> doc;
    JsonObject obj = doc.createNestedObject(NAMESPACE_SYSTEM);
    obj[KEY_INITIALIZED] = initialized;
    obj[KEY_SLEEP_TIME] = sleepTime;
    obj[KEY_DEVICE_ID] = deviceId;
    obj[KEY_STATION_ID] = stationId;

    String jsonString;
    serializeJson(doc, jsonString);
    DEBUG_PRINT(F("DEBUG: SystemConfigCallback onRead - JSON enviado: "));
    DEBUG_PRINTLN(jsonString);
    pCharacteristic->setValue(jsonString.c_str());
}

#ifdef DEVICE_TYPE_ANALOGIC
// Implementación de NTC100KConfigCallback
void BLEHandler::NTC100KConfigCallback::onWrite(BLECharacteristic *pCharacteristic) {
    DEBUG_PRINTLN(F("DEBUG: NTC100KConfigCallback onWrite - JSON recibido:"));
    DEBUG_PRINTLN(pCharacteristic->getValue().c_str());

    // Se espera un JSON de la forma: { "ntc_100k": { <parámetros> } }
    StaticJsonDocument<JSON_DOC_SIZE_SMALL> fullDoc;
    DeserializationError error = deserializeJson(fullDoc, pCharacteristic->getValue());
    if (error) {
        DEBUG_PRINT(F("Error deserializando NTC100K config: "));
        DEBUG_PRINTLN(error.c_str());
        return;
    }
    JsonObject doc = fullDoc[NAMESPACE_NTC100K];
    DEBUG_PRINT(F("DEBUG: NTC100K valores parseados - T1: "));
    DEBUG_PRINT(doc[KEY_NTC100K_T1] | 0.0);
    DEBUG_PRINT(F(", R1: "));
    DEBUG_PRINT(doc[KEY_NTC100K_R1] | 0.0);
    DEBUG_PRINT(F(", T2: "));
    DEBUG_PRINT(doc[KEY_NTC100K_T2] | 0.0);
    DEBUG_PRINT(F(", R2: "));
    DEBUG_PRINT(doc[KEY_NTC100K_R2] | 0.0);
    DEBUG_PRINT(F(", T3: "));
    DEBUG_PRINT(doc[KEY_NTC100K_T3] | 0.0);
    DEBUG_PRINT(F(", R3: "));
    DEBUG_PRINTLN(doc[KEY_NTC100K_R3] | 0.0);
    
    ConfigManager::setNTC100KConfig(
        doc[KEY_NTC100K_T1] | 0.0,
        doc[KEY_NTC100K_R1] | 0.0,
        doc[KEY_NTC100K_T2] | 0.0,
        doc[KEY_NTC100K_R2] | 0.0,
        doc[KEY_NTC100K_T3] | 0.0,
        doc[KEY_NTC100K_R3] | 0.0
    );
}

void BLEHandler::NTC100KConfigCallback::onRead(BLECharacteristic *pCharacteristic) {
    double t1, r1, t2, r2, t3, r3;
    ConfigManager::getNTC100KConfig(t1, r1, t2, r2, t3, r3);
    
    DEBUG_PRINT(F("DEBUG: NTC100KConfigCallback onRead - Config: T1="));
    DEBUG_PRINT(t1);
    DEBUG_PRINT(F(", R1="));
    DEBUG_PRINT(r1);
    DEBUG_PRINT(F(", T2="));
    DEBUG_PRINT(t2);
    DEBUG_PRINT(F(", R2="));
    DEBUG_PRINT(r2);
    DEBUG_PRINT(F(", T3="));
    DEBUG_PRINT(t3);
    DEBUG_PRINT(F(", R3="));
    DEBUG_PRINTLN(r3);
    
    StaticJsonDocument<JSON_DOC_SIZE_SMALL> fullDoc;
    // Crear objeto anidado con el namespace "ntc_100k"
    JsonObject doc = fullDoc.createNestedObject(NAMESPACE_NTC100K);
    doc[KEY_NTC100K_T1] = t1;
    doc[KEY_NTC100K_R1] = r1;
    doc[KEY_NTC100K_T2] = t2;
    doc[KEY_NTC100K_R2] = r2;
    doc[KEY_NTC100K_T3] = t3;
    doc[KEY_NTC100K_R3] = r3;
    
    String jsonString;
    serializeJson(fullDoc, jsonString);
    DEBUG_PRINT(F("DEBUG: NTC100KConfigCallback onRead - JSON enviado: "));
    DEBUG_PRINTLN(jsonString);
    pCharacteristic->setValue(jsonString.c_str());
}

// Implementación de NTC10KConfigCallback
void BLEHandler::NTC10KConfigCallback::onWrite(BLECharacteristic *pCharacteristic) {
    DEBUG_PRINTLN(F("DEBUG: NTC10KConfigCallback onWrite - JSON recibido:"));
    DEBUG_PRINTLN(pCharacteristic->getValue().c_str());
    
    // Se espera JSON: { "ntc_10k": { <parámetros> } }
    StaticJsonDocument<JSON_DOC_SIZE_SMALL> fullDoc;
    DeserializationError error = deserializeJson(fullDoc, pCharacteristic->getValue());
    if (error) {
        DEBUG_PRINT(F("Error deserializando NTC10K config: "));
        DEBUG_PRINTLN(error.c_str());
        return;
    }
    JsonObject doc = fullDoc[NAMESPACE_NTC10K];
    DEBUG_PRINT(F("DEBUG: NTC10K valores parseados - T1: "));
    DEBUG_PRINT(doc[KEY_NTC10K_T1] | 0.0);
    DEBUG_PRINT(F(", R1: "));
    DEBUG_PRINT(doc[KEY_NTC10K_R1] | 0.0);
    DEBUG_PRINT(F(", T2: "));
    DEBUG_PRINT(doc[KEY_NTC10K_T2] | 0.0);
    DEBUG_PRINT(F(", R2: "));
    DEBUG_PRINT(doc[KEY_NTC10K_R2] | 0.0);
    DEBUG_PRINT(F(", T3: "));
    DEBUG_PRINT(doc[KEY_NTC10K_T3] | 0.0);
    DEBUG_PRINT(F(", R3: "));
    DEBUG_PRINTLN(doc[KEY_NTC10K_R3] | 0.0);
    
    ConfigManager::setNTC10KConfig(
        doc[KEY_NTC10K_T1] | 0.0,
        doc[KEY_NTC10K_R1] | 0.0,
        doc[KEY_NTC10K_T2] | 0.0,
        doc[KEY_NTC10K_R2] | 0.0,
        doc[KEY_NTC10K_T3] | 0.0,
        doc[KEY_NTC10K_R3] | 0.0
    );
}

void BLEHandler::NTC10KConfigCallback::onRead(BLECharacteristic *pCharacteristic) {
    double t1, r1, t2, r2, t3, r3;
    ConfigManager::getNTC10KConfig(t1, r1, t2, r2, t3, r3);
    
    DEBUG_PRINT(F("DEBUG: NTC10KConfigCallback onRead - Config: T1="));
    DEBUG_PRINT(t1);
    DEBUG_PRINT(F(", R1="));
    DEBUG_PRINT(r1);
    DEBUG_PRINT(F(", T2="));
    DEBUG_PRINT(t2);
    DEBUG_PRINT(F(", R2="));
    DEBUG_PRINT(r2);
    DEBUG_PRINT(F(", T3="));
    DEBUG_PRINT(t3);
    DEBUG_PRINT(F(", R3="));
    DEBUG_PRINTLN(r3);
    
    StaticJsonDocument<JSON_DOC_SIZE_SMALL> fullDoc;
    JsonObject doc = fullDoc.createNestedObject(NAMESPACE_NTC10K);
    doc[KEY_NTC10K_T1] = t1;
    doc[KEY_NTC10K_R1] = r1;
    doc[KEY_NTC10K_T2] = t2;
    doc[KEY_NTC10K_R2] = r2;
    doc[KEY_NTC10K_T3] = t3;
    doc[KEY_NTC10K_R3] = r3;
    
    String jsonString;
    serializeJson(fullDoc, jsonString);
    DEBUG_PRINT(F("DEBUG: NTC10KConfigCallback onRead - JSON enviado: "));
    DEBUG_PRINTLN(jsonString);
    pCharacteristic->setValue(jsonString.c_str());
}

// Implementación de ConductivityConfigCallback
void BLEHandler::ConductivityConfigCallback::onWrite(BLECharacteristic *pCharacteristic) {
    DEBUG_PRINTLN(F("DEBUG: ConductivityConfigCallback onWrite - JSON recibido:"));
    DEBUG_PRINTLN(pCharacteristic->getValue().c_str());
    
    // Se espera un JSON: { "cond": { <parámetros> } }
    StaticJsonDocument<JSON_DOC_SIZE_SMALL> fullDoc;
    DeserializationError error = deserializeJson(fullDoc, pCharacteristic->getValue());
    if (error) {
        DEBUG_PRINT(F("Error deserializando Conductivity config: "));
        DEBUG_PRINTLN(error.c_str());
        return;
    }
    JsonObject doc = fullDoc[NAMESPACE_COND];
    
    DEBUG_PRINT(F("DEBUG: Conductivity valores parseados - CT: "));
    DEBUG_PRINT(doc[KEY_CONDUCT_CT] | 0.0f);
    DEBUG_PRINT(F(", CC: "));
    DEBUG_PRINT(doc[KEY_CONDUCT_CC] | 0.0f);
    DEBUG_PRINT(F(", V1: "));
    DEBUG_PRINT(doc[KEY_CONDUCT_V1] | 0.0f);
    DEBUG_PRINT(F(", T1: "));
    DEBUG_PRINT(doc[KEY_CONDUCT_T1] | 0.0f);
    DEBUG_PRINT(F(", V2: "));
    DEBUG_PRINT(doc[KEY_CONDUCT_V2] | 0.0f);
    DEBUG_PRINT(F(", T2: "));
    DEBUG_PRINT(doc[KEY_CONDUCT_T2] | 0.0f);
    DEBUG_PRINT(F(", V3: "));
    DEBUG_PRINT(doc[KEY_CONDUCT_V3] | 0.0f);
    DEBUG_PRINT(F(", T3: "));
    DEBUG_PRINTLN(doc[KEY_CONDUCT_T3] | 0.0f);
    
    ConfigManager::setConductivityConfig(
        doc[KEY_CONDUCT_CT] | 0.0f,  // Temperatura de calibración
        doc[KEY_CONDUCT_CC] | 0.0f,  // Coeficiente de compensación
        doc[KEY_CONDUCT_V1] | 0.0f,
        doc[KEY_CONDUCT_T1] | 0.0f,
        doc[KEY_CONDUCT_V2] | 0.0f,
        doc[KEY_CONDUCT_T2] | 0.0f,
        doc[KEY_CONDUCT_V3] | 0.0f,
        doc[KEY_CONDUCT_T3] | 0.0f
    );
}

void BLEHandler::ConductivityConfigCallback::onRead(BLECharacteristic *pCharacteristic) {
    float calTemp, coefComp, v1, t1, v2, t2, v3, t3;
    ConfigManager::getConductivityConfig(calTemp, coefComp, v1, t1, v2, t2, v3, t3);
    
    DEBUG_PRINT(F("DEBUG: ConductivityConfigCallback onRead - Config: CT="));
    DEBUG_PRINT(calTemp);
    DEBUG_PRINT(F(", CC="));
    DEBUG_PRINT(coefComp);
    DEBUG_PRINT(F(", V1="));
    DEBUG_PRINT(v1);
    DEBUG_PRINT(F(", T1="));
    DEBUG_PRINT(t1);
    DEBUG_PRINT(F(", V2="));
    DEBUG_PRINT(v2);
    DEBUG_PRINT(F(", T2="));
    DEBUG_PRINT(t2);
    DEBUG_PRINT(F(", V3="));
    DEBUG_PRINT(v3);
    DEBUG_PRINT(F(", T3="));
    DEBUG_PRINTLN(t3);
    
    StaticJsonDocument<JSON_DOC_SIZE_SMALL> fullDoc;
    JsonObject doc = fullDoc.createNestedObject(NAMESPACE_COND);
    doc[KEY_CONDUCT_CT] = calTemp;
    doc[KEY_CONDUCT_CC] = coefComp;
    doc[KEY_CONDUCT_V1] = v1;
    doc[KEY_CONDUCT_T1] = t1;
    doc[KEY_CONDUCT_V2] = v2;
    doc[KEY_CONDUCT_T2] = t2;
    doc[KEY_CONDUCT_V3] = v3;
    doc[KEY_CONDUCT_T3] = t3;
    
    String jsonString;
    serializeJson(fullDoc, jsonString);
    DEBUG_PRINT(F("DEBUG: ConductivityConfigCallback onRead - JSON enviado: "));
    DEBUG_PRINTLN(jsonString);
    pCharacteristic->setValue(jsonString.c_str());
}

// Implementación de PHConfigCallback
void BLEHandler::PHConfigCallback::onWrite(BLECharacteristic *pCharacteristic) {
    DEBUG_PRINTLN(F("DEBUG: PHConfigCallback onWrite - JSON recibido:"));
    DEBUG_PRINTLN(pCharacteristic->getValue().c_str());
    
    // Se espera JSON: { "ph": { <parámetros> } }
    StaticJsonDocument<JSON_DOC_SIZE_SMALL> fullDoc;
    DeserializationError error = deserializeJson(fullDoc, pCharacteristic->getValue());
    if (error) {
        DEBUG_PRINT(F("Error deserializando pH config: "));
        DEBUG_PRINTLN(error.c_str());
        return;
    }
    JsonObject doc = fullDoc[NAMESPACE_PH];
    DEBUG_PRINT(F("DEBUG: pH valores parseados - V1: "));
    DEBUG_PRINT(doc[KEY_PH_V1] | 0.0f);
    DEBUG_PRINT(F(", T1: "));
    DEBUG_PRINT(doc[KEY_PH_T1] | 0.0f);
    DEBUG_PRINT(F(", V2: "));
    DEBUG_PRINT(doc[KEY_PH_V2] | 0.0f);
    DEBUG_PRINT(F(", T2: "));
    DEBUG_PRINT(doc[KEY_PH_T2] | 0.0f);
    DEBUG_PRINT(F(", V3: "));
    DEBUG_PRINT(doc[KEY_PH_V3] | 0.0f);
    DEBUG_PRINT(F(", T3: "));
    DEBUG_PRINT(doc[KEY_PH_T3] | 0.0f);
    DEBUG_PRINT(F(", CT: "));
    DEBUG_PRINTLN(doc[KEY_PH_CT] | 25.0f);
    
    ConfigManager::setPHConfig(
        doc[KEY_PH_V1] | 0.0f,
        doc[KEY_PH_T1] | 0.0f,
        doc[KEY_PH_V2] | 0.0f,
        doc[KEY_PH_T2] | 0.0f,
        doc[KEY_PH_V3] | 0.0f,
        doc[KEY_PH_T3] | 0.0f,
        doc[KEY_PH_CT] | 25.0f
    );
}

void BLEHandler::PHConfigCallback::onRead(BLECharacteristic *pCharacteristic) {
    float v1, t1, v2, t2, v3, t3, calTemp;
    ConfigManager::getPHConfig(v1, t1, v2, t2, v3, t3, calTemp);
    
    DEBUG_PRINT(F("DEBUG: PHConfigCallback onRead - Config: V1="));
    DEBUG_PRINT(v1);
    DEBUG_PRINT(F(", T1="));
    DEBUG_PRINT(t1);
    DEBUG_PRINT(F(", V2="));
    DEBUG_PRINT(v2);
    DEBUG_PRINT(F(", T2="));
    DEBUG_PRINT(t2);
    DEBUG_PRINT(F(", V3="));
    DEBUG_PRINT(v3);
    DEBUG_PRINT(F(", T3="));
    DEBUG_PRINT(t3);
    DEBUG_PRINT(F(", CT="));
    DEBUG_PRINTLN(calTemp);
    
    StaticJsonDocument<JSON_DOC_SIZE_SMALL> fullDoc;
    JsonObject doc = fullDoc.createNestedObject(NAMESPACE_PH);
    doc[KEY_PH_V1] = v1;
    doc[KEY_PH_T1] = t1;
    doc[KEY_PH_V2] = v2;
    doc[KEY_PH_T2] = t2;
    doc[KEY_PH_V3] = v3;
    doc[KEY_PH_T3] = t3;
    doc[KEY_PH_CT] = calTemp;
    
    String jsonString;
    serializeJson(fullDoc, jsonString);
    DEBUG_PRINT(F("DEBUG: PHConfigCallback onRead - JSON enviado: "));
    DEBUG_PRINTLN(jsonString);
    pCharacteristic->setValue(jsonString.c_str());
}
#endif // DEVICE_TYPE_ANALOGIC

#if defined(DEVICE_TYPE_BASIC) || defined(DEVICE_TYPE_ANALOGIC) || defined(DEVICE_TYPE_MODBUS)
// Implementación de SensorsConfigCallback
void BLEHandler::SensorsConfigCallback::onWrite(BLECharacteristic *pCharacteristic) {
    DEBUG_PRINTLN(F("DEBUG: SensorsConfigCallback onWrite - JSON recibido:"));
    DEBUG_PRINTLN(pCharacteristic->getValue().c_str());
    
    // Se espera un JSON: { "sensors": [ {<sensor1>}, {<sensor2>}, ... ] }
    DynamicJsonDocument doc(JSON_DOC_SIZE_LARGE);
    DeserializationError error = deserializeJson(doc, pCharacteristic->getValue());
    if (error) {
        DEBUG_PRINT(F("Error deserializando Sensors config: "));
        DEBUG_PRINTLN(error.c_str());
        return;
    }
    
    std::vector<SensorConfig> configs;
    JsonArray sensorArray = doc[NAMESPACE_SENSORS];
    
    for (JsonVariant sensor : sensorArray) {
        SensorConfig config;
        strncpy(config.configKey, sensor[KEY_SENSOR] | "", sizeof(config.configKey));
        strncpy(config.sensorId, sensor[KEY_SENSOR_ID] | "", sizeof(config.sensorId));
        config.type = static_cast<SensorType>(sensor[KEY_SENSOR_TYPE] | 0);
        config.enable = sensor[KEY_SENSOR_ENABLE] | false;
        
        DEBUG_PRINT(F("DEBUG: Sensor config parsed - key: "));
        DEBUG_PRINT(config.configKey);
        DEBUG_PRINT(F(", sensorId: "));
        DEBUG_PRINT(config.sensorId);
        DEBUG_PRINT(F(", type: "));
        DEBUG_PRINT(static_cast<int>(config.type));
        DEBUG_PRINT(F(", enable: "));
        DEBUG_PRINTLN(config.enable ? "true" : "false");
        
        configs.push_back(config);
    }
    
    ConfigManager::setSensorsConfigs(configs);
}

void BLEHandler::SensorsConfigCallback::onRead(BLECharacteristic *pCharacteristic) {
    DynamicJsonDocument doc(JSON_DOC_SIZE_LARGE);
    JsonArray sensorArray = doc.createNestedArray(NAMESPACE_SENSORS);

    std::vector<SensorConfig> configs = ConfigManager::getAllSensorConfigs();
    
    DEBUG_PRINTLN(F("DEBUG: SensorsConfigCallback onRead - Configuraciones de sensores obtenidas:"));
    for (const auto& sensor : configs) {
        DEBUG_PRINT(F("DEBUG: Sensor config - key: "));
        DEBUG_PRINT(sensor.configKey);
        DEBUG_PRINT(F(", sensorId: "));
        DEBUG_PRINT(sensor.sensorId);
        DEBUG_PRINT(F(", type: "));
        DEBUG_PRINT(static_cast<int>(sensor.type));
        DEBUG_PRINT(F(", enable: "));
        DEBUG_PRINTLN(sensor.enable ? "true" : "false");

        JsonObject obj = sensorArray.createNestedObject();
        obj[KEY_SENSOR]             = sensor.configKey;
        obj[KEY_SENSOR_ID]          = sensor.sensorId;
        obj[KEY_SENSOR_TYPE]        = static_cast<int>(sensor.type);
        obj[KEY_SENSOR_ENABLE]      = sensor.enable;
    }

    String jsonString;
    serializeJson(doc, jsonString);
    DEBUG_PRINT(F("DEBUG: SensorsConfigCallback onRead - JSON enviado: "));
    DEBUG_PRINTLN(jsonString);
    pCharacteristic->setValue(jsonString.c_str());
}
#endif

// Implementación de LoRaConfigCallback
void BLEHandler::LoRaConfigCallback::onWrite(BLECharacteristic* pCharacteristic) {
    DEBUG_PRINTLN(F("DEBUG: LoRaConfigCallback onWrite - JSON recibido:"));
    DEBUG_PRINTLN(pCharacteristic->getValue().c_str());
    
    // Se espera JSON: { "lorawan": { <parámetros> } }
    StaticJsonDocument<JSON_DOC_SIZE_SMALL> fullDoc;
    DeserializationError error = deserializeJson(fullDoc, pCharacteristic->getValue());
    if (error) {
        DEBUG_PRINT(F("Error deserializando LoRa config: "));
        DEBUG_PRINTLN(error.c_str());
        return;
    }
    JsonObject doc = fullDoc[NAMESPACE_LORAWAN];
    String joinEUI     = doc[KEY_LORA_JOIN_EUI]      | "";
    String devEUI     = doc[KEY_LORA_DEV_EUI]      | "";
    String nwkKey     = doc[KEY_LORA_NWK_KEY]      | "";
    String appKey     = doc[KEY_LORA_APP_KEY]      | "";
    
    DEBUG_PRINT(F("DEBUG: LoRa valores parseados - joinEUI: "));
    DEBUG_PRINT(joinEUI);
    DEBUG_PRINT(F(", devEUI: "));
    DEBUG_PRINT(devEUI);
    DEBUG_PRINT(F(", nwkKey: "));
    DEBUG_PRINT(nwkKey);
    DEBUG_PRINT(F(", appKey: "));
    DEBUG_PRINTLN(appKey);
    
    ConfigManager::setLoRaConfig(joinEUI, devEUI, nwkKey, appKey);
}

void BLEHandler::LoRaConfigCallback::onRead(BLECharacteristic* pCharacteristic) {
    LoRaConfig config = ConfigManager::getLoRaConfig();
    
    DEBUG_PRINTLN(F("DEBUG: LoRaConfigCallback onRead - Config obtenido:"));
    DEBUG_PRINT(F("joinEUI: "));
    DEBUG_PRINTLN(config.joinEUI);
    DEBUG_PRINT(F("devEUI: "));
    DEBUG_PRINTLN(config.devEUI);
    DEBUG_PRINT(F("nwkKey: "));
    DEBUG_PRINTLN(config.nwkKey);
    
    // Aumentamos el tamaño del documento para asegurarnos de incluir todas las claves
    StaticJsonDocument<JSON_DOC_SIZE_SMALL> fullDoc;
    JsonObject doc = fullDoc.createNestedObject(NAMESPACE_LORAWAN);
    doc[KEY_LORA_JOIN_EUI]     = config.joinEUI;
    doc[KEY_LORA_DEV_EUI]     = config.devEUI;
    doc[KEY_LORA_NWK_KEY]     = config.nwkKey;
    doc[KEY_LORA_APP_KEY]     = config.appKey;
    String jsonString;
    serializeJson(fullDoc, jsonString);
    DEBUG_PRINT(F("DEBUG: LoRaConfigCallback onRead - JSON enviado: "));
    DEBUG_PRINTLN(jsonString);
    pCharacteristic->setValue(jsonString.c_str());
}

================
File: src/HardwareManager.cpp
================
/*******************************************************************************************
 * Archivo: src/HardwareManager.cpp
 * Descripción: Implementación de la gestión de hardware del sistema.
 *******************************************************************************************/

#include "HardwareManager.h"
#include "debug.h"

// time execution < 10 ms
bool HardwareManager::initHardware(PCA9555& ioExpander, PowerManager& powerManager, SensirionI2cSht3x& sht30Sensor, SPIClass& spi) {
    #ifdef DEVICE_TYPE_ANALOGIC || DEVICE_TYPE_BASIC
    // Configurar GPIO one wire con pull-up
    pinMode(ONE_WIRE_BUS, INPUT_PULLUP);
    #endif
    
    // Inicializar I2C con pines definidos
    Wire.begin(I2C_SDA_PIN, I2C_SCL_PIN);
    
    // Inicializar SPI con pines definidos
    spi.begin(SPI_SCK_PIN, SPI_MISO_PIN, SPI_MOSI_PIN);

    //Inicializar SHT30 para reset y dummy lectura
    sht30Sensor.begin(Wire, SHT30_I2C_ADDR_44);
    sht30Sensor.stopMeasurement();
    sht30Sensor.softReset();

    // // time execution ≈ 13 ms
    // float dummyTemp = 0.0f, dummyHum = 0.0f;
    // sht30Sensor.measureSingleShot(REPEATABILITY_HIGH, false, dummyTemp, dummyHum);
    // ////////////////////////////////////////////////////////////////
    
    //Inicializar PCA9555 para expansión de I/O
    if (!ioExpander.begin()) {
        DEBUG_PRINTLN("Error al inicializar PCA9555");
        return false;
    }
    
    // Inicializar los pines de selección SPI (SS)
    initializeSPISSPins();
    
    // Inicializar PowerManager para control de energía
    powerManager.begin();
    
    return true;
}

void HardwareManager::initializeSPISSPins() {
    // Inicializar SS del LORA conectado directamente
    pinMode(LORA_NSS_PIN, OUTPUT);
    digitalWrite(LORA_NSS_PIN, HIGH);

    // Inicializar SS conectados al expansor
    extern PCA9555 ioExpander;
    ioExpander.pinMode(PT100_CS_PIN, OUTPUT); // ss de p100
    ioExpander.digitalWrite(PT100_CS_PIN, HIGH);

#ifdef DEVICE_TYPE_ANALOGIC
    ioExpander.pinMode(ADS124S08_CS_PIN, OUTPUT); // ss del adc
    ioExpander.digitalWrite(ADS124S08_CS_PIN, HIGH);
#endif
}

================
File: src/MAX31865.cpp
================
#include "MAX31865.h"
#include <math.h>   // Para sqrt

/**
 * @brief Constructor con PCA9555.
 */
MAX31865_RTD::MAX31865_RTD(
    ptd_type type,
    SPIClass& spi,
    SPISettings& spiSettings,
    PCA9555& pca,
    uint8_t pcaPinCS
)
{
  _spi = &spi;
  _spiSettings = &spiSettings;
  this->type = type;
  this->_usePCA = true;
  this->_pca = &pca;
  this->_pcaPinCS = pcaPinCS;
  this->_csPinMCU = 0xFF;
}

/**
 * @brief Constructor con pin nativo de MCU.
 */
MAX31865_RTD::MAX31865_RTD(
    ptd_type type,
    SPIClass& spi,
    SPISettings& spiSettings,
    uint8_t csPin
)
{
  _spi = &spi;
  _spiSettings = &spiSettings;
  this->type = type;
  this->_usePCA = false;
  this->_pca = nullptr;
  this->_pcaPinCS = 0xFF;
  this->_csPinMCU = csPin;
}

// -----------------------------------------------------------------------
void MAX31865_RTD::configure(bool v_bias, bool conversion_mode, bool one_shot,
                             bool three_wire, uint8_t fault_cycle, bool fault_clear,
                             bool filter_50hz,
                             uint16_t low_threshold,
                             uint16_t high_threshold)
{
  uint8_t control_bits = 0;
  // Arma la máscara
  control_bits |= (v_bias ? 0x80 : 0);
  control_bits |= (conversion_mode ? 0x40 : 0);
  control_bits |= (one_shot ? 0x20 : 0);
  control_bits |= (three_wire ? 0x10 : 0);
  control_bits |= (fault_cycle & 0b00001100);
  control_bits |= (fault_clear ? 0x02 : 0);
  control_bits |= (filter_50hz ? 0x01 : 0);

  this->configuration_control_bits   = control_bits;
  this->configuration_low_threshold  = low_threshold;
  this->configuration_high_threshold = high_threshold;

  // Llama a reconfigure() para escribir valores
  reconfigure();
}

// -----------------------------------------------------------------------
void MAX31865_RTD::reconfigure()
{
  // Inicia transacción SPI
  _spi->beginTransaction(*_spiSettings);

  // Escribe config
  setCSLow();
  _spi->transfer(0x80); // Dirección de escritura del registro config
  _spi->transfer(this->configuration_control_bits);
  setCSHigh();

  // Umbrales
  setCSLow();
  _spi->transfer(0x83); // Registro de umbrales
  _spi->transfer( (this->configuration_high_threshold >> 8) & 0xFF );
  _spi->transfer(  this->configuration_high_threshold       & 0xFF );
  _spi->transfer( (this->configuration_low_threshold  >> 8) & 0xFF );
  _spi->transfer(  this->configuration_low_threshold        & 0xFF );
  setCSHigh();

  // Cierra transacción
  _spi->endTransaction();
}

// -----------------------------------------------------------------------
uint8_t MAX31865_RTD::read_all()
{
  uint16_t combined_bytes = 0;

  _spi->beginTransaction(*_spiSettings);

  setCSLow();
  // Indica que leeremos desde la dirección 0 (se manda 0x00)
  _spi->transfer(0x00);

  // Orden de lectura: Config, RTD, High Fault Th, Low Fault Th, Status
  measured_configuration = _spi->transfer(0x00);

  combined_bytes  = ((uint16_t)_spi->transfer(0x00) << 8);
  combined_bytes |=          _spi->transfer(0x00);
  measured_resistance = (combined_bytes >> 1);

  combined_bytes  = ((uint16_t)_spi->transfer(0x00) << 8);
  combined_bytes |=          _spi->transfer(0x00);
  measured_high_threshold = (combined_bytes >> 1);

  combined_bytes  = ((uint16_t)_spi->transfer(0x00) << 8);
  combined_bytes |=          _spi->transfer(0x00);
  measured_low_threshold = (combined_bytes >> 1);

  measured_status = _spi->transfer(0x00);

  delayMicroseconds(20);
  setCSHigh();
  _spi->endTransaction();

  // Reconfigura si resistencia=0 o hay falla
  if ((measured_resistance == 0) || (measured_status != 0)) {
    reconfigure();
  }
  return measured_status;
}

// -----------------------------------------------------------------------
double MAX31865_RTD::temperature() const
{
  // Si hay error o resistencia inválida, retornar NAN
  if (measured_status != 0 || measured_resistance == 0) {
    return NAN;
  }

  // Callendar-Van Dusen
  static const double a2 = 2.0 * RTD_B;
  static const double b_sq = (RTD_A * RTD_A);
  double rtd_resistance = (type == RTD_PT100) ? RTD_RESISTANCE_PT100 : RTD_RESISTANCE_PT1000;

  double c = 1.0 - (resistance() / rtd_resistance);
  double D = b_sq - 2.0 * a2 * c;
  
  // Verificar si la ecuación cuadrática tiene solución real
  if (D < 0) {
    return NAN;
  }
  
  double tempC = (-RTD_A + sqrt(D)) / a2;

  return tempC;
}

void MAX31865_RTD::setCSLow() {
  if (_usePCA && _pca) {
    _pca->digitalWrite(_pcaPinCS, LOW);
    delayMicroseconds(5);
  } else {
    digitalWrite(_csPinMCU, LOW);
  }
}

void MAX31865_RTD::setCSHigh() {
  if (_usePCA && _pca) {
    _pca->digitalWrite(_pcaPinCS, HIGH);
  } else {
    digitalWrite(_csPinMCU, HIGH);
  }
}

double MAX31865_RTD::singleMeasurement(uint16_t conversionDelayMs) {
    // Activar BIAS
    uint8_t originalConfig = configuration_control_bits;
    configuration_control_bits |= 0x80;  // Set VBIAS on
    reconfigure();
    
    delay(10);  // Esperar a que VBIAS se estabilice
    
    // Iniciar conversión única
    configuration_control_bits |= 0x20;  // Set one-shot bit
    reconfigure();
    
    // Esperar a que la conversión termine
    delay(conversionDelayMs);
    
    // Leer resultado
    read_all();
    
    // Desactivar BIAS y one-shot
    configuration_control_bits = originalConfig;
    reconfigure();
    
    return temperature();
}

// Nuevo método begin para inicializar los pines
bool MAX31865_RTD::begin() {
    if (_usePCA && _pca) {
        _pca->pinMode(_pcaPinCS, OUTPUT);
        _pca->digitalWrite(_pcaPinCS, HIGH);
    } else {
        pinMode(_csPinMCU, OUTPUT);
        digitalWrite(_csPinMCU, HIGH);
    }
    return true;
}

================
File: src/SleepManager.cpp
================
/*******************************************************************************************
 * Archivo: src/SleepManager.cpp
 * Descripción: Implementación de la gestión del modo deep sleep para el ESP32.
 *******************************************************************************************/

#include "SleepManager.h"
#include "debug.h"
#include "LoRaManager.h"

void SleepManager::goToDeepSleep(uint32_t timeToSleep, 
                               PowerManager& powerManager,
                               PCA9555& ioExpander,
                               SX1262* radio,
                               LoRaWANNode& node,
                               uint8_t* LWsession,
                               SPIClass& spi) {
    // Guardar sesión en RTC y otras rutinas de apagado
    uint8_t *persist = node.getBufferSession();
    memcpy(LWsession, persist, RADIOLIB_LORAWAN_SESSION_BUF_SIZE);
    
    // Apagar todos los reguladores
    powerManager.allPowerOff();
    
    // Flush Serial antes de dormir
    DEBUG_FLUSH();
    DEBUG_END();
    
    // Apagar módulos
    LoRaManager::prepareForSleep(radio);
    btStop();

    // Poner el PCA9555 en modo sleep
    ioExpander.sleep();

    // Deshabilitar I2C y SPI
    Wire.end();
    spi.end();
    
    // Configurar el temporizador y GPIO para despertar
    esp_sleep_enable_timer_wakeup(timeToSleep * 1000000ULL);
    gpio_wakeup_enable((gpio_num_t)CONFIG_PIN, GPIO_INTR_LOW_LEVEL);
    esp_sleep_enable_gpio_wakeup();
    esp_deep_sleep_enable_gpio_wakeup(BIT(CONFIG_PIN), ESP_GPIO_WAKEUP_GPIO_LOW);
    
    // Configurar pines para deep sleep
    configurePinsForDeepSleep();
    
    esp_deep_sleep_start();
}

/**
 * @brief Configura los pines no utilizados en alta impedancia para reducir el consumo durante deep sleep.
 */
void SleepManager::configurePinsForDeepSleep() {
#ifdef DEVICE_TYPE_BASIC
    // Configurar pines específicos del módulo LoRa como ANALOG para DEVICE_TYPE_BASIC
    pinMode(ONE_WIRE_BUS, ANALOG);
    pinMode(BATTERY_PIN, ANALOG);

    pinMode(LORA_RST_PIN, ANALOG);
    pinMode(LORA_BUSY_PIN, ANALOG);
    pinMode(LORA_DIO1_PIN, ANALOG);
    pinMode(SPI_SCK_PIN, ANALOG);
    pinMode(SPI_MISO_PIN, ANALOG);
    pinMode(SPI_MOSI_PIN, ANALOG);

    pinMode(20, ANALOG); //Serial RX
    pinMode(21, ANALOG); //Serial TX

    pinMode(I2C_SDA_PIN, ANALOG); //I2C SDA
    pinMode(I2C_SCL_PIN, ANALOG); //I2C SCL

    pinMode(9, ANALOG); //LORA NSS

    // Configurar explícitamente LORA_NSS_PIN como salida en alto para mantener el chip select del módulo LoRa desactivado
    pinMode(LORA_NSS_PIN, OUTPUT);
    digitalWrite(LORA_NSS_PIN, HIGH);
    gpio_hold_en((gpio_num_t)LORA_NSS_PIN);
#endif

#ifdef DEVICE_TYPE_ANALOGIC
    // Configurar pines específicos del módulo LoRa como ANALOG para DEVICE_TYPE_ANALOGIC
    pinMode(FLOW_SENSOR_PIN, ANALOG);
    pinMode(ONE_WIRE_BUS, ANALOG);

    pinMode(LORA_RST_PIN, ANALOG);
    pinMode(LORA_BUSY_PIN, ANALOG);
    pinMode(LORA_DIO1_PIN, ANALOG);
    pinMode(SPI_SCK_PIN, ANALOG);
    pinMode(SPI_MISO_PIN, ANALOG);
    pinMode(SPI_MOSI_PIN, ANALOG);

    pinMode(20, ANALOG); //Serial RX
    pinMode(21, ANALOG); //Serial TX

    pinMode(I2C_SDA_PIN, ANALOG); //I2C SDA
    pinMode(I2C_SCL_PIN, ANALOG); //I2C SCL

    pinMode(9, ANALOG); //LORA NSS

    // Configurar explícitamente LORA_NSS_PIN como salida en alto para mantener el chip select del módulo LoRa desactivado
    pinMode(LORA_NSS_PIN, OUTPUT);
    digitalWrite(LORA_NSS_PIN, HIGH);
    gpio_hold_en((gpio_num_t)LORA_NSS_PIN);
#endif

#ifdef DEVICE_TYPE_MODBUS
    // Configurar pines específicos del módulo LoRa como ANALOG para DEVICE_TYPE_MODBUS
    pinMode(FLOW_SENSOR_PIN, ANALOG);
    pinMode(BATTERY_PIN, ANALOG);

    pinMode(LORA_RST_PIN, ANALOG);
    pinMode(LORA_BUSY_PIN, ANALOG);
    pinMode(LORA_DIO1_PIN, ANALOG);
    pinMode(SPI_SCK_PIN, ANALOG);
    pinMode(SPI_MISO_PIN, ANALOG);
    pinMode(SPI_MOSI_PIN, ANALOG);

    pinMode(20, ANALOG); //Serial RX
    pinMode(21, ANALOG); //Serial TX

    pinMode(I2C_SDA_PIN, ANALOG); //I2C SDA
    pinMode(I2C_SCL_PIN, ANALOG); //I2C SCL

    pinMode(9, ANALOG); //LORA NSS

    // Configurar explícitamente LORA_NSS_PIN como salida en alto para mantener el chip select del módulo LoRa desactivado
    pinMode(LORA_NSS_PIN, OUTPUT);
    digitalWrite(LORA_NSS_PIN, HIGH);
    gpio_hold_en((gpio_num_t)LORA_NSS_PIN);
#endif
}

/**
 * @brief Libera el estado de retención (hold) de los pines que fueron configurados para deep sleep.
 * Esto permite que los pines puedan ser reconfigurados adecuadamente tras salir del deep sleep.
 */
void SleepManager::releaseHeldPins() {
    // Liberar específicamente el pin NSS de LoRa
    gpio_hold_dis((gpio_num_t)LORA_NSS_PIN);
    
    // Liberar otros pines si se ha aplicado retención
    // Nota: Los pines configurados como ANALOG no necesitan liberación específica
    // ya que no se les aplica retención (gpio_hold_en)
}

================
File: include/config_manager.h
================
#pragma once
#include <Preferences.h>
#include <vector>
#include <Arduino.h>  // Se incluye para utilizar el tipo String
#include "sensor_types.h"
#include <RadioLib.h> // Añadido para RADIOLIB_LORAWAN_SESSION_BUF_SIZE
#include "config.h"

// Definición de la estructura para la configuración de LoRa
struct LoRaConfig {
    //FOR OTAA
    String joinEUI;
    String devEUI;
    String nwkKey;
    String appKey;
};

class ConfigManager {
public:
    /* =========================================================================
       INICIALIZACIÓN Y CONFIGURACIÓN DEL SISTEMA
       ========================================================================= */
    // Verificación e inicialización
    static bool checkInitialized();
    static void initializeDefaultConfig();
    
    // Configuración del sistema
    static void getSystemConfig(bool &initialized, uint32_t &sleepTime, String &deviceId, String &stationId);
    static void setSystemConfig(bool initialized, uint32_t sleepTime, const String &deviceId, const String &stationId);

    /* =========================================================================
       CONFIGURACIÓN DE SENSORES NO-MODBUS
       ========================================================================= */
    // Gestión de sensores generales
    static void setSensorsConfigs(const std::vector<SensorConfig>& configs);
    static std::vector<SensorConfig> getAllSensorConfigs();
    static std::vector<SensorConfig> getEnabledSensorConfigs();

#if defined(DEVICE_TYPE_ANALOGIC) || defined(DEVICE_TYPE_MODBUS)
    /* =========================================================================
       CONFIGURACIÓN DE SENSORES MODBUS
       ========================================================================= */
    static void setModbusSensorsConfigs(const std::vector<ModbusSensorConfig>& configs);
    static std::vector<ModbusSensorConfig> getAllModbusSensorConfigs();
    static std::vector<ModbusSensorConfig> getEnabledModbusSensorConfigs();
#endif
    
    /* =========================================================================
       CONFIGURACIÓN DE LORA
       ========================================================================= */
    static LoRaConfig getLoRaConfig();
    static void setLoRaConfig(
        const String &joinEUI, 
        const String &devEUI, 
        const String &nwkKey, 
        const String &appKey);
    
#ifdef DEVICE_TYPE_ANALOGIC
    /* =========================================================================
       CONFIGURACIÓN DE SENSORES ANALÓGICOS (Solo para dispositivo analógico)
       ========================================================================= */
    // NTC 100K
    static void getNTC100KConfig(double& t1, double& r1, double& t2, double& r2, double& t3, double& r3);
    static void setNTC100KConfig(double t1, double r1, double t2, double r2, double t3, double r3);
    
    // NTC 10K
    static void getNTC10KConfig(double& t1, double& r1, double& t2, double& r2, double& t3, double& r3);
    static void setNTC10KConfig(double t1, double r1, double t2, double r2, double t3, double r3);
    
    // Conductividad
    static void getConductivityConfig(float& calTemp, float& coefComp, 
                                    float& v1, float& t1, float& v2, float& t2, float& v3, float& t3);
    static void setConductivityConfig(float calTemp, float coefComp,
                                    float v1, float t1, float v2, float t2, float v3, float t3);
    
    // pH
    static void getPHConfig(float& v1, float& t1, float& v2, float& t2, float& v3, float& t3, float& defaultTemp);
    static void setPHConfig(float v1, float t1, float v2, float t2, float v3, float t3, float defaultTemp);
#endif

private:
    // Configuraciones por defecto
    static const SensorConfig defaultConfigs[]; // Configs no-Modbus
#if defined(DEVICE_TYPE_ANALOGIC) || defined(DEVICE_TYPE_MODBUS)
    static const ModbusSensorConfig defaultModbusSensors[]; // Configs Modbus
#endif
};

================
File: include/utilities.h
================
#ifndef UTILITIES_H
#define UTILITIES_H

#include <Arduino.h>

void parseKeyString(const String &keyStr, uint8_t *outArray, size_t expectedSize);
bool parseEUIString(const char* euiStr, uint64_t* eui);

/**
 * @brief Formatea un valor flotante con hasta 3 decimales, eliminando ceros finales.
 * @param value Valor flotante a formatear.
 * @param buffer Buffer donde se almacenará la cadena formateada.
 * @param bufferSize Tamaño del buffer.
 */
void formatFloatTo3Decimals(float value, char* buffer, size_t bufferSize);

#endif // UTILITIES_H

================
File: src/ModbusSensorManager.cpp
================
#include "ModbusSensorManager.h"
#include "config.h"    // Para SERIAL_BAUD

#if defined(DEVICE_TYPE_ANALOGIC) || defined(DEVICE_TYPE_MODBUS)

#include "ModbusMaster.h"
#include "debug.h"     // Para DEBUG_END
#include "sensor_types.h" // Para ENV4Keys
#include "sensor_constants.h" // Para SensorKeys
#include "utilities.h"
#include <string.h>

// Crear una instancia global de ModbusMaster
ModbusMaster modbus;

/**
 * @note 
 *  - Se usa la biblioteca ModbusMaster para la comunicación Modbus
 *  - Se asume que el pin DE/RE del transceiver RS485 está atado de forma que cuando
 *    se escribe en Serial, se habilita la transmisión, y al terminar, pasa a recepción.
 */

void ModbusSensorManager::beginModbus() {
    // Configurar Serial usando los parámetros definidos en config.h
    Serial.begin(MODBUS_BAUDRATE, MODBUS_SERIAL_CONFIG);
    
    // Inicializar ModbusMaster
    modbus.begin(0, Serial); // El slave ID se configurará en cada petición
}

void ModbusSensorManager::endModbus() {
    // Finalizar la comunicación Serial de Modbus
    Serial.end();
}

bool ModbusSensorManager::readHoldingRegisters(uint8_t address, uint16_t startReg, uint16_t numRegs, uint16_t* outData) {
    // Guardar los bytes recibidos para depuración posterior
    uint8_t result;
    
    // Establecer el slave ID
    modbus.begin(address, Serial);
    
    // Implementar reintentos de lectura
    for (uint8_t retry = 0; retry < MODBUS_MAX_RETRY; retry++) {
        // Registrar el tiempo de inicio para implementar timeout manual
        uint32_t startTime = millis();
        
        // Realizar la petición Modbus para leer registros holding
        result = modbus.readHoldingRegisters(startReg, numRegs);
        
        // Verificar si la lectura fue exitosa
        if (result == modbus.ku8MBSuccess) {
            // Extraer datos de los registros
            for (uint8_t i = 0; i < numRegs; i++) {
                outData[i] = modbus.getResponseBuffer(i);
            }
            
            return true;
        }
        
        // Verificar si se agotó el tiempo (timeout personalizado)
        if ((millis() - startTime) >= MODBUS_RESPONSE_TIMEOUT) {
            DEBUG_PRINTLN("Timeout en comunicación Modbus");
            break; // Salir del bucle de reintentos si se agota el tiempo
        }
        
        // Si no es el último intento, continuar con el siguiente intento
        DEBUG_PRINTF("Intento %d fallido, código: %d\n", retry + 1, result);
    }
    
    // Si llegamos aquí, todos los intentos fallaron
    DEBUG_PRINTF("Error Modbus después de %d intentos\n", MODBUS_MAX_RETRY);
    return false;
}

ModbusSensorReading ModbusSensorManager::readEnvSensor(const ModbusSensorConfig &cfg) {
    ModbusSensorReading reading;
    strncpy(reading.sensorId, cfg.sensorId, sizeof(reading.sensorId));
    reading.type = cfg.type;
    reading.subValues.clear();

    // Lectura de 8 registros (500..507)
    const uint16_t startReg = 500;
    const uint16_t numRegs = 8;
    uint16_t rawData[8];
    memset(rawData, 0, sizeof(rawData));

    // Definir las claves para cada valor usando las constantes
    const char* keys[] = {
        ENV4_KEY_HUMIDITY,
        ENV4_KEY_TEMPERATURE,
        ENV4_KEY_PRESSURE,
        ENV4_KEY_ILLUMINATION
    };
    
    bool ok = readHoldingRegisters(cfg.address, startReg, numRegs, rawData);
    if (!ok) {
        // Llenar con NAN si fallo, pero usando las claves correctas
        for (int i=0; i<4; i++){
            SubValue sv;
            strncpy(sv.key, keys[i], sizeof(sv.key));
            sv.value = NAN;
            reading.subValues.push_back(sv);
        }
        return reading;
    }

    // Extraer segun datasheet (versión 4 en 1):
    // rawData[0] = Humedad entera *10
    // rawData[1] = Temp entera *10 (16 bits con posible signo)
    // rawData[5] = Presion *10 (en kPa)
    // rawData[6] = LuxHigh (32 bits -> parte alta)
    // rawData[7] = LuxLow  (32 bits -> parte baja)
    // Los demás registros (ruido, PM2.5, PM10) vienen en 0 y se ignoran

    // Humedad
    {
        SubValue sH;
        strncpy(sH.key, keys[0], sizeof(sH.key)); 
        sH.value = rawData[0] / 10.0f;
        reading.subValues.push_back(sH);
    }
    // Temperatura
    {
        SubValue sT;
        strncpy(sT.key, keys[1], sizeof(sT.key));
        // Ver si es negativo
        int16_t temp16 = (int16_t)rawData[1];
        sT.value = temp16 / 10.0f;
        reading.subValues.push_back(sT);
    }
    // Presion
    {
        SubValue sP;
        strncpy(sP.key, keys[2], sizeof(sP.key));
        sP.value = rawData[5] / 10.0f;  // kPa
        reading.subValues.push_back(sP);
    }
    // Lux
    {
        uint32_t luxHigh = rawData[6];
        uint32_t luxLow  = rawData[7];
        uint32_t fullLux = (luxHigh << 16) | luxLow; 
        SubValue sL;
        strncpy(sL.key, keys[3], sizeof(sL.key));
        sL.value = (float)fullLux;
        reading.subValues.push_back(sL);
    }

    return reading;
}

#endif // defined(DEVICE_TYPE_ANALOGIC) || defined(DEVICE_TYPE_MODBUS)

================
File: src/utilities.cpp
================
#include <Arduino.h>  // Agregar esta línea para definir la clase String
#include <cmath>     // Necesario para pow, round y fabs
#include "utilities.h"

// Función auxiliar para convertir un string tipo 
// "EE,F1,30,98,6A,11,4E,69,D0,DE,8A,DC,D6,8D,28,A6"
// en un array de 16 bytes
void parseKeyString(const String &keyStr, uint8_t *outArray, size_t expectedSize) {
    int index = 0;
    int start = 0;
    while (index < expectedSize && start < keyStr.length()) {
        int comma = keyStr.indexOf(',', start);
        String byteStr;
        if (comma == -1) {
            byteStr = keyStr.substring(start);
            start = keyStr.length();
        } else {
            byteStr = keyStr.substring(start, comma);
            start = comma + 1;
        }
        outArray[index] = (uint8_t)strtol(byteStr.c_str(), NULL, 16);
        index++;
    }
}

bool parseEUIString(const char* euiStr, uint64_t* eui) {
    char temp[3];
    uint8_t bytes[8];
    const char* ptr = euiStr;
    
    // Parsear 8 bytes
    for (int i = 0; i < 8; i++) {
        // Copiar dos caracteres hexadecimales
        strncpy(temp, ptr, 2);
        temp[2] = '\0';
        
        // Convertir string hex a byte
        bytes[i] = strtoul(temp, nullptr, 16);
        
        // Avanzar al siguiente par de caracteres, saltando la coma si existe
        ptr += (ptr[2] == ',') ? 3 : 2;
    }
    
    // Convertir los 8 bytes a uint64_t
    *eui = 0;
    for (int i = 0; i < 8; i++) {
        *eui = (*eui << 8) | bytes[i];
    }
    
    return true;
} 

/**
 * @brief Formatea un valor flotante con hasta 3 decimales, eliminando ceros finales.
 * @param value Valor flotante a formatear.
 * @param buffer Buffer donde se almacenará la cadena formateada.
 * @param bufferSize Tamaño del buffer.
 */
void formatFloatTo3Decimals(float value, char* buffer, size_t bufferSize) {
    // Primero formateamos con 3 decimales
    snprintf(buffer, bufferSize, "%.3f", value);
    
    // Luego eliminamos los ceros a la derecha y el punto si no hay decimales
    int len = strlen(buffer);
    int i = len - 1;
    
    // Retroceder mientras haya ceros al final
    while (i >= 0 && buffer[i] == '0') {
        i--;
    }
    
    // Si el último carácter es un punto, también lo eliminamos
    if (i >= 0 && buffer[i] == '.') {
        buffer[i] = '\0';
    } else {
        // Si no, terminamos la cadena después del último dígito no cero
        buffer[i + 1] = '\0';
    }
}

================
File: include/LoRaManager.h
================
/*******************************************************************************************
 * Archivo: include/LoRaManager.h
 * Descripción: Gestión de comunicaciones LoRa y LoRaWAN para el sistema de sensores.
 * Incluye funciones para inicialización, activación y envío de datos.
 *******************************************************************************************/

#ifndef LORA_MANAGER_H
#define LORA_MANAGER_H

#include <Arduino.h>
#include <RadioLib.h>
#include <vector>
#include <ArduinoJson.h>
#include "config_manager.h"
#include "utilities.h"
#include "sensor_types.h"
#include <RTClib.h>
#include "SensorManager.h"

// Código de error personalizado para fallo en sincronización RTC
#define RADIOLIB_ERR_RTC_SYNC_FAILED -5000

class LoRaManager {
public:
    /**
     * @brief Inicializa el módulo LoRa con la configuración especificada
     * @param radio Puntero al módulo de radio SX1262
     * @param region Región LoRaWAN a utilizar
     * @param subBand Sub-banda para la región (relevante para US915)
     * @return Estado de la inicialización
     */
    static int16_t begin(SX1262* radio, const LoRaWANBand_t* region, uint8_t subBand);

    /**
     * @brief Activa el nodo LoRaWAN restaurando la sesión o realizando un nuevo join
     * @param node Referencia al nodo LoRaWAN
     * @return Estado de la activación
     */
    static int16_t lwActivate(LoRaWANNode& node);

    /**
     * @brief Crea un payload optimizado con formato delimitado por | y , en lugar de JSON.
     * @param readings Vector con lecturas de sensores.
     * @param deviceId ID del dispositivo.
     * @param stationId ID de la estación.
     * @param battery Valor de la batería.
     * @param timestamp Timestamp del sistema.
     * @param buffer Buffer donde se almacenará el payload.
     * @param bufferSize Tamaño del buffer.
     * @return Tamaño del payload generado.
     */
    static size_t createDelimitedPayload(
        const std::vector<SensorReading>& readings,
        const String& deviceId,
        const String& stationId,
        float battery,
        uint32_t timestamp,
        char* buffer,
        size_t bufferSize
    );

#if defined(DEVICE_TYPE_ANALOGIC) || defined(DEVICE_TYPE_MODBUS)
    /**
     * @brief Crea un payload optimizado con formato delimitado para sensores normales y Modbus.
     * @param normalReadings Vector con lecturas de sensores normales.
     * @param modbusReadings Vector con lecturas de sensores Modbus.
     * @param deviceId ID del dispositivo.
     * @param stationId ID de la estación.
     * @param battery Valor de la batería.
     * @param timestamp Timestamp del sistema.
     * @param buffer Buffer donde se almacenará el payload.
     * @param bufferSize Tamaño del buffer.
     * @return Tamaño del payload generado.
     */
    static size_t createDelimitedPayload(
        const std::vector<SensorReading>& normalReadings,
        const std::vector<ModbusSensorReading>& modbusReadings,
        const String& deviceId,
        const String& stationId,
        float battery,
        uint32_t timestamp,
        char* buffer,
        size_t bufferSize
    );
#endif

    /**
     * @brief Envía el payload de sensores estándar usando formato delimitado.
     * @param readings Vector con todas las lecturas de sensores.
     * @param node Referencia al nodo LoRaWAN
     * @param deviceId ID del dispositivo
     * @param stationId ID de la estación
     * @param rtc Referencia al RTC para obtener timestamp
     */
    static void sendDelimitedPayload(const std::vector<SensorReading>& readings, 
                                   LoRaWANNode& node,
                                   const String& deviceId, 
                                   const String& stationId, 
                                   RTC_DS3231& rtc);

#if defined(DEVICE_TYPE_ANALOGIC) || defined(DEVICE_TYPE_MODBUS)
    /**
     * @brief Envía el payload de sensores estándar y Modbus usando formato delimitado.
     * @param normalReadings Vector con lecturas de sensores estándar
     * @param modbusReadings Vector con lecturas de sensores Modbus
     * @param node Referencia al nodo LoRaWAN
     * @param deviceId ID del dispositivo
     * @param stationId ID de la estación
     * @param rtc Referencia al RTC para obtener timestamp
     */
    static void sendDelimitedPayload(const std::vector<SensorReading>& normalReadings, 
                                   const std::vector<ModbusSensorReading>& modbusReadings,
                                   LoRaWANNode& node,
                                   const String& deviceId, 
                                   const String& stationId, 
                                   RTC_DS3231& rtc);
#endif

    /**
     * @brief Prepara el módulo LoRa para entrar en modo sleep
     * @param radio Puntero al módulo de radio SX1262
     */
    static void prepareForSleep(SX1262* radio);

    /**
     * @brief Configura el datarate para la transmisión
     * @param node Referencia al nodo LoRaWAN
     * @param datarate Valor del datarate a configurar
     */
    static void setDatarate(LoRaWANNode& node, uint8_t datarate);

private:
    static LoRaWANNode* node;
    static SX1262* radioModule;

};

#endif // LORA_MANAGER_H

================
File: platformio.ini
================
; PlatformIO Project Configuration File
;
;   Build options: build flags, source filter
;   Upload options: custom upload port, speed and extra flags
;   Library options: dependencies, extra library storages
;   Advanced options: extra scripting
;
; Please visit documentation for the other options and examples
; https://docs.platformio.org/page/projectconf.html

[env:esp32-c3-devkitc-02]
platform = espressif32
board = esp32-c3-devkitc-02
framework = arduino
lib_deps = 
	adafruit/RTClib@^2.1.1
	paulstoffregen/OneWire@^2.3.7
	milesburton/DallasTemperature@^3.11.0
	SPI
	Wire
	BLE
	jgromes/RadioLib@^6.6.0
	bblanchon/ArduinoJson@^6.21.4
	sensirion/Sensirion I2C SHT3x@^1.0.1
upload_speed = 921600
monitor_speed = 115200

================
File: src/clsPCA9555.cpp
================
/**
 * @file    clsPCA9555.cpp
 * @author     Nico Verduin
 * @date      9-8-2015
 *
 * @mainpage  clsPCA9555
 * Class to enable pinMode(), digitalRead() and digitalWrite() functions on PCA9555 IO expanders
 *
 * Additional input received from Rob Tillaart (9-8-2015)
 *
 * @par License info
 *
 * Class to enable the use of single pins on PCA9555 IO Expander using
 * pinMode(), digitalRead() and digitalWrite().
 *
 * Copyright (C) 2015  Nico Verduin
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Program : clsPCA9555  Copyright (C) 2015  Nico Verduin
 * This is free software, and you are welcome to redistribute it.
 *
 */

#if defined(ARDUINO) && ARDUINO >= 100
#include "Arduino.h"
#else
#include "WProgram.h"
#endif

#include "clsPCA9555.h"
#include "Wire.h"
#include "debug.h"

PCA9555* PCA9555::instancePointer = 0;

/**
 * @name PCA9555 constructor
 * @param address I2C address of the IO Expander
 * Creates the class interface and sets the I2C Address of the port
 */
PCA9555::PCA9555(uint8_t address, int interruptPin) {
    _address         = address;        // save the address id
    _valueRegister   = 0;
    Wire.begin();                      // start I2C communication

    if(interruptPin >= 0)
    {
    instancePointer = this;
    attachInterrupt(digitalPinToInterrupt(interruptPin), PCA9555::alertISR, LOW); // Set to low for button presses
    }
}

PCA9555::PCA9555(uint8_t address, int sda, int scl, int interruptPin) {
    _address = address;
    _sda = sda;
    _scl = scl;
    _valueRegister = 0;
    Wire.begin(sda, scl); // Inicia I2C con los pines especificados

    if (interruptPin >= 0) {
        instancePointer = this;
        attachInterrupt(digitalPinToInterrupt(interruptPin), PCA9555::alertISR, LOW);
    }
}

// Checks if PCA9555 is responsive. Refer to Wire.endTransmission() from Arduino for details.
bool PCA9555::begin() {

    // Intentar varias veces la inicialización
    for (int intento = 0; intento < 3; intento++) {
        Wire.beginTransmission(_address);
        Wire.write(0x02);
        _error = Wire.endTransmission();

        if (_error == 0) {
            // Configuración inicial
            _valueRegister = 0x0000;          
            _configurationRegister = 0x0000;
            
            // Añadir pequeños delays entre escrituras I2C
            I2CSetValue(_address, NXP_OUTPUT, _valueRegister_low);
            delayMicroseconds(100);
            I2CSetValue(_address, NXP_OUTPUT + 1, _valueRegister_high);
            delayMicroseconds(100);
            I2CSetValue(_address, NXP_CONFIG, _configurationRegister_low);
            delayMicroseconds(100);
            I2CSetValue(_address, NXP_CONFIG + 1, _configurationRegister_high);

            return true;
        }
        
        delayMicroseconds(100);  // Esperar antes del siguiente intento
    }
    
    return false;
}

/**
 * @name pinMode
 * @param pin       pin number
 * @param IOMode    mode of pin INPUT or OUTPUT
 * sets the mode of this IO pin
 */
void PCA9555::pinMode(uint8_t pin, uint8_t IOMode) {

    //
    // check if valid pin first
    //
    if (pin <= 15) {
        //
        // now set the correct bit in the configuration register
        //
        if (IOMode == OUTPUT) {
            //
            // mask correct bit to 0 by inverting x so that only
            // the correct bit is LOW. The rest stays HIGH
            //
            _configurationRegister = _configurationRegister & ~(1 << pin);
        } else {
            //
            // or just the required bit to 1
            //
            _configurationRegister = _configurationRegister | (1 << pin);
        }
        //
        // write configuration register to chip
        //
        I2CSetValue(_address, NXP_CONFIG    , _configurationRegister_low);
        I2CSetValue(_address, NXP_CONFIG + 1, _configurationRegister_high);
    }
}
/**
 * @name digitalRead Reads the high/low value of specified pin
 * @param pin
 * @return value of pin
 * Reads the selected pin.
 */
uint8_t PCA9555::digitalRead(uint8_t pin) {
    uint16_t _inputData = 0;
    //
    // we wil only process pins <= 15
    //
    if (pin > 15 ) return 255;
    _inputData  = I2CGetValue(_address, NXP_INPUT);
    _inputData |= I2CGetValue(_address, NXP_INPUT + 1) << 8;
    //
    // now mask the bit required and see if it is a HIGH
    //
    if ((_inputData & (1 << pin)) > 0){
        //
        // the bit is HIGH otherwise we would return a LOW value
        //
        return HIGH;
    } else {
        return LOW;
    }
}

void PCA9555::digitalWrite(uint8_t pin, uint8_t value) {
    //
    // check valid pin first
    //
    if (pin > 15 ){
        _error = 255;            // invalid pin
        return;                  // exit
    }
    //
    // if the value is LOW we will and the register value with correct bit set to zero
    // if the value is HIGH we will or the register value with correct bit set to HIGH
    //
    if (value > 0) {
        //
        // this is a High value so we will or it with the value register
        //
        _valueRegister = _valueRegister | (1 << pin);    // and OR bit in register
    } else {
        //
        // this is a LOW value so we have to AND it with 0 into the _valueRegister
        //
        _valueRegister = _valueRegister & ~(1 << pin);    // AND all bits
    }
    I2CSetValue(_address, NXP_OUTPUT    , _valueRegister_low);
    I2CSetValue(_address, NXP_OUTPUT + 1, _valueRegister_high);
}

// This is the actual ISR
// Stores states of all pins in _stateOfPins
void PCA9555::pinStates(){
  _stateOfPins = I2CGetValue(_address, NXP_INPUT);
  _stateOfPins|= I2CGetValue(_address, NXP_INPUT + 1) << 8;
}

// Returns to user the state of desired pin
uint8_t PCA9555::stateOfPin(uint8_t pin){
  if ((_stateOfPins & (1 << pin)) > 0){
    //
    // the bit is HIGH otherwise we would return a LOW value
    //
    return HIGH;
  } else {
    return LOW;
  }
}

/**
 * @name setClock modifies the clock frequency for I2C communication
 * @param clockFrequency
 * clockFrequency: the value (in Hertz) of desired communication clock.
 * The PCA9555 supports a 400kHz clock.
 * Accepted values are:
 *    10000 low speed mode, supported on some processors
 *    100000, standard mode
 *    400000, fast mode
 */
void PCA9555::setClock(uint32_t clockFrequency){
  Wire.setClock(clockFrequency);
}

void PCA9555::alertISR()
{
  if (instancePointer != 0)
  {
    instancePointer->pinStates(); // Points to the actual ISR
  }
}

//
// low level hardware methods
//

/**
 * @name I2CGetValue
 * @param address Address of I2C chip
 * @param reg    Register to read from
 * @return data in register
 * Reads the data from addressed chip at selected register. \n
 * If the value is above 255, an error is set. \n
 * error codes : \n
 * 256 = either 0 or more than one byte is received from the chip
 */
uint16_t PCA9555::I2CGetValue(uint8_t address, uint8_t reg) {
    uint16_t _inputData;
    //
    // read the address input register
    //
    Wire.beginTransmission(address);          // setup read registers
    Wire.write(reg);
    _error = Wire.endTransmission();
    //
    // ask for 2 bytes to be returned
    //
    if (Wire.requestFrom((int)address, 1) != 1)
    {
        //
        // we are not receing the bytes we need
        //
        return 256;                            // error code is above normal data range
    };
    //
    // read both bytes
    //
    _inputData = Wire.read();
    return _inputData;
}

/**
 * @name I2CSetValue(uint8_t address, uint8_t reg, uint8_t value)
 * @param address Address of I2C chip
 * @param reg    register to write to
 * @param value    value to write to register
 * Write the value given to the register set to selected chip.
 */
void PCA9555::I2CSetValue(uint8_t address, uint8_t reg, uint8_t value){
    //
    // write output register to chip
    //
    Wire.beginTransmission(address);              // setup direction registers
    Wire.write(reg);                              // pointer to configuration register address 0
    Wire.write(value);                            // write config register low byte
    _error = Wire.endTransmission();
}

void PCA9555::sleep() {
    // 1) Prepara registros locales (16 bits) para la configuración y el valor de salida
    //    Empezamos con todo en 0 (por defecto, consideraremos OUTPUT=0 y LOW=0).
    uint16_t tempConfig = 0x0000;  // 0 => OUTPUT, 1 => INPUT
    uint16_t tempOutput = 0x0000;  // 0 => LOW,    1 => HIGH

#ifdef DEVICE_TYPE_BASIC
    // Configuración para dispositivo BASIC
    // Para los pines que sean INPUT (por ejemplo pin 2, 5, 6, 7, 10...15),
    // ponemos su bit correspondiente en 1 dentro de tempConfig.
    // Ejemplo: pin 2 como INPUT => set bit 2 de tempConfig a 1:
    tempConfig |= (1 << 1);   // pin 1 => INPUT
    tempConfig |= (1 << 2);   // pin 2 => INPUT
    tempConfig |= (1 << 4);   // pin 4 => INPUT
    tempConfig |= (1 << 5);   // pin 5 => INPUT
    tempConfig |= (1 << 6);   // pin 6 => INPUT
    tempConfig |= (1 << 11);  // pin 11 => INPUT
    tempConfig |= (1 << 12);  // pin 12 => INPUT
    tempConfig |= (1 << 13);  // pin 13 => INPUT
    tempConfig |= (1 << 14);  // pin 14 => INPUT
    tempConfig |= (1 << 15);  // pin 15 => INPUT
    // Si no se pone un bit en 1 explícitamente, queda en 0 => OUTPUT.

    // Para los pines que son OUTPUT y queramos poner en HIGH (p. ej. pin 1, 4, 9),
    // establecemos el bit correspondiente en tempOutput:
    tempOutput |= (1 << 3);  // pin 3 => HIGH //ss de pt100
    // Los pines OUTPUT sin setear aquí quedan en LOW (por defecto tempOutput=0).
#endif

#ifdef DEVICE_TYPE_MODBUS
    // Configuración para dispositivo MODBUS
    //Power manager commentados para que esten como output bajo
    //tempConfig |= (1 << 0);  // pin 1 => INPUT
    //tempOutput |= (1 << 1);  // pin 1 => INPUT

    //unused pins
    tempConfig |= (1 << 2);  // pin 11 => INPUT
    tempConfig |= (1 << 3);  // pin 12 => INPUT //cs de pt100, gasta menos con estado input flotante
    tempConfig |= (1 << 4);  // pin 12 => INPUT
    tempConfig |= (1 << 5);  // pin 13 => INPUT
    tempConfig |= (1 << 6);  // pin 14 => INPUT
    tempConfig |= (1 << 11);  // pin 11 => INPUT
    tempConfig |= (1 << 12);  // pin 12 => INPUT
    tempConfig |= (1 << 13);  // pin 13 => INPUT
    tempConfig |= (1 << 14);  // pin 14 => INPUT
    tempConfig |= (1 << 15);  // pin 15 => INPUT

    //Actuadores se quedan en output bajo
    tempConfig |= (1 << 7);  // pin 15 => INPUT
    tempConfig |= (1 << 8);  // pin 15 => INPUT

    // //Leds comentados para que sean output bajo
    // tempConfig |= (1 << 9);  // pin 15 => INPUT
    // tempConfig |= (1 << 10);  // pin 15 => INPUT
    tempOutput |= (0 << 9);  // pin 9 => LOW //ss de pt100
    tempOutput |= (0 << 10);  // pin 10 => LOW //ss de pt100
#endif

#ifdef DEVICE_TYPE_ANALOGIC
    // Configuración para dispositivo ANALOGIC
    // Para los pines que sean INPUT, ponemos su bit correspondiente en 1 dentro de tempConfig
    tempConfig |= (1 << 1);   // pin 1 => INPUT
    tempConfig |= (1 << 2);   // pin 2 => INPUT
    tempConfig |= (1 << 4);   // pin 4 => INPUT
    tempConfig |= (1 << 5);   // pin 5 => INPUT
    tempConfig |= (1 << 6);   // pin 6 => INPUT
    tempConfig |= (1 << 10);  // pin 10 => INPUT //Entrada analógica
    tempConfig |= (1 << 11);  // pin 11 => INPUT
    tempConfig |= (1 << 12);  // pin 12 => INPUT
    tempConfig |= (1 << 13);  // pin 13 => INPUT
    tempConfig |= (1 << 14);  // pin 14 => INPUT
    tempConfig |= (1 << 15);  // pin 15 => INPUT
    
    // Para los pines que son OUTPUT y queramos poner en HIGH
    tempOutput |= (1 << 3);   // pin 3 => HIGH //ss de pt100
    tempOutput |= (1 << 8);   // pin 8 => HIGH //Activación de circuito analógico
#endif

    // -------------------------------------------------------------
    // 2) Volcamos estos valores a las variables miembros y escribimos en el PCA9555
    //    Primero el registro de OUTPUT, luego el de CONFIG.
    //    (OJO: cuando un pin es INPUT, da igual el bit de salida que pongas).
    _valueRegister         = tempOutput;
    _configurationRegister = tempConfig;

    I2CSetValue(_address, NXP_OUTPUT, _valueRegister_low);
    I2CSetValue(_address, NXP_OUTPUT + 1, _valueRegister_high);

    I2CSetValue(_address, NXP_CONFIG, _configurationRegister_low);
    I2CSetValue(_address, NXP_CONFIG + 1, _configurationRegister_high);
}

================
File: src/config_manager.cpp
================
#include "config_manager.h"
#include <ArduinoJson.h>
#include <vector>
#include "config.h"
#include "sensor_types.h"
#include <Preferences.h>
#include <Arduino.h> // Incluido para usar Serial

/* =========================================================================
   FUNCIONES AUXILIARES
   ========================================================================= */
// Funciones auxiliares para leer y escribir el JSON completo en cada namespace.
static void writeNamespace(const char* ns, const StaticJsonDocument<JSON_DOC_SIZE_MEDIUM>& doc) {
    Preferences prefs;
    prefs.begin(ns, false);
    String jsonString;
    serializeJson(doc, jsonString);
    // Se usa el mismo nombre del namespace como clave interna
    prefs.putString(ns, jsonString.c_str());
    prefs.end();
}

static void readNamespace(const char* ns, StaticJsonDocument<JSON_DOC_SIZE_MEDIUM>& doc) {
    Preferences prefs;
    prefs.begin(ns, true);
    String jsonString = prefs.getString(ns, "{}");
    prefs.end();
    deserializeJson(doc, jsonString);
}

// Configuración por defecto de sensores NO-modbus
const SensorConfig ConfigManager::defaultConfigs[] = DEFAULT_SENSOR_CONFIGS;

/* =========================================================================
   INICIALIZACIÓN Y CONFIGURACIÓN DEL SISTEMA
   ========================================================================= */
bool ConfigManager::checkInitialized() {
    StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
    readNamespace(NAMESPACE_SYSTEM, doc);
    return doc[KEY_INITIALIZED] | false;
}

void ConfigManager::initializeDefaultConfig() {
    /* -------------------------------------------------------------------------
       1. INICIALIZACIÓN DE CONFIGURACIÓN DEL SISTEMA
       ------------------------------------------------------------------------- */
    // Sistema unificado: NAMESPACE_SYSTEM (incluye system, sleep y device)
    // Común para todos los tipos de dispositivo
    {
        StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
        doc[KEY_STATION_ID] = DEFAULT_STATION_ID;
        doc[KEY_INITIALIZED] = true;
        doc[KEY_SLEEP_TIME] = DEFAULT_TIME_TO_SLEEP;
        doc[KEY_DEVICE_ID] = DEFAULT_DEVICE_ID;
        writeNamespace(NAMESPACE_SYSTEM, doc);
    }
    
#ifdef DEVICE_TYPE_ANALOGIC
    /* -------------------------------------------------------------------------
       2. INICIALIZACIÓN DE SENSORES ANALÓGICOS (Solo para dispositivo analógico)
       ------------------------------------------------------------------------- */
    // NTC 100K: NAMESPACE_NTC100K
    {
        StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
        doc[KEY_NTC100K_T1] = DEFAULT_T1_100K;
        doc[KEY_NTC100K_R1] = DEFAULT_R1_100K;
        doc[KEY_NTC100K_T2] = DEFAULT_T2_100K;
        doc[KEY_NTC100K_R2] = DEFAULT_R2_100K;
        doc[KEY_NTC100K_T3] = DEFAULT_T3_100K;
        doc[KEY_NTC100K_R3] = DEFAULT_R3_100K;
        writeNamespace(NAMESPACE_NTC100K, doc);
    }
    
    // NTC 10K: NAMESPACE_NTC10K
    {
        StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
        doc[KEY_NTC10K_T1] = DEFAULT_T1_10K;
        doc[KEY_NTC10K_R1] = DEFAULT_R1_10K;
        doc[KEY_NTC10K_T2] = DEFAULT_T2_10K;
        doc[KEY_NTC10K_R2] = DEFAULT_R2_10K;
        doc[KEY_NTC10K_T3] = DEFAULT_T3_10K;
        doc[KEY_NTC10K_R3] = DEFAULT_R3_10K;
        writeNamespace(NAMESPACE_NTC10K, doc);
    }
    
    // Conductividad: NAMESPACE_COND
    {
        StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
        doc[KEY_CONDUCT_CT] = CONDUCTIVITY_DEFAULT_TEMP;
        doc[KEY_CONDUCT_CC] = TEMP_COEF_COMPENSATION;
        doc[KEY_CONDUCT_V1] = CONDUCTIVITY_DEFAULT_V1;
        doc[KEY_CONDUCT_T1] = CONDUCTIVITY_DEFAULT_T1;
        doc[KEY_CONDUCT_V2] = CONDUCTIVITY_DEFAULT_V2;
        doc[KEY_CONDUCT_T2] = CONDUCTIVITY_DEFAULT_T2;
        doc[KEY_CONDUCT_V3] = CONDUCTIVITY_DEFAULT_V3;
        doc[KEY_CONDUCT_T3] = CONDUCTIVITY_DEFAULT_T3;
        writeNamespace(NAMESPACE_COND, doc);
    }
    
    // pH: NAMESPACE_PH
    {
        StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
        doc[KEY_PH_V1] = PH_DEFAULT_V1;
        doc[KEY_PH_T1] = PH_DEFAULT_T1;
        doc[KEY_PH_V2] = PH_DEFAULT_V2;
        doc[KEY_PH_T2] = PH_DEFAULT_T2;
        doc[KEY_PH_V3] = PH_DEFAULT_V3;
        doc[KEY_PH_T3] = PH_DEFAULT_T3;
        doc[KEY_PH_CT] = PH_DEFAULT_TEMP;
        writeNamespace(NAMESPACE_PH, doc);
    }
#endif
    
    /* -------------------------------------------------------------------------
       3. INICIALIZACIÓN DE SENSORES NO-MODBUS
       ------------------------------------------------------------------------- */
    {
        Preferences prefs;
        prefs.begin(NAMESPACE_SENSORS, false);
        StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
        JsonArray sensorArray = doc.to<JsonArray>(); // Array raíz

        for (const auto& config : ConfigManager::defaultConfigs) {
            JsonObject sensorObj = sensorArray.createNestedObject();
            sensorObj[KEY_SENSOR] = config.configKey;
            sensorObj[KEY_SENSOR_ID] = config.sensorId;
            sensorObj[KEY_SENSOR_TYPE] = static_cast<int>(config.type);
            sensorObj[KEY_SENSOR_ENABLE] = config.enable;
        }
        
        String jsonString;
        serializeJson(doc, jsonString);
        prefs.putString(NAMESPACE_SENSORS, jsonString.c_str());
        prefs.end();
    }
    
    /* -------------------------------------------------------------------------
       4. INICIALIZACIÓN DE CONFIGURACIÓN DE LORA
       ------------------------------------------------------------------------- */
    {
        StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
        doc[KEY_LORA_JOIN_EUI]      = DEFAULT_JOIN_EUI;
        doc[KEY_LORA_DEV_EUI]       = DEFAULT_DEV_EUI;
        doc[KEY_LORA_NWK_KEY]       = DEFAULT_NWK_KEY;
        doc[KEY_LORA_APP_KEY]       = DEFAULT_APP_KEY;
        writeNamespace(NAMESPACE_LORAWAN, doc);
    }

#if defined(DEVICE_TYPE_MODBUS) || defined(DEVICE_TYPE_ANALOGIC)
    /* -------------------------------------------------------------------------
       5. INICIALIZACIÓN DE SENSORES MODBUS
       ------------------------------------------------------------------------- */
    {
        Preferences prefs;
        prefs.begin(NAMESPACE_SENSORS_MODBUS, false);
        StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
        JsonArray sensorArray = doc.to<JsonArray>(); 

        // Cargamos un default (definido en config.h)
        static const ModbusSensorConfig defaultModbusSensors[] = DEFAULT_MODBUS_SENSOR_CONFIGS;
        size_t count = sizeof(defaultModbusSensors)/sizeof(defaultModbusSensors[0]);

        for (size_t i = 0; i < count; i++) {
            JsonObject sensorObj = sensorArray.createNestedObject();
            sensorObj[KEY_MODBUS_SENSOR_ID]    = defaultModbusSensors[i].sensorId;
            sensorObj[KEY_MODBUS_SENSOR_TYPE]  = (int)defaultModbusSensors[i].type;
            sensorObj[KEY_MODBUS_SENSOR_ADDR] = defaultModbusSensors[i].address;
            sensorObj[KEY_MODBUS_SENSOR_ENABLE]   = defaultModbusSensors[i].enable;
        }
        
        String jsonString;
        serializeJson(doc, jsonString);
        prefs.putString(NAMESPACE_SENSORS_MODBUS, jsonString.c_str());
        prefs.end();
    }
#endif
}

void ConfigManager::getSystemConfig(bool &initialized, uint32_t &sleepTime, String &deviceId, String &stationId) {
    StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
    readNamespace(NAMESPACE_SYSTEM, doc);
    initialized = doc[KEY_INITIALIZED] | false;
    sleepTime = doc[KEY_SLEEP_TIME] | DEFAULT_TIME_TO_SLEEP;
    deviceId = String(doc[KEY_DEVICE_ID] | DEFAULT_DEVICE_ID);
    stationId = String(doc[KEY_STATION_ID] | DEFAULT_STATION_ID);
}

void ConfigManager::setSystemConfig(bool initialized, uint32_t sleepTime, const String &deviceId, const String &stationId) {
    StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
    readNamespace(NAMESPACE_SYSTEM, doc);
    doc[KEY_INITIALIZED] = initialized;
    doc[KEY_SLEEP_TIME] = sleepTime;
    doc[KEY_DEVICE_ID] = deviceId;
    doc[KEY_STATION_ID] = stationId;
    writeNamespace(NAMESPACE_SYSTEM, doc);
}

/* =========================================================================
   CONFIGURACIÓN DE SENSORES NO-MODBUS
   ========================================================================= */
std::vector<SensorConfig> ConfigManager::getAllSensorConfigs() {
    std::vector<SensorConfig> configs;
    StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
    readNamespace(NAMESPACE_SENSORS, doc);
    
    if (!doc.is<JsonArray>()) {
        // Si no es un arreglo, no hay nada que leer
        return configs;
    }
    
    JsonArray sensorArray = doc.as<JsonArray>();
    for (JsonObject sensorObj : sensorArray) {
        SensorConfig config;
        const char* cKey = sensorObj[KEY_SENSOR] | "";
        strncpy(config.configKey, cKey, sizeof(config.configKey));
        const char* sensorId = sensorObj[KEY_SENSOR_ID] | "";
        strncpy(config.sensorId, sensorId, sizeof(config.sensorId));
        config.type = static_cast<SensorType>(sensorObj[KEY_SENSOR_TYPE] | 0);
        config.enable = sensorObj[KEY_SENSOR_ENABLE] | false;
        
        configs.push_back(config);
    }
    
    return configs;
}

std::vector<SensorConfig> ConfigManager::getEnabledSensorConfigs() {
    std::vector<SensorConfig> allSensors = getAllSensorConfigs();
    
    std::vector<SensorConfig> enabledSensors;
    for (const auto& sensor : allSensors) {
        if (sensor.enable && strlen(sensor.sensorId) > 0) {
            enabledSensors.push_back(sensor);
        }
    }
    
    return enabledSensors;
}

void ConfigManager::setSensorsConfigs(const std::vector<SensorConfig>& configs) {
    Preferences prefs;
    prefs.begin(NAMESPACE_SENSORS, false);
    StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
    JsonArray sensorArray = doc.to<JsonArray>();
    
    for (const auto& sensor : configs) {
        JsonObject sensorObj = sensorArray.createNestedObject();
        sensorObj[KEY_SENSOR] = sensor.configKey;
        sensorObj[KEY_SENSOR_ID] = sensor.sensorId;
        sensorObj[KEY_SENSOR_TYPE] = static_cast<int>(sensor.type);
        sensorObj[KEY_SENSOR_ENABLE] = sensor.enable;
    }
    
    String jsonString;
    serializeJson(doc, jsonString);
    prefs.putString(NAMESPACE_SENSORS, jsonString.c_str());
    prefs.end();
}

/* =========================================================================
   CONFIGURACIÓN DE LORA
   ========================================================================= */
LoRaConfig ConfigManager::getLoRaConfig() {
    StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
    readNamespace(NAMESPACE_LORAWAN, doc);
    
    LoRaConfig config;
    config.joinEUI  = doc[KEY_LORA_JOIN_EUI] | DEFAULT_JOIN_EUI;
    config.devEUI   = doc[KEY_LORA_DEV_EUI]  | DEFAULT_DEV_EUI;
    config.nwkKey   = doc[KEY_LORA_NWK_KEY]  | DEFAULT_NWK_KEY;
    config.appKey   = doc[KEY_LORA_APP_KEY]  | DEFAULT_APP_KEY;
    
    return config;
}

void ConfigManager::setLoRaConfig(
    const String &joinEUI, 
    const String &devEUI, 
    const String &nwkKey, 
    const String &appKey) {
    StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
    readNamespace(NAMESPACE_LORAWAN, doc);
    
    doc[KEY_LORA_JOIN_EUI] = joinEUI;
    doc[KEY_LORA_DEV_EUI]  = devEUI;
    doc[KEY_LORA_NWK_KEY]  = nwkKey;
    doc[KEY_LORA_APP_KEY]  = appKey;
    
    writeNamespace(NAMESPACE_LORAWAN, doc);
}

/* =========================================================================
   CONFIGURACIÓN DE SENSORES MODBUS
   ========================================================================= */
#if defined(DEVICE_TYPE_MODBUS) || defined(DEVICE_TYPE_ANALOGIC)
// Definición de la variable estática
const ModbusSensorConfig ConfigManager::defaultModbusSensors[] = DEFAULT_MODBUS_SENSOR_CONFIGS;

void ConfigManager::setModbusSensorsConfigs(const std::vector<ModbusSensorConfig>& configs) {
    Preferences prefs;
    prefs.begin(NAMESPACE_SENSORS_MODBUS, false);
    StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
    JsonArray sensorArray = doc.to<JsonArray>();
    
    for (const auto& sensor : configs) {
        JsonObject sensorObj = sensorArray.createNestedObject();
        sensorObj[KEY_MODBUS_SENSOR_ID] = sensor.sensorId;
        sensorObj[KEY_MODBUS_SENSOR_TYPE] = static_cast<int>(sensor.type);
        sensorObj[KEY_MODBUS_SENSOR_ADDR] = sensor.address;
        sensorObj[KEY_MODBUS_SENSOR_ENABLE] = sensor.enable;
    }
    
    String jsonString;
    serializeJson(doc, jsonString);
    prefs.putString(NAMESPACE_SENSORS_MODBUS, jsonString.c_str());
    prefs.end();
}

std::vector<ModbusSensorConfig> ConfigManager::getAllModbusSensorConfigs() {
    StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
    readNamespace(NAMESPACE_SENSORS_MODBUS, doc);
    
    std::vector<ModbusSensorConfig> configs;
    
    if (doc.is<JsonArray>()) {
        JsonArray array = doc.as<JsonArray>();
        
        for (JsonObject sensorObj : array) {
            ModbusSensorConfig config;
            strlcpy(config.sensorId, sensorObj[KEY_MODBUS_SENSOR_ID] | "", sizeof(config.sensorId));
            config.type = static_cast<SensorType>(sensorObj[KEY_MODBUS_SENSOR_TYPE] | 0);
            config.address = sensorObj[KEY_MODBUS_SENSOR_ADDR] | 1;
            config.enable = sensorObj[KEY_MODBUS_SENSOR_ENABLE] | false;
            
            configs.push_back(config);
        }
    }
    
    return configs;
}

std::vector<ModbusSensorConfig> ConfigManager::getEnabledModbusSensorConfigs() {
    std::vector<ModbusSensorConfig> all = getAllModbusSensorConfigs();
    std::vector<ModbusSensorConfig> enabled;
    for (auto &m : all) {
        if (m.enable) {
            enabled.push_back(m);
        }
    }
    return enabled;
}
#endif

/* =========================================================================
   CONFIGURACIÓN DE SENSORES ANALÓGICOS (Solo para dispositivo analógico)
   ========================================================================= */
#ifdef DEVICE_TYPE_ANALOGIC

void ConfigManager::getNTC100KConfig(double& t1, double& r1, double& t2, double& r2, double& t3, double& r3) {
    StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
    readNamespace(NAMESPACE_NTC100K, doc);
    t1 = doc[KEY_NTC100K_T1] | DEFAULT_T1_100K;
    r1 = doc[KEY_NTC100K_R1] | DEFAULT_R1_100K;
    t2 = doc[KEY_NTC100K_T2] | DEFAULT_T2_100K;
    r2 = doc[KEY_NTC100K_R2] | DEFAULT_R2_100K;
    t3 = doc[KEY_NTC100K_T3] | DEFAULT_T3_100K;
    r3 = doc[KEY_NTC100K_R3] | DEFAULT_R3_100K;
}

void ConfigManager::setNTC100KConfig(double t1, double r1, double t2, double r2, double t3, double r3) {
    StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
    readNamespace(NAMESPACE_NTC100K, doc);
    doc[KEY_NTC100K_T1] = t1;
    doc[KEY_NTC100K_R1] = r1;
    doc[KEY_NTC100K_T2] = t2;
    doc[KEY_NTC100K_R2] = r2;
    doc[KEY_NTC100K_T3] = t3;
    doc[KEY_NTC100K_R3] = r3;
    writeNamespace(NAMESPACE_NTC100K, doc);
}

void ConfigManager::getNTC10KConfig(double& t1, double& r1, double& t2, double& r2, double& t3, double& r3) {
    StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
    readNamespace(NAMESPACE_NTC10K, doc);
    t1 = doc[KEY_NTC10K_T1] | DEFAULT_T1_10K;
    r1 = doc[KEY_NTC10K_R1] | DEFAULT_R1_10K;
    t2 = doc[KEY_NTC10K_T2] | DEFAULT_T2_10K;
    r2 = doc[KEY_NTC10K_R2] | DEFAULT_R2_10K;
    t3 = doc[KEY_NTC10K_T3] | DEFAULT_T3_10K;
    r3 = doc[KEY_NTC10K_R3] | DEFAULT_R3_10K;
}

void ConfigManager::setNTC10KConfig(double t1, double r1, double t2, double r2, double t3, double r3) {
    StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
    readNamespace(NAMESPACE_NTC10K, doc);
    doc[KEY_NTC10K_T1] = t1;
    doc[KEY_NTC10K_R1] = r1;
    doc[KEY_NTC10K_T2] = t2;
    doc[KEY_NTC10K_R2] = r2;
    doc[KEY_NTC10K_T3] = t3;
    doc[KEY_NTC10K_R3] = r3;
    writeNamespace(NAMESPACE_NTC10K, doc);
}

void ConfigManager::getConductivityConfig(float& calTemp, float& coefComp, 
                                           float& v1, float& t1, float& v2, float& t2, float& v3, float& t3) {
    StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
    readNamespace(NAMESPACE_COND, doc);
    calTemp = doc[KEY_CONDUCT_CT] | CONDUCTIVITY_DEFAULT_TEMP;
    coefComp = doc[KEY_CONDUCT_CC] | TEMP_COEF_COMPENSATION;
    v1 = doc[KEY_CONDUCT_V1] | CONDUCTIVITY_DEFAULT_V1;
    t1 = doc[KEY_CONDUCT_T1] | CONDUCTIVITY_DEFAULT_T1;
    v2 = doc[KEY_CONDUCT_V2] | CONDUCTIVITY_DEFAULT_V2;
    t2 = doc[KEY_CONDUCT_T2] | CONDUCTIVITY_DEFAULT_T2;
    v3 = doc[KEY_CONDUCT_V3] | CONDUCTIVITY_DEFAULT_V3;
    t3 = doc[KEY_CONDUCT_T3] | CONDUCTIVITY_DEFAULT_T3;
}

void ConfigManager::setConductivityConfig(float calTemp, float coefComp,
                                           float v1, float t1, float v2, float t2, float v3, float t3) {
    StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
    readNamespace(NAMESPACE_COND, doc);
    doc[KEY_CONDUCT_CT] = calTemp;
    doc[KEY_CONDUCT_CC] = coefComp;
    doc[KEY_CONDUCT_V1] = v1;
    doc[KEY_CONDUCT_T1] = t1;
    doc[KEY_CONDUCT_V2] = v2;
    doc[KEY_CONDUCT_T2] = t2;
    doc[KEY_CONDUCT_V3] = v3;
    doc[KEY_CONDUCT_T3] = t3;
    writeNamespace(NAMESPACE_COND, doc);
}

void ConfigManager::getPHConfig(float& v1, float& t1, float& v2, float& t2, float& v3, float& t3, float& defaultTemp) {
    StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
    readNamespace(NAMESPACE_PH, doc);
    v1 = doc[KEY_PH_V1] | PH_DEFAULT_V1;
    t1 = doc[KEY_PH_T1] | PH_DEFAULT_T1;
    v2 = doc[KEY_PH_V2] | PH_DEFAULT_V2;
    t2 = doc[KEY_PH_T2] | PH_DEFAULT_T2;
    v3 = doc[KEY_PH_V3] | PH_DEFAULT_V3;
    t3 = doc[KEY_PH_T3] | PH_DEFAULT_T3;
    defaultTemp = doc[KEY_PH_CT] | PH_DEFAULT_TEMP;
}

void ConfigManager::setPHConfig(float v1, float t1, float v2, float t2, float v3, float t3, float defaultTemp) {
    StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
    readNamespace(NAMESPACE_PH, doc);
    doc[KEY_PH_V1] = v1;
    doc[KEY_PH_T1] = t1;
    doc[KEY_PH_V2] = v2;
    doc[KEY_PH_T2] = t2;
    doc[KEY_PH_V3] = v3;
    doc[KEY_PH_T3] = t3;
    doc[KEY_PH_CT] = defaultTemp;
    writeNamespace(NAMESPACE_PH, doc);
}
#endif

================
File: include/sensor_types.h
================
#ifndef SENSOR_TYPES_H
#define SENSOR_TYPES_H

#include <stdint.h>
#include <vector>
#include "sensor_constants.h"
#include "config.h"

/**
 * @brief Estructura para variables múltiples en un solo sensor.
 *        Por ejemplo, un sensor SHT30 que da Temperature (T) y Humidity (H).
 */
struct SubValue {
    char key[10];    // Nombre corto de la variable, por ej: "T", "H", etc.
    float value;
};

/************************************************************************
 * SECCIÓN PARA SENSORES ESTÁNDAR (NO MODBUS)
 ************************************************************************/

/**
 * @brief Enumeración de tipos de sensores disponibles.
 */
enum SensorType {
    // Sensores estándar (no-Modbus)
    N100K,    // NTC 100K
    N10K,     // NTC 10K
    HDS10,    // HDS10
    RTD,      // RTD
    DS18B20,  // DS18B20
    PH,       // pH
    COND,     // Conductividad
    SOILH,    // Soil Humidity
    SHT30,    // SHT30
    
    // Sensores Modbus
    ENV4      // Sensor ambiental 4 en 1 (Modbus)
    // Aquí se pueden agregar más tipos de sensores Modbus
};

/**
 * @brief Estructura básica para almacenar una lectura de sensor.
 *        Para sensores con múltiples variables, se utilizará 'subValues'.
 */
struct SensorReading {
    char sensorId[20];         // Identificador del sensor (ej. "SHT30_1")
    SensorType type;           // Tipo de sensor
    float value;               // Valor único (si aplica)
    std::vector<SubValue> subValues; // Subvalores, si el sensor genera varias mediciones
};

/**
 * @brief Estructura de configuración para sensores "normales" (no Modbus).
 */
struct SensorConfig {
    char configKey[20];
    char sensorId[20];
    SensorType type;
    bool enable;
};

#if defined(DEVICE_TYPE_ANALOGIC) || defined(DEVICE_TYPE_MODBUS)
/************************************************************************
 * SECCIÓN PARA SENSORES MODBUS
 ************************************************************************/

/**
 * @brief Estructura de configuración para sensores Modbus.
 */
struct ModbusSensorConfig {
    char sensorId[20];         // Identificador del sensor
    SensorType type;           // Tipo de sensor Modbus
    uint8_t address;           // Dirección Modbus del dispositivo
    bool enable;               // Si está habilitado o no
};

/**
 * @brief Estructura para almacenar la lectura completa de un sensor Modbus.
 */
struct ModbusSensorReading {
    char sensorId[20];         // Identificador del sensor
    SensorType type;           // Tipo de sensor Modbus
    std::vector<SubValue> subValues; // Subvalores reportados por el sensor
};
#endif // defined(DEVICE_TYPE_ANALOGIC) || defined(DEVICE_TYPE_MODBUS)

#endif // SENSOR_TYPES_H

================
File: src/LoRaManager.cpp
================
/*******************************************************************************************
 * Archivo: src/LoRaManager.cpp
 * Descripción: Implementación de la gestión de comunicaciones LoRa y LoRaWAN.
 *              Se ha modificado la forma de serializar los valores float a 3 decimales
 *              usando snprintf("%.3f", ...) antes de asignarlos al JSON.
 *******************************************************************************************/

#include "LoRaManager.h"
#include <Preferences.h>
#include "debug.h"
#include <RadioLib.h>
#include <RTClib.h>
#include "utilities.h"  // Incluido para acceder a formatFloatTo3Decimals
#include "config.h"     // Incluido para acceder a MAX_PAYLOAD
#include "sensor_types.h"  // Incluido para acceder a ModbusSensorReading
#include "config_manager.h"
#include "sensors/BatterySensor.h"

// Inicialización de variables estáticas
LoRaWANNode* LoRaManager::node = nullptr;
SX1262* LoRaManager::radioModule = nullptr;

// Referencias externas
extern RTC_DATA_ATTR uint8_t LWsession[RADIOLIB_LORAWAN_SESSION_BUF_SIZE];
extern RTC_DATA_ATTR uint16_t bootCountSinceUnsuccessfulJoin;
extern RTC_DS3231 rtc;

int16_t LoRaManager::begin(SX1262* radio, const LoRaWANBand_t* region, uint8_t subBand) {
    radioModule = radio;
    int16_t state = radioModule->begin();
    if (state != RADIOLIB_ERR_NONE) {
        return state;
    }
    
    // Crear el nodo LoRaWAN
    node = new LoRaWANNode(radio, region, subBand);
    return RADIOLIB_ERR_NONE;
}

int16_t LoRaManager::lwActivate(LoRaWANNode& node) {
    int16_t state = RADIOLIB_ERR_UNKNOWN;
    Preferences store;
    
    // Obtener configuración LoRa
    LoRaConfig loraConfig = ConfigManager::getLoRaConfig();
    
    // Convertir strings de EUIs a uint64_t
    uint64_t joinEUI = 0, devEUI = 0;
    if (!parseEUIString(loraConfig.joinEUI.c_str(), &joinEUI) ||
        !parseEUIString(loraConfig.devEUI.c_str(), &devEUI)) {
        return state;
    }
    
    // Parsear las claves
    uint8_t nwkKey[16], appKey[16];
    parseKeyString(loraConfig.nwkKey, nwkKey, 16);
    parseKeyString(loraConfig.appKey, appKey, 16);

    // Configurar la sesión OTAA
    node.beginOTAA(joinEUI, devEUI, nwkKey, appKey);

    store.begin("radiolib");

    // Intentar restaurar nonces si existen
    if (store.isKey("nonces")) {
        uint8_t buffer[RADIOLIB_LORAWAN_NONCES_BUF_SIZE];
        store.getBytes("nonces", buffer, RADIOLIB_LORAWAN_NONCES_BUF_SIZE);
        state = node.setBufferNonces(buffer);
        
        if (state == RADIOLIB_ERR_NONE) {
            // Intentar restaurar sesión desde RTC
            state = node.setBufferSession(LWsession);
            
            if (state == RADIOLIB_ERR_NONE) {
                state = node.activateOTAA();
                
                if (state == RADIOLIB_LORAWAN_SESSION_RESTORED) {
                    store.end();
                    return state;
                }
            }
        }
    } else {
        DEBUG_PRINTLN("No hay nonces guardados - iniciando nuevo join");
    }

    // Si llegamos aquí, necesitamos hacer un nuevo join
    state = RADIOLIB_ERR_NETWORK_NOT_JOINED;
    while (state != RADIOLIB_LORAWAN_NEW_SESSION) {
        state = node.activateOTAA();

        // Guardar nonces en flash si el join fue exitoso
        if (state == RADIOLIB_LORAWAN_NEW_SESSION) {
            uint8_t buffer[RADIOLIB_LORAWAN_NONCES_BUF_SIZE];
            uint8_t *persist = node.getBufferNonces();
            memcpy(buffer, persist, RADIOLIB_LORAWAN_NONCES_BUF_SIZE);
            store.putBytes("nonces", buffer, RADIOLIB_LORAWAN_NONCES_BUF_SIZE);

            // Solicitar DeviceTime después de un join exitoso
            delay(1000); // Pausa para estabilización
            node.setDatarate(3);
            
            // Variable para controlar el número de intentos
            int rtcAttempts = 0;
            bool rtcUpdated = false;
            const int maxAttempts = 3; // Máximo número de intentos para actualizar RTC
            
            // Intentar solicitar y actualizar el tiempo del RTC hasta 3 veces
            while (!rtcUpdated && rtcAttempts < maxAttempts) {
                rtcAttempts++;
                DEBUG_PRINTF("Intento %d de actualización de RTC\n", rtcAttempts);
                
                bool macCommandSuccess = node.sendMacCommandReq(RADIOLIB_LORAWAN_MAC_DEVICE_TIME);
                if (macCommandSuccess) {
                    // Enviar mensaje vacío
                    uint8_t fPort = 1;
                    uint8_t downlinkPayload[255];
                    size_t downlinkSize = 0;
                    
                    int16_t rxState = node.sendReceive(nullptr, 0, fPort, downlinkPayload, &downlinkSize, true);
                    if (rxState == RADIOLIB_ERR_NONE) {
                        // Obtener y procesar DeviceTime
                        uint32_t unixEpoch;
                        uint8_t fraction;
                        int16_t dtState = node.getMacDeviceTimeAns(&unixEpoch, &fraction, true);
                        if (dtState == RADIOLIB_ERR_NONE) {
                            DEBUG_PRINTF("DeviceTime recibido: epoch = %lu s, fraction = %u\n", unixEpoch, fraction);
                            // Convertir el tiempo unix a DateTime
                            DateTime serverTime(unixEpoch);
                            
                            // Ajustar el RTC con el tiempo del servidor
                            rtc.adjust(serverTime);
                            
                            // Verificar si se ajustó correctamente
                            if (abs((int32_t)rtc.now().unixtime() - (int32_t)unixEpoch) < 10) {
                                DEBUG_PRINTLN("RTC actualizado exitosamente con tiempo del servidor");
                                rtcUpdated = true; // Marca como actualizado para salir del bucle
                            } else {
                                DEBUG_PRINTLN("Error al actualizar RTC con tiempo del servidor");
                                // Si estamos en el último intento, continuamos de todas formas
                                if (rtcAttempts >= maxAttempts) {
                                    DEBUG_PRINTLN("Agotados los intentos de actualización de RTC");
                                } else {
                                    delay(1000); // Esperar un segundo antes del siguiente intento
                                }
                            }
                        } else {
                            DEBUG_PRINTF("Error al obtener DeviceTime: %d\n", dtState);
                            // Si estamos en el último intento, continuamos de todas formas
                            if (rtcAttempts >= maxAttempts) {
                                DEBUG_PRINTLN("Agotados los intentos de actualización de RTC");
                            } else {
                                delay(1000); // Esperar un segundo antes del siguiente intento
                            }
                        }
                    } else {
                        DEBUG_PRINTF("Error al recibir respuesta DeviceTime: %d\n", rxState);
                        // Si estamos en el último intento, continuamos de todas formas
                        if (rtcAttempts >= maxAttempts) {
                            DEBUG_PRINTLN("Agotados los intentos de actualización de RTC");
                        } else {
                            delay(1000); // Esperar un segundo antes del siguiente intento
                        }
                    }
                } else {
                    DEBUG_PRINTLN("Error al solicitar DeviceTime: comando no pudo ser encolado");
                    // Si estamos en el último intento, continuamos de todas formas
                    if (rtcAttempts >= maxAttempts) {
                        DEBUG_PRINTLN("Agotados los intentos de actualización de RTC");
                    } else {
                        delay(1000); // Esperar un segundo antes del siguiente intento
                    }
                }
            }
            
            // Si no se pudo actualizar el RTC después de los intentos máximos, retornar error
            if (!rtcUpdated) {
                DEBUG_PRINTLN("No se pudo actualizar el RTC después de los intentos máximos, entrando en deep sleep");
                bootCountSinceUnsuccessfulJoin = 0;
                store.end();
                return RADIOLIB_ERR_RTC_SYNC_FAILED; // Error personalizado para indicar fallo en sincronización RTC
            }
            
            bootCountSinceUnsuccessfulJoin = 0;
            store.end();
            return RADIOLIB_LORAWAN_NEW_SESSION;
        } else {
            DEBUG_PRINTF("Join falló: %d\n", state);
            bootCountSinceUnsuccessfulJoin++;
            store.end();
            return state;
        }
    }

    store.end();
    return state;
}

/**
 * @brief Crea un payload optimizado con formato delimitado por | y , en lugar de JSON.
 * @param readings Vector con lecturas de sensores.
 * @param deviceId ID del dispositivo.
 * @param stationId ID de la estación.
 * @param battery Valor de la batería.
 * @param timestamp Timestamp del sistema.
 * @param buffer Buffer donde se almacenará el payload.
 * @param bufferSize Tamaño del buffer.
 * @return Tamaño del payload generado.
 */
size_t LoRaManager::createDelimitedPayload(
    const std::vector<SensorReading>& readings,
    const String& deviceId,
    const String& stationId,
    float battery,
    uint32_t timestamp,
    char* buffer,
    size_t bufferSize
) {
    // Inicializar buffer
    buffer[0] = '\0';
    size_t offset = 0;
    
    // Formatear batería con hasta 3 decimales
    char batteryStr[16];
    formatFloatTo3Decimals(battery, batteryStr, sizeof(batteryStr));
    
    // Formato: st|d|vt|ts|sensor1_id,sensor1_type,val1,val2,...|sensor2_id,...
    
    // Añadir encabezado: st|d|vt|ts
    offset += snprintf(buffer + offset, bufferSize - offset, 
                      "%s|%s|%s|%lu", 
                      stationId.c_str(), 
                      deviceId.c_str(), 
                      batteryStr, 
                      timestamp);
    
    // Añadir cada sensor
    for (const auto& reading : readings) {
        if (offset >= bufferSize - 1) break; // Evitar desbordamiento
        
        // Añadir separador de sensor
        buffer[offset++] = '|';
        buffer[offset] = '\0';
        
        // Añadir ID y tipo del sensor
        offset += snprintf(buffer + offset, bufferSize - offset, 
                          "%s,%d", 
                          reading.sensorId, 
                          reading.type);
        
        // Añadir valores
        if (reading.subValues.empty()) {
            // Un solo valor
            char valStr[16];
            formatFloatTo3Decimals(reading.value, valStr, sizeof(valStr));
            offset += snprintf(buffer + offset, bufferSize - offset, ",%s", valStr);
        } else {
            // Múltiples valores (subValues)
            for (const auto& sv : reading.subValues) {
                char valStr[16];
                formatFloatTo3Decimals(sv.value, valStr, sizeof(valStr));
                offset += snprintf(buffer + offset, bufferSize - offset, ",%s", valStr);
            }
        }
    }
    
    return offset;
}

#if defined(DEVICE_TYPE_ANALOGIC) || defined(DEVICE_TYPE_MODBUS)
/**
 * @brief Crea un payload optimizado con formato delimitado para sensores normales y Modbus.
 * @param normalReadings Vector con lecturas de sensores normales.
 * @param modbusReadings Vector con lecturas de sensores Modbus.
 * @param deviceId ID del dispositivo.
 * @param stationId ID de la estación.
 * @param battery Valor de la batería.
 * @param timestamp Timestamp del sistema.
 * @param buffer Buffer donde se almacenará el payload.
 * @param bufferSize Tamaño del buffer.
 * @return Tamaño del payload generado.
 */
size_t LoRaManager::createDelimitedPayload(
    const std::vector<SensorReading>& normalReadings,
    const std::vector<ModbusSensorReading>& modbusReadings,
    const String& deviceId,
    const String& stationId,
    float battery,
    uint32_t timestamp,
    char* buffer,
    size_t bufferSize
) {
    // Inicializar buffer
    buffer[0] = '\0';
    size_t offset = 0;
    
    // Formatear batería con hasta 3 decimales
    char batteryStr[16];
    formatFloatTo3Decimals(battery, batteryStr, sizeof(batteryStr));
    
    // Formato: st|d|vt|ts|sensor1_id,sensor1_type,val1,val2,...|sensor2_id,...
    
    // Añadir encabezado: st|d|vt|ts
    offset += snprintf(buffer + offset, bufferSize - offset, 
                      "%s|%s|%s|%lu", 
                      stationId.c_str(), 
                      deviceId.c_str(), 
                      batteryStr, 
                      timestamp);
    
    // Añadir sensores normales
    for (const auto& reading : normalReadings) {
        if (offset >= bufferSize - 1) break; // Evitar desbordamiento
        
        // Añadir separador de sensor
        buffer[offset++] = '|';
        buffer[offset] = '\0';
        
        // Añadir ID y tipo del sensor
        offset += snprintf(buffer + offset, bufferSize - offset, 
                          "%s,%d", 
                          reading.sensorId, 
                          reading.type);
        
        // Añadir valores
        if (reading.subValues.empty()) {
            // Un solo valor
            char valStr[16];
            formatFloatTo3Decimals(reading.value, valStr, sizeof(valStr));
            offset += snprintf(buffer + offset, bufferSize - offset, ",%s", valStr);
        } else {
            // Múltiples valores (subValues)
            for (const auto& sv : reading.subValues) {
                char valStr[16];
                formatFloatTo3Decimals(sv.value, valStr, sizeof(valStr));
                offset += snprintf(buffer + offset, bufferSize - offset, ",%s", valStr);
            }
        }
    }
    
    // Añadir sensores Modbus
    for (const auto& reading : modbusReadings) {
        if (offset >= bufferSize - 1) break; // Evitar desbordamiento
        
        // Añadir separador de sensor
        buffer[offset++] = '|';
        buffer[offset] = '\0';
        
        // Añadir ID y tipo del sensor
        offset += snprintf(buffer + offset, bufferSize - offset, 
                          "%s,%d", 
                          reading.sensorId, 
                          reading.type);
        
        // Añadir valores
        for (const auto& sv : reading.subValues) {
            char valStr[16];
            formatFloatTo3Decimals(sv.value, valStr, sizeof(valStr));
            offset += snprintf(buffer + offset, bufferSize - offset, ",%s", valStr);
        }
    }
    
    return offset;
}
#endif

/**
 * @brief Envía el payload de sensores estándar usando formato delimitado.
 */
void LoRaManager::sendDelimitedPayload(const std::vector<SensorReading>& readings, 
                                     LoRaWANNode& node,
                                     const String& deviceId, 
                                     const String& stationId, 
                                     RTC_DS3231& rtc) 
{
    char payloadBuffer[MAX_LORA_PAYLOAD + 1];
    
    // Crear payload delimitado
    float battery = BatterySensor::readVoltage();
    uint32_t timestamp = rtc.now().unixtime();
    
    size_t payloadLength = createDelimitedPayload(
        readings, deviceId, stationId, battery, timestamp, 
        payloadBuffer, sizeof(payloadBuffer)
    );
    
    DEBUG_PRINTF("Enviando payload delimitado con tamaño %d bytes\n", payloadLength);
    DEBUG_PRINTLN(payloadBuffer);
    
    // Enviar
    uint8_t fPort = 1;
    uint8_t downlinkPayload[255];
    size_t downlinkSize = 0;
    
    int16_t state = node.sendReceive(
        (uint8_t*)payloadBuffer, 
        payloadLength, 
        fPort, 
        downlinkPayload, 
        &downlinkSize
    );
    
    if (state == RADIOLIB_ERR_NONE) {
        DEBUG_PRINTLN("Transmisión exitosa!");
        if (downlinkSize > 0) {
            DEBUG_PRINTF("Recibidos %d bytes de downlink\n", downlinkSize);
        }
    } else {
        DEBUG_PRINTF("Error en transmisión: %d\n", state);
    }
}

#if defined(DEVICE_TYPE_ANALOGIC) || defined(DEVICE_TYPE_MODBUS)
/**
 * @brief Envía el payload de sensores estándar y Modbus usando formato delimitado.
 */
void LoRaManager::sendDelimitedPayload(const std::vector<SensorReading>& normalReadings, 
                                     const std::vector<ModbusSensorReading>& modbusReadings,
                                     LoRaWANNode& node,
                                     const String& deviceId, 
                                     const String& stationId, 
                                     RTC_DS3231& rtc)
{
    char payloadBuffer[MAX_LORA_PAYLOAD + 1];
    
    // Crear payload delimitado
    float battery = BatterySensor::readVoltage();
    uint32_t timestamp = rtc.now().unixtime();
    
    size_t payloadLength = createDelimitedPayload(
        normalReadings, modbusReadings, deviceId, stationId, battery, timestamp, 
        payloadBuffer, sizeof(payloadBuffer)
    );
    
    DEBUG_PRINTF("Enviando payload delimitado con tamaño %d bytes\n", payloadLength);
    DEBUG_PRINTLN(payloadBuffer);
    
    // Enviar
    uint8_t fPort = 1;
    uint8_t downlinkPayload[255];
    size_t downlinkSize = 0;

    /*
    Lista de Data Rates (DR) para LoRaWAN US915

    - Cada DR define un conjunto específico de parámetros: 
        - SF (Spreading Factor): Cuanto mayor es, más alcance tiene pero menor velocidad de transmisión.
        - BW (Bandwidth): Mayor ancho de banda significa mayor velocidad pero menor alcance.
        - CR (Coding Rate): Relación de corrección de errores.
        - Payload Máximo: Tamaño máximo de datos en bytes que se pueden enviar en una sola transmisión.

    - NOTA: DR5, DR6 y DR7 no están definidos en US915.

    Índice | SF  | BW   | CR   | Payload Máximo | Comentario
    -------|-----|------|------|---------------|------------------------------------
    DR0    | SF10 | 125kHz | 4/5 | 19 bytes      | Mayor alcance, menor velocidad.
    DR1    | SF9  | 125kHz | 4/5 | 61 bytes      | Menor alcance, más velocidad que DR0.
    DR2    | SF8  | 125kHz | 4/5 | 133 bytes     | Velocidad media, menor alcance que DR1.
    DR3    | SF7  | 125kHz | 4/5 | 250 bytes     | Mayor velocidad en 125kHz, menor alcance.
    DR4    | SF8  | 500kHz | 4/5 | 250 bytes     | Mayor BW para mejorar la velocidad.
    DR5    | N/A  | N/A    | N/A | No definido   | No definido en US915.
    DR6    | N/A  | N/A    | N/A | No definido   | No definido en US915.
    DR7    | N/A  | N/A    | N/A | No definido   | No definido en US915.
    DR8    | SF12 | 500kHz | 4/5 | 41 bytes      | Mayor alcance en 500kHz, menor velocidad.
    DR9    | SF11 | 500kHz | 4/5 | 117 bytes     | Más velocidad que DR8, menos alcance.
    DR10   | SF10 | 500kHz | 4/5 | 230 bytes     | Más velocidad que DR9.
    DR11   | SF9  | 500kHz | 4/5 | 230 bytes     | Velocidad media en 500kHz.
    DR12   | SF8  | 500kHz | 4/5 | 230 bytes     | Más velocidad que DR11.
    DR13   | SF7  | 500kHz | 4/5 | 230 bytes     | Mayor velocidad en 500kHz, menor alcance.
    DR14   | N/A  | N/A    | N/A | No definido   | No definido en US915.

    - DR0 a DR3 se usan para **uplink** en los 64 canales de 125kHz.
    - DR4 se usa para **uplink** en los 8 canales de 500kHz.
    - DR8 a DR13 se usan para **downlink** en los 8 canales de 500kHz.
    - El payload máximo puede verse afectado por la opción **FOpt** en el MAC layer.
    */
    LoRaManager::setDatarate(node, 3);

    
    // int16_t state = node.sendReceive(
    //     (uint8_t*)payloadBuffer, 
    //     payloadLength, 
    //     fPort, 
    //     downlinkPayload, 
    //     &downlinkSize
    // );

    int16_t state = node.uplink(
        (uint8_t*)payloadBuffer, 
        payloadLength, 
        fPort
    );
    
    if (state == RADIOLIB_ERR_NONE) {
        DEBUG_PRINTLN("Transmisión exitosa!");
        if (downlinkSize > 0) {
            DEBUG_PRINTF("Recibidos %d bytes de downlink\n", downlinkSize);
        }
    } else {
        DEBUG_PRINTF("Error en transmisión: %d\n", state);
    }
}
#endif

void LoRaManager::prepareForSleep(SX1262* radio) {
    if (radio) {
        radio->sleep(true);
    }
}

void LoRaManager::setDatarate(LoRaWANNode& node, uint8_t datarate) {
    node.setDatarate(datarate);
}

================
File: include/SensorManager.h
================
#ifndef SENSOR_MANAGER_H
#define SENSOR_MANAGER_H

#include <Arduino.h>
#include <vector>
#include "sensor_types.h"
#include <RTClib.h>
#include "clsPCA9555.h"
#include "PowerManager.h"
#include "MAX31865.h"
#if defined(DEVICE_TYPE_BASIC) || defined(DEVICE_TYPE_ANALOGIC)
#include <OneWire.h>
#include <DallasTemperature.h>
#endif
#include <SensirionI2cSht3x.h>
#if defined(DEVICE_TYPE_ANALOGIC) || defined(DEVICE_TYPE_MODBUS)
#include "ModbusSensorManager.h"
#ifdef DEVICE_TYPE_ANALOGIC
#include "sensors/NtcManager.h"
#endif
#endif

// Variables y objetos globales declarados en main.cpp
extern RTC_DS3231 rtc;
extern PCA9555 ioExpander;
extern PowerManager powerManager;
extern SPIClass spi;
#ifdef DEVICE_TYPE_ANALOGIC
extern SPISettings spiAdcSettings;
#endif
extern SPISettings spiRtdSettings;
extern MAX31865_RTD rtd;
#if defined(DEVICE_TYPE_BASIC) || defined(DEVICE_TYPE_ANALOGIC)
extern OneWire oneWire;
extern DallasTemperature dallasTemp;
#endif
extern SensirionI2cSht3x sht30Sensor;

/**
 * @brief Clase que maneja la inicialización y lecturas de todos los sensores
 *        incluyendo sensores normales y Modbus.
 */
class SensorManager {
  public:
    // Inicializa pines, periféricos (ADC, RTD, etc.), OneWire, etc.
    static void beginSensors();

    // Devuelve la lectura (o lecturas) de un sensor NO-Modbus según su configuración.
    static SensorReading getSensorReading(const SensorConfig& cfg);
    
#if defined(DEVICE_TYPE_ANALOGIC) || defined(DEVICE_TYPE_MODBUS)
    // Devuelve la lectura de un sensor Modbus según su configuración
    static ModbusSensorReading getModbusSensorReading(const ModbusSensorConfig& cfg);
#endif
    
    // Obtiene todas las lecturas de sensores (normales y Modbus) habilitados
    static void getAllSensorReadings(std::vector<SensorReading>& normalReadings
#if defined(DEVICE_TYPE_ANALOGIC) || defined(DEVICE_TYPE_MODBUS)
                                    , std::vector<ModbusSensorReading>& modbusReadings
#endif
                                    );

#ifdef DEVICE_TYPE_ANALOGIC
    
    // Ya no son necesarios, se movieron a sus propias clases
    // static float readHDS10Sensor();
    // static float convertResistanceToHumidity(float resistance);
    // static float readConductivitySensor();
    // static float convertVoltageToConductivity(float voltage, float tempC);
    // static float readPHSensor();
    // static float convertVoltageToPH(float voltage, float tempC);
#endif

  private:
    // Métodos de lectura internos
    // Ya no son necesarios, se han movido a sus propias clases
    // static float readRtdSensor();
    // static float readDallasSensor();
    // static void readSht30(float& outTemp, float& outHum);

    static float readSensorValue(const SensorConfig &cfg, SensorReading &reading);
};

#endif // SENSOR_MANAGER_H

================
File: src/main.cpp
================
#include <Arduino.h>
#include <Wire.h>
#include <SPI.h>
#include <Preferences.h>
#if defined(DEVICE_TYPE_BASIC) || defined(DEVICE_TYPE_ANALOGIC)
#include <OneWire.h>
#include <DallasTemperature.h>
#endif
#include <vector>
#include <ArduinoJson.h>
#include <cmath>

#include "config.h"
#include "debug.h"
#include "PowerManager.h"
#include "MAX31865.h"
#include <RadioLib.h>
#include <RTClib.h>
#include "sensor_types.h"
#include "SensorManager.h"
#include "nvs_flash.h"
#include "esp_sleep.h"
#include <BLEDevice.h>
#include <BLEServer.h>
#include <BLEAdvertising.h>
#include "config_manager.h"
#include "utilities.h"
#include <SensirionI2cSht3x.h>
#include "LoRaManager.h"
#include "BLE.h"
#include "ADS124S08.h"
#include "HardwareManager.h"
#include "SleepManager.h"

//--------------------------------------------------------------------------------------------
// Variables globales
//--------------------------------------------------------------------------------------------
const LoRaWANBand_t Region = LORA_REGION;
const uint8_t subBand = LORA_SUBBAND;

Preferences preferences;
uint32_t timeToSleep;
String deviceId;
String stationId;
bool systemInitialized;
unsigned long setupStartTime; // Variable para almacenar el tiempo de inicio

RTC_DS3231 rtc;
PCA9555 ioExpander(I2C_ADDRESS_PCA9555, I2C_SDA_PIN, I2C_SCL_PIN);
PowerManager powerManager(ioExpander);

SPIClass spi(FSPI);
#ifdef DEVICE_TYPE_ANALOGIC
SPISettings spiAdcSettings(SPI_ADC_CLOCK, MSBFIRST, SPI_MODE1);
ADS124S08 ADC(ioExpander, spi, spiAdcSettings);
#endif
SPISettings spiRtdSettings(SPI_RTD_CLOCK, MSBFIRST, SPI_MODE1);
SPISettings spiRadioSettings(SPI_RADIO_CLOCK, MSBFIRST, SPI_MODE0);

MAX31865_RTD rtd(MAX31865_RTD::RTD_PT100, spi, spiRtdSettings, ioExpander, PT100_CS_PIN);
SensirionI2cSht3x sht30Sensor;

SX1262 radio = new Module(LORA_NSS_PIN, LORA_DIO1_PIN, LORA_RST_PIN, LORA_BUSY_PIN, spi, spiRadioSettings);
LoRaWANNode node(&radio, &Region, subBand);

#if defined(DEVICE_TYPE_BASIC) || defined(DEVICE_TYPE_ANALOGIC)
OneWire oneWire(ONE_WIRE_BUS);
DallasTemperature dallasTemp(&oneWire);
#endif

RTC_DATA_ATTR uint16_t bootCount = 0;
RTC_DATA_ATTR uint16_t bootCountSinceUnsuccessfulJoin = 0;
RTC_DATA_ATTR uint8_t LWsession[RADIOLIB_LORAWAN_SESSION_BUF_SIZE];
Preferences store;

//--------------------------------------------------------------------------------------------
// setup()
//--------------------------------------------------------------------------------------------
void setup() {
    setupStartTime = millis(); // Inicia el contador de tiempo
    DEBUG_BEGIN(SERIAL_BAUD_RATE);

    SleepManager::releaseHeldPins();

    // // Inicialización del NVS y de hardware I2C/IO
    // preferences.clear();
    // nvs_flash_erase();
    // nvs_flash_init();

    // Inicialización de configuración
    if (!ConfigManager::checkInitialized()) {
        ConfigManager::initializeDefaultConfig();
    }
    ConfigManager::getSystemConfig(systemInitialized, timeToSleep, deviceId, stationId);

    // Inicialización de hardware
    if (!HardwareManager::initHardware(ioExpander, powerManager, sht30Sensor, spi)) {
        DEBUG_PRINTLN("Error en la inicialización del hardware");
        SleepManager::goToDeepSleep(timeToSleep, powerManager, ioExpander, &radio, node, LWsession, spi);
    }

    // Configuración de pines de modo config
    pinMode(CONFIG_PIN, INPUT);
    ioExpander.pinMode(CONFIG_LED_PIN, OUTPUT);

    // Modo configuración BLE
    if (BLEHandler::checkConfigMode(ioExpander)) {
        return;
    }

    // Inicializar RTC
    if (!rtc.begin()) {
        DEBUG_PRINTLN("No se pudo encontrar RTC");
    }

    // Inicializar sensores
    SensorManager::beginSensors();

    //TIEMPO TRASCURRIDO HASTA EL MOMENTO ≈ 98 ms
    // Inicializar radio LoRa
    int16_t state = radio.begin();
    if (state != RADIOLIB_ERR_NONE) {
        DEBUG_PRINTF("Error iniciando radio: %d\n", state);
        SleepManager::goToDeepSleep(timeToSleep, powerManager, ioExpander, &radio, node, LWsession, spi);
    }

    // Activar LoRaWAN
    state = LoRaManager::lwActivate(node);
    if (state != RADIOLIB_LORAWAN_NEW_SESSION && 
        state != RADIOLIB_LORAWAN_SESSION_RESTORED) {
        DEBUG_PRINTF("Error activando LoRaWAN o sincronizando RTC: %d\n", state);
        SleepManager::goToDeepSleep(timeToSleep, powerManager, ioExpander, &radio, node, LWsession, spi);
    }
}

//--------------------------------------------------------------------------------------------
// loop()
//--------------------------------------------------------------------------------------------
void loop() {
    // Verificar si se mantiene presionado para modo config
    if (BLEHandler::checkConfigMode(ioExpander)) {
        return;
    }

    // Obtener todas las lecturas de sensores (normales y Modbus)
    std::vector<SensorReading> normalReadings;
#if defined(DEVICE_TYPE_ANALOGIC) || defined(DEVICE_TYPE_MODBUS)
    std::vector<ModbusSensorReading> modbusReadings;
    SensorManager::getAllSensorReadings(normalReadings, modbusReadings);
    
    // Debug del tiempo transcurrido antes de enviar datos
    DEBUG_PRINTF("Tiempo transcurrido antes de enviar datos: %lu ms\n", millis() - setupStartTime);
    
    // Usar el nuevo formato delimitado en lugar de JSON
    LoRaManager::sendDelimitedPayload(normalReadings, modbusReadings, node, deviceId, stationId, rtc);
#else
    SensorManager::getAllSensorReadings(normalReadings);
    
    // Usar el nuevo formato delimitado en lugar de JSON
    LoRaManager::sendDelimitedPayload(normalReadings, node, deviceId, stationId, rtc);
#endif

    // Calcular y mostrar el tiempo transcurrido antes de dormir
    unsigned long elapsedTime = millis() - setupStartTime;
    DEBUG_PRINTF("Tiempo transcurrido antes de sleep: %lu ms\n", elapsedTime);
    delay(100);
    
    // Dormir
    SleepManager::goToDeepSleep(timeToSleep, powerManager, ioExpander, &radio, node, LWsession, spi);
}

================
File: include/config.h
================
#ifndef CONFIG_H
#define CONFIG_H

// Descomentar solo UNO de los siguientes
// #define DEVICE_TYPE_BASIC
#define DEVICE_TYPE_ANALOGIC
// #define DEVICE_TYPE_MODBUS

// Configuración de depuración - Comentar para deshabilitar mensajes de depuración
#define DEBUG_ENABLED

#ifdef DEVICE_TYPE_BASIC

// Pines generales
#define ONE_WIRE_BUS        0
#define I2C_SDA_PIN         19
#define I2C_SCL_PIN         18
#define I2C_ADDRESS_PCA9555 0x20

// SPI
#define SPI_SCK_PIN         10
#define SPI_MISO_PIN        6
#define SPI_MOSI_PIN        7
#define SPI_RTD_CLOCK       1000000
#define SPI_RADIO_CLOCK     100000

// PT100
#define PT100_CS_PIN        P03

// Modo Config
#define CONFIG_PIN          2
#define CONFIG_TRIGGER_TIME 5000
#define CONFIG_TIMEOUT      30000
#define CONFIG_LED_PIN      P11

// LoRa
#define LORA_NSS_PIN        8
#define LORA_BUSY_PIN       4
#define LORA_RST_PIN        5
#define LORA_DIO1_PIN       3
#define MAX_LORA_PAYLOAD    200

// Serial
#define SERIAL_BAUD_RATE        115200

// Deep Sleep
#define DEFAULT_TIME_TO_SLEEP   30

// Identificadores
#define DEFAULT_DEVICE_ID   "DEV01"
#define DEFAULT_STATION_ID  "ST001"

// LoRa (OTAA)
#define DEFAULT_JOIN_EUI    "00,00,00,00,00,00,00,00"
#define DEFAULT_DEV_EUI     "1f,d4,e6,68,46,8c,e1,b7"
#define DEFAULT_APP_KEY     "1d,fb,69,80,69,d6,a0,7e,5d,bf,29,ba,6b,37,d3,04"
#define DEFAULT_NWK_KEY     "82,91,e9,55,19,ab,c0,6c,86,25,63,68,e7,f4,5a,89"

// LoRa Region y SubBand
#define LORA_REGION         US915
#define LORA_SUBBAND        2       // For US915, use 2; for other regions, use 0

#define BLE_SERVICE_UUID             "180A"
#define BLE_CHAR_SYSTEM_UUID         "2A37"
#define BLE_CHAR_SENSORS_UUID        "2A40"
#define BLE_CHAR_LORA_CONFIG_UUID    "2A41"
#define BLE_DEVICE_PREFIX            "AGRICOS_"

// Calibración batería
const double R1 = 470000.0;
const double R2 = 1500000.0;
const double conversionFactor = (R1 + R2) / R1;

// Namespaces
#define NAMESPACE_SYSTEM        "system"
#define NAMESPACE_SENSORS       "sensors"
#define NAMESPACE_LORAWAN       "lorawan"
#define NAMESPACE_LORA_SESSION  "lorasession"

// Claves
#define KEY_INITIALIZED         "initialized"
#define KEY_SLEEP_TIME          "sleep_time"
#define KEY_STATION_ID          "stationId"
#define KEY_DEVICE_ID           "deviceId"
#define KEY_VOLT                "volt"
#define KEY_SENSOR              "k"
#define KEY_SENSOR_ID           "id"
#define KEY_SENSOR_ID_TEMPERATURE_SENSOR "ts"
#define KEY_SENSOR_TYPE         "t"
#define KEY_SENSOR_ENABLE       "e"
#define KEY_LORA_JOIN_EUI       "joinEUI"
#define KEY_LORA_DEV_EUI        "devEUI"
#define KEY_LORA_NWK_KEY        "nwkKey"
#define KEY_LORA_APP_KEY        "appKey"
#define KEY_LORAWAN_SESSION     "lorawan_session"

// Tamaños de documentos JSON - Centralizados
#define JSON_DOC_SIZE_SMALL   300
#define JSON_DOC_SIZE_MEDIUM  1024
#define JSON_DOC_SIZE_LARGE   2048

// Batería
#define BATTERY_PIN             1

//Power Manager
#define POWER_3V3_PIN           P00
#define POWER_STABILIZE_DELAY   20

// Configuración default sensores
#define DEFAULT_SENSOR_CONFIGS { \
    {"R", "RTD1", RTD, true}, \
    {"D", "DS1", DS18B20, true}, \
    {"I2C", "SHT30", SHT30, true} \
}

#endif


#ifdef DEVICE_TYPE_ANALOGIC

// Pines generales
#define ONE_WIRE_BUS        1
#define I2C_SDA_PIN         19
#define I2C_SCL_PIN         18
#define I2C_ADDRESS_PCA9555 0x20

// SPI
#define SPI_SCK_PIN         10
#define SPI_MISO_PIN        6
#define SPI_MOSI_PIN        7
#define SPI_RTD_CLOCK       1000000
#define SPI_RADIO_CLOCK     100000

// PT100
#define PT100_CS_PIN        P03

// Modo Config
#define CONFIG_PIN          2
#define CONFIG_TRIGGER_TIME 5000
#define CONFIG_TIMEOUT      30000
#define CONFIG_LED_PIN      P11

// LoRa
#define LORA_NSS_PIN        8
#define LORA_BUSY_PIN       4
#define LORA_RST_PIN        5
#define LORA_DIO1_PIN       3
#define MAX_LORA_PAYLOAD    200

// Serial
#define SERIAL_BAUD_RATE         115200

// Deep Sleep
#define DEFAULT_TIME_TO_SLEEP   30

// Identificadores
#define DEFAULT_DEVICE_ID   "DEV01"
#define DEFAULT_STATION_ID  "ST001"

// LoRa (OTAA)
#define DEFAULT_JOIN_EUI    "00,00,00,00,00,00,00,00"
#define DEFAULT_DEV_EUI     "1f,d4,e6,68,46,8c,e1,b7"
#define DEFAULT_APP_KEY     "1d,fb,69,80,69,d6,a0,7e,5d,bf,29,ba,6b,37,d3,04"
#define DEFAULT_NWK_KEY     "82,91,e9,55,19,ab,c0,6c,86,25,63,68,e7,f4,5a,89"

// LoRa Region y SubBand
#define LORA_REGION         US915
#define LORA_SUBBAND        2       // For US915, use 2; for other regions, use 0

#define BLE_SERVICE_UUID             "180A"
#define BLE_CHAR_SYSTEM_UUID         "2A37"
#define BLE_CHAR_SENSORS_UUID        "2A40"
#define BLE_CHAR_LORA_CONFIG_UUID    "2A41"
#define BLE_CHAR_NTC100K_UUID        "2A38"
#define BLE_CHAR_NTC10K_UUID         "2A39"
#define BLE_CHAR_CONDUCTIVITY_UUID   "2A3C"
#define BLE_CHAR_PH_UUID             "2A3B"
#define BLE_DEVICE_PREFIX            "AGRICOS_"

// Calibración batería
const double R1 = 1000000.0;
const double R2 = 1500000.0;
const double conversionFactor = (R1 + R2) / R1;

// Namespaces
#define NAMESPACE_SYSTEM        "system"
#define NAMESPACE_SENSORS       "sensors"
#define NAMESPACE_LORAWAN       "lorawan"
#define NAMESPACE_LORA_SESSION  "lorasession"
#define NAMESPACE_SENSORS_MODBUS "sensors_modbus"

// Claves
#define KEY_INITIALIZED         "initialized"
#define KEY_SLEEP_TIME          "sleep_time"
#define KEY_STATION_ID          "stationId"
#define KEY_DEVICE_ID           "deviceId"
#define KEY_VOLT                "volt"
#define KEY_SENSOR              "k"
#define KEY_SENSOR_ID           "id"
#define KEY_SENSOR_ID_TEMPERATURE_SENSOR "ts"
#define KEY_SENSOR_TYPE         "t"
#define KEY_SENSOR_ENABLE       "e"
#define KEY_LORA_JOIN_EUI       "joinEUI"
#define KEY_LORA_DEV_EUI        "devEUI"
#define KEY_LORA_NWK_KEY        "nwkKey"
#define KEY_LORA_APP_KEY        "appKey"
#define KEY_LORAWAN_SESSION     "lorawan_session"

// Claves para Modbus
#define KEY_MODBUS_SENSOR_ID    "id"
#define KEY_MODBUS_SENSOR_TYPE  "t"
#define KEY_MODBUS_SENSOR_ADDR  "a"
#define KEY_MODBUS_SENSOR_ENABLE "e"

// Configuración Modbus
#define MODBUS_BAUDRATE         9600
#define MODBUS_SERIAL_CONFIG    SERIAL_8N1
#define MODBUS_RESPONSE_TIMEOUT 300  // Tiempo de espera para respuesta en ms
#define MODBUS_MAX_RETRY        3     // Número máximo de intentos de lectura Modbus


// Tamaños de documentos JSON - Centralizados
#define JSON_DOC_SIZE_SMALL   300
#define JSON_DOC_SIZE_MEDIUM  1024
#define JSON_DOC_SIZE_LARGE   2048

// Batería
#define POWER_3V3_PIN           P00
#define POWER_12V_PIN           P01
#define POWER_2V5_PIN           P02
#define POWER_STABILIZE_DELAY   1

// ADS124S08
#define ADS124S08_CS_PIN        P05
#define ADS124S08_DRDY_PIN      P06
#define ADS124S08_RST_PIN       P13
#define ADS124S08_START_PIN     P14
#define SPI_ADC_CLOCK           1000000

// FlowSensor
#define FLOW_SENSOR_PIN         0

// Namespaces analógicos
#define NAMESPACE_NTC100K   "ntc_100k"
#define NAMESPACE_NTC10K    "ntc_10k"
#define NAMESPACE_COND      "cond"
#define NAMESPACE_PH        "ph"

// Calibración NTC 100K
#define DEFAULT_T1_100K     25.0
#define DEFAULT_R1_100K     100000.0
#define DEFAULT_T2_100K     35.0
#define DEFAULT_R2_100K     64770.0
#define DEFAULT_T3_100K     45.0
#define DEFAULT_R3_100K     42530.0

// Calibración NTC 10K
#define DEFAULT_T1_10K      25.0
#define DEFAULT_R1_10K      10000.0
#define DEFAULT_T2_10K      35.0
#define DEFAULT_R2_10K      6477.0
#define DEFAULT_T3_10K      45.0
#define DEFAULT_R3_10K      4253.0

// Calibración Conductividad
#define CONDUCTIVITY_DEFAULT_V1    0.010314f
#define CONDUCTIVITY_DEFAULT_T1    84.0f
#define CONDUCTIVITY_DEFAULT_V2    0.175384f
#define CONDUCTIVITY_DEFAULT_T2    1413.0f
#define CONDUCTIVITY_DEFAULT_V3    1.407745f
#define CONDUCTIVITY_DEFAULT_T3    12880.0f
#define TEMP_COEF_COMPENSATION     0.02f
#define CONDUCTIVITY_DEFAULT_TEMP  24.22f

// Calibración pH
#define PH_DEFAULT_V1          0.4425
#define PH_DEFAULT_T1          4.01
#define PH_DEFAULT_V2          0.001
#define PH_DEFAULT_T2          6.86
#define PH_DEFAULT_V3         -0.32155
#define PH_DEFAULT_T3          9.18
#define PH_DEFAULT_TEMP        25.0

// Claves NTC100K
#define KEY_NTC100K_T1         "n100k_t1"
#define KEY_NTC100K_R1         "n100k_r1"
#define KEY_NTC100K_T2         "n100k_t2"
#define KEY_NTC100K_R2         "n100k_r2"
#define KEY_NTC100K_T3         "n100k_t3"
#define KEY_NTC100K_R3         "n100k_r3"

// Claves NTC10K
#define KEY_NTC10K_T1          "n10k_t1"
#define KEY_NTC10K_R1          "n10k_r1"
#define KEY_NTC10K_T2          "n10k_t2"
#define KEY_NTC10K_R2          "n10k_r2"
#define KEY_NTC10K_T3          "n10k_t3"
#define KEY_NTC10K_R3          "n10k_r3"

// Claves Conductividad
#define KEY_CONDUCT_CT         "c_ct"
#define KEY_CONDUCT_CC         "c_cc"
#define KEY_CONDUCT_V1         "c_v1"
#define KEY_CONDUCT_T1         "c_t1"
#define KEY_CONDUCT_V2         "c_v2"
#define KEY_CONDUCT_T2         "c_t2"
#define KEY_CONDUCT_V3         "c_v3"
#define KEY_CONDUCT_T3         "c_t3"

// Claves pH
#define KEY_PH_V1              "ph_v1"
#define KEY_PH_T1              "ph_t1"
#define KEY_PH_V2              "ph_v2"
#define KEY_PH_T2              "ph_t2"
#define KEY_PH_V3              "ph_v3"
#define KEY_PH_T3              "ph_t3"
#define KEY_PH_CT              "ph_ct"

// Configuración default sensores
#define  DEFAULT_SENSOR_CONFIGS { \
    {"0", "NTC1",  N100K, true}, \
    {"1", "NTC2",  N100K, true}, \
    {"2", "NTC3",  N10K, true}, \
    {"3", "HDS10",  HDS10, true}, \
    {"4", "COND",  COND, true}, \
    {"5", "SM1",   SOILH, true}, \
    {"8", "PH",    PH, true}, \
    {"R", "RTD1",  RTD, true}, \
    {"D", "DS1",   DS18B20, true}, \
    {"I2C", "SHT30", SHT30, true} \
}

// Sin sensores Modbus registrados
#define DEFAULT_MODBUS_SENSOR_CONFIGS { }

// Límites de temperatura NTC para evitar lecturas erróneas cuando esta desconectado
#define NTC_TEMP_MIN           -20.0   // Temperatura mínima válida en °C
#define NTC_TEMP_MAX            100.0   // Temperatura máxima válida en °C

#endif


#ifdef DEVICE_TYPE_MODBUS

// Pines generales
#define I2C_SDA_PIN         19
#define I2C_SCL_PIN         18
#define I2C_ADDRESS_PCA9555 0x20

// SPI
#define SPI_SCK_PIN         10
#define SPI_MISO_PIN        6
#define SPI_MOSI_PIN        7
#define SPI_RTD_CLOCK       1000000
#define SPI_RADIO_CLOCK     100000

// PT100
#define PT100_CS_PIN        P03

// FlowSensor
#define FLOW_SENSOR_PIN     0

// Batería
#define BATTERY_PIN         1

// Modo Config
#define CONFIG_PIN          2
#define CONFIG_TRIGGER_TIME 5000
#define CONFIG_TIMEOUT      30000
#define CONFIG_LED_PIN      P11

// LoRa
#define LORA_NSS_PIN        8
#define LORA_BUSY_PIN       4
#define LORA_RST_PIN        5
#define LORA_DIO1_PIN       3
#define MAX_LORA_PAYLOAD    200

// Serial
#define SERIAL_BAUD_RATE         115200

// Deep Sleep
#define DEFAULT_TIME_TO_SLEEP   30

// Identificadores
#define DEFAULT_DEVICE_ID   "DEV01"
#define DEFAULT_STATION_ID  "ST001"

// LoRa (OTAA)
#define DEFAULT_JOIN_EUI    "00,00,00,00,00,00,00,00"
#define DEFAULT_DEV_EUI     "1f,d4,e6,68,46,8c,e1,b7"
#define DEFAULT_APP_KEY     "1d,fb,69,80,69,d6,a0,7e,5d,bf,29,ba,6b,37,d3,04"
#define DEFAULT_NWK_KEY     "82,91,e9,55,19,ab,c0,6c,86,25,63,68,e7,f4,5a,89"

// LoRa Region y SubBand
#define LORA_REGION         US915
#define LORA_SUBBAND        2

#define BLE_SERVICE_UUID             "180A"
#define BLE_CHAR_SYSTEM_UUID         "2A37"
#define BLE_CHAR_SENSORS_UUID        "2A40"
#define BLE_CHAR_LORA_CONFIG_UUID    "2A41"
#define BLE_DEVICE_PREFIX            "AGRICOS_"

// Calibración batería
const double R1 = 470000.0;
const double R2 = 1500000.0;
const double conversionFactor = (R1 + R2) / R1;

// Namespaces
#define NAMESPACE_SYSTEM                "system"
#define NAMESPACE_SENSORS               "sensors"
#define NAMESPACE_LORAWAN               "lorawan"
#define NAMESPACE_LORA_SESSION          "lorasession"
#define NAMESPACE_SENSORS_MODBUS        "sensors_modbus"

// Claves
#define KEY_INITIALIZED                  "initialized"
#define KEY_SLEEP_TIME                   "sleep_time"
#define KEY_STATION_ID                   "stationId"
#define KEY_DEVICE_ID                    "deviceId"
#define KEY_VOLT                         "volt"
#define KEY_SENSOR                       "k"
#define KEY_SENSOR_ID                    "id"
#define KEY_SENSOR_ID_TEMPERATURE_SENSOR "ts"
#define KEY_SENSOR_TYPE                  "t"
#define KEY_SENSOR_ENABLE                "e"
#define KEY_LORA_JOIN_EUI                "joinEUI"
#define KEY_LORA_DEV_EUI                 "devEUI"
#define KEY_LORA_NWK_KEY                 "nwkKey"
#define KEY_LORA_APP_KEY                 "appKey"
#define KEY_LORAWAN_SESSION              "lorawan_session"

// Claves para Modbus
#define KEY_MODBUS_SENSOR_ID    "id"
#define KEY_MODBUS_SENSOR_TYPE  "t"
#define KEY_MODBUS_SENSOR_ADDR  "a"
#define KEY_MODBUS_SENSOR_ENABLE "e"

// Configuración Modbus
#define MODBUS_BAUDRATE         9600
#define MODBUS_SERIAL_CONFIG    SERIAL_8N1
#define MODBUS_RESPONSE_TIMEOUT 300  // Tiempo de espera para respuesta en ms
#define MODBUS_MAX_RETRY        3     // Número máximo de intentos de lectura Modbus

// Tamaños JSON
#define JSON_DOC_SIZE_SMALL   300
#define JSON_DOC_SIZE_MEDIUM  1024
#define JSON_DOC_SIZE_LARGE   2048

// Power management
#define POWER_3V3_PIN           P00
#define POWER_12V_PIN           P01
#define POWER_STABILIZE_DELAY   20

// Configuración default sensores
#define DEFAULT_SENSOR_CONFIGS { \
    {"R", "RTD1", RTD, 0, "", true}, \
    {"D", "DS1", DS18B20, 0, "", true}, \
    {"I2C", "SHT30", SHT30, 0, "", true} \
}

// Sin sensores Modbus registrados
#define DEFAULT_MODBUS_SENSOR_CONFIGS { }

#endif

#endif // CONFIG_H

================
File: src/SensorManager.cpp
================
#include "SensorManager.h"
#include <Wire.h>
#include <SPI.h>
#include <cmath>  // Para fabs() y otras funciones matemáticas
#if defined(DEVICE_TYPE_BASIC) || defined(DEVICE_TYPE_ANALOGIC)
#include <DallasTemperature.h>
#endif
#include "MAX31865.h"
#include "sensor_types.h"
#include "config.h"
#include <Preferences.h>
#include "config_manager.h"
#include "debug.h"
#include "sensor_constants.h"  // Para tiempos de estabilización
#include "utilities.h"

#ifdef DEVICE_TYPE_ANALOGIC
#include "ADS124S08.h"
#include "sensors/NtcManager.h"
#include "AdcUtilities.h"
#include "sensors/PHSensor.h"
#include "sensors/ConductivitySensor.h"
#include "sensors/HDS10Sensor.h"
extern ADS124S08 ADC;
#endif

// Inclusión de nuevos sensores
#include "sensors/RTDSensor.h"
#include "sensors/SHT30Sensor.h"
#if defined(DEVICE_TYPE_BASIC) || defined(DEVICE_TYPE_ANALOGIC)
#include "sensors/DS18B20Sensor.h"
#endif

// -------------------------------------------------------------------------------------
// Métodos de la clase SensorManager
// -------------------------------------------------------------------------------------

void SensorManager::beginSensors() {
    // Encender alimentación 3.3V
    powerManager.power3V3On();
    
#ifdef DEVICE_TYPE_ANALOGIC
    // Encender alimentación 2.5V solo para dispositivos ANALOGIC
    powerManager.power2V5On();
#endif

    // Inicializar RTD y configurarlo
    rtd.begin();
    {
        bool vBias = true;
        bool autoConvert = true;
        bool oneShot = false;
        bool threeWire = false;
        uint8_t faultCycle = 0; // MAX31865_FAULT_DETECTION_NONE
        bool faultClear = true;
        bool filter50Hz = true;
        uint16_t lowTh = 0x0000;
        uint16_t highTh = 0x7fff;
        rtd.configure(vBias, autoConvert, oneShot, threeWire, faultCycle, faultClear, filter50Hz, lowTh, highTh);
    }

#if defined(DEVICE_TYPE_BASIC) || defined(DEVICE_TYPE_ANALOGIC)
    // TIEMPO ejecución ≈ 65 ms
    // Inicializar DS18B20
    dallasTemp.begin();
    dallasTemp.requestTemperatures();
    ////////////////////////////////////////////////////////////////
#endif

#ifdef DEVICE_TYPE_ANALOGIC
    // TIEMPO ejecución ≈ 15 ms
    ADC.begin();
    // Reset del ADC
    ADC.sendCommand(RESET_OPCODE_MASK);
    delay(1);
    // Asegurarse de que el ADC esté despierto
    ADC.sendCommand(WAKE_OPCODE_MASK);
    
    // Configurar ADC con referencia interna
    ADC.regWrite(REF_ADDR_MASK, ADS_REFINT_ON_ALWAYS | ADS_REFSEL_INT);
    
    // Deshabilitar PGA (bypass)
    ADC.regWrite(PGA_ADDR_MASK, ADS_PGA_BYPASS); // PGA_EN = 0, ganancia ignorada
    
    // Ajustar velocidad de muestreo
    ADC.regWrite(DATARATE_ADDR_MASK, ADS_DR_4000); //EL PCA NO MANEJA DR MAS BAJOS
    
    // Iniciar conversión continua
    ADC.reStart();
    ////////////////////////////////////////////////////////////////
#endif
}

SensorReading SensorManager::getSensorReading(const SensorConfig &cfg) {
    SensorReading reading;
    strncpy(reading.sensorId, cfg.sensorId, sizeof(reading.sensorId) - 1);
    reading.sensorId[sizeof(reading.sensorId) - 1] = '\0';
    reading.type = cfg.type;
    reading.value = NAN;

    readSensorValue(cfg, reading);

    return reading;
}

/**
 * @brief Lógica principal para leer el valor de cada sensor normal (no Modbus) según su tipo.
 */
float SensorManager::readSensorValue(const SensorConfig &cfg, SensorReading &reading) {
    switch (cfg.type) {
        case N100K:
#ifdef DEVICE_TYPE_ANALOGIC
            // Usar NtcManager para obtener la temperatura
            reading.value = NtcManager::readNtc100kTemperature(cfg.configKey);
#else
            reading.value = NAN;
#endif
            break;

        case N10K:
#ifdef DEVICE_TYPE_ANALOGIC
            // Usar NtcManager para obtener la temperatura del NTC de 10k
            reading.value = NtcManager::readNtc10kTemperature();
#else
            reading.value = NAN;
#endif
            break;
            
        case HDS10:
#ifdef DEVICE_TYPE_ANALOGIC
            // Leer sensor HDS10 y obtener el porcentaje de humedad
            reading.value = HDS10Sensor::read();
#else
            reading.value = NAN;
#endif
            break;
            
        case PH:
#ifdef DEVICE_TYPE_ANALOGIC
            // Leer sensor de pH y obtener valor
            reading.value = PHSensor::read();
#else
            reading.value = NAN;
#endif
            break;

        case COND:
#ifdef DEVICE_TYPE_ANALOGIC
            // Leer sensor de conductividad y obtener valor en ppm
            reading.value = ConductivitySensor::read();
#else
            reading.value = NAN;
#endif
            break;
        
        case SOILH:
            reading.value = NAN; 
            break;

        case RTD:
            reading.value = RTDSensor::read();
            break;

#if defined(DEVICE_TYPE_BASIC) || defined(DEVICE_TYPE_ANALOGIC)
        case DS18B20:
            reading.value = DS18B20Sensor::read();
            break;
#endif

        case SHT30:
        {
            float tmp = 0.0f, hum = 0.0f;
            SHT30Sensor::read(tmp, hum);
            reading.subValues.clear();
            {
                SubValue sT; strncpy(sT.key, "T", sizeof(sT.key)); sT.value = tmp;
                reading.subValues.push_back(sT);
            }
            {
                SubValue sH; strncpy(sH.key, "H", sizeof(sH.key)); sH.value = hum;
                reading.subValues.push_back(sH);
            }
            // Asignar el valor principal como NAN si alguno de los valores falló
            reading.value = (isnan(tmp) || isnan(hum)) ? NAN : tmp;
        }
        break;

        default:
            reading.value = NAN;
            break;
    }
    return reading.value;
}

#if defined(DEVICE_TYPE_ANALOGIC) || defined(DEVICE_TYPE_MODBUS)
ModbusSensorReading SensorManager::getModbusSensorReading(const ModbusSensorConfig& cfg) {
    ModbusSensorReading reading;
    
    // Copiar el ID del sensor
    strlcpy(reading.sensorId, cfg.sensorId, sizeof(reading.sensorId));
    reading.type = cfg.type;
    
    // Leer sensor según su tipo
    switch (cfg.type) {
        case ENV4:
            reading = ModbusSensorManager::readEnvSensor(cfg);
            break;
        // Añadir casos para otros tipos de sensores Modbus
        default:
            DEBUG_PRINTLN("Tipo de sensor Modbus no soportado");
            break;
    }
    
    return reading;
}
#endif

void SensorManager::getAllSensorReadings(std::vector<SensorReading>& normalReadings
#if defined(DEVICE_TYPE_ANALOGIC) || defined(DEVICE_TYPE_MODBUS)
                                        , std::vector<ModbusSensorReading>& modbusReadings
#endif
                                        ) {
    // Obtener configuraciones de sensores habilitados
    auto enabledNormalSensors = ConfigManager::getEnabledSensorConfigs();
#if defined(DEVICE_TYPE_ANALOGIC) || defined(DEVICE_TYPE_MODBUS)
    auto enabledModbusSensors = ConfigManager::getEnabledModbusSensorConfigs();
#endif
    
    // Reservar espacio para los vectores
    normalReadings.reserve(enabledNormalSensors.size());
#if defined(DEVICE_TYPE_ANALOGIC) || defined(DEVICE_TYPE_MODBUS)
    modbusReadings.reserve(enabledModbusSensors.size());
#endif
    
    // Leer sensores normales
    for (const auto &sensor : enabledNormalSensors) {
        uint32_t startTime = millis();
        SensorReading sensorReading = getSensorReading(sensor);
        uint32_t elapsedTime = millis() - startTime;
        
        DEBUG_PRINTF("Sensor %s (tipo %d) medido en %u ms\n", 
                    sensorReading.sensorId, 
                    (int)sensorReading.type, 
                    elapsedTime);
                    
        normalReadings.push_back(sensorReading);
    }
    
#if defined(DEVICE_TYPE_ANALOGIC) || defined(DEVICE_TYPE_MODBUS)
    // Si hay sensores Modbus, inicializar comunicación, leerlos y finalizar
    if (!enabledModbusSensors.empty()) {
        // Determinar el tiempo máximo de estabilización necesario
        uint32_t maxStabilizationTime = 0;
        
        // Revisar cada sensor habilitado para encontrar el tiempo máximo
        for (const auto &sensor : enabledModbusSensors) {
            uint32_t sensorStabilizationTime = 0;
            
            // Obtener el tiempo de estabilización según el tipo de sensor
            switch (sensor.type) {
                case ENV4:
                    sensorStabilizationTime = SENSOR_MODBUS_ENV4_STABILIZATION_TIME;
                    break;
                // Añadir casos para otros tipos de sensores Modbus con sus respectivos tiempos
                default:
                    sensorStabilizationTime = 500; // Tiempo predeterminado si no se especifica
                    break;
            }
            
            // Actualizar el tiempo máximo si este sensor necesita más tiempo
            if (sensorStabilizationTime > maxStabilizationTime) {
                maxStabilizationTime = sensorStabilizationTime;
            }
        }
        
        // Encender alimentación de 12V para sensores Modbus
#if defined(DEVICE_TYPE_MODBUS) || defined(DEVICE_TYPE_ANALOGIC)
        powerManager.power12VOn();
        DEBUG_PRINTF("Esperando %u ms para estabilización de sensores Modbus\n", maxStabilizationTime);
        delay(maxStabilizationTime);
#endif
        
        // Inicializar comunicación Modbus antes de comenzar las mediciones
        ModbusSensorManager::beginModbus();
        
        // Leer todos los sensores Modbus
        for (const auto &sensor : enabledModbusSensors) {
            modbusReadings.push_back(getModbusSensorReading(sensor));
        }
        
        // Finalizar comunicación Modbus después de completar todas las lecturas
        ModbusSensorManager::endModbus();
        
        // Apagar alimentación de 12V después de completar las lecturas
#if defined(DEVICE_TYPE_MODBUS) || defined(DEVICE_TYPE_ANALOGIC)
        powerManager.power12VOff();
#endif
    }
#endif
}

#ifdef DEVICE_TYPE_ANALOGIC
// Las funciones de sensores se han movido a sus propias clases
#endif



================================================================
End of Codebase
================================================================
